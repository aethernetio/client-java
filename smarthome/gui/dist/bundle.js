/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/aether-client/build/LogPrinter.js":
/*!********************************************************!*\
  !*** ./node_modules/aether-client/build/LogPrinter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: LogPrinter.ts\n// PURPOSE: Column-based log formatter and printer for the Aether logging system.\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogPrinter = exports.ColumnBase = void 0;\nconst aether_astring_1 = __webpack_require__(/*! ./aether_astring */ \"./node_modules/aether-client/build/aether_astring.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\n/**\n * Base implementation of Column decorators to avoid reimplementing them.\n */\nclass ColumnBase {\n    min(width) {\n        const self = this;\n        return new class extends ColumnBase {\n            getKey() { return self.getKey(); }\n            print(printer, out, node, workKeys) {\n                const startLen = out.length;\n                self.print(printer, out, node, workKeys);\n                const endLen = out.length;\n                const diff = endLen - startLen;\n                if (diff < width) {\n                    out.addSpace(width - diff);\n                }\n            }\n        }();\n    }\n    max(width) {\n        const self = this;\n        return new class extends ColumnBase {\n            getKey() { return self.getKey(); }\n            print(printer, out, node, workKeys) {\n                // We pass a *limited* AString wrapper to the underlying print method\n                self.print(printer, out.limit(width), node, workKeys);\n            }\n        }();\n    }\n    style(style, color) {\n        const self = this;\n        return new class extends ColumnBase {\n            getKey() { return self.getKey(); }\n            print(printer, out, node, workKeys) {\n                out.style(style, color);\n                self.print(printer, out, node, workKeys);\n                out.styleClear();\n            }\n        }();\n    }\n    foregroundColorRGB(r, g, b) {\n        const self = this;\n        return new class extends ColumnBase {\n            getKey() { return self.getKey(); }\n            print(printer, out, node, workKeys) {\n                out.styleForeground(null, r, g, b);\n                self.print(printer, out, node, workKeys);\n                out.styleClear();\n            }\n        }();\n    }\n}\nexports.ColumnBase = ColumnBase;\n/**\n * A LogPrinter listens for log events and prints them to the console\n * using a configurable set of columns.\n */\nclass LogPrinter {\n    filter;\n    columns;\n    keys;\n    listenerDisposer;\n    /**\n     * @param columns An array of Column definitions.\n     * @param filter An optional filter to apply. Only nodes passing this filter will be printed.\n     */\n    constructor(columns, filter = () => true) {\n        this.columns = columns;\n        this.filter = filter;\n        // Collect all primary keys from columns\n        this.keys = new Set();\n        for (const c of columns) {\n            const key = c.getKey();\n            if (key)\n                this.keys.add(key);\n        }\n        // Add this printer as a listener to the global logger\n        this.listenerDisposer = aether_logging_1.Log.addListener(filter, (node) => {\n            this.printRow(aether_astring_1.AString.of(), node);\n        });\n    }\n    /**\n     * Prints a single log node to the console (the default destination).\n     * @param s An empty AString to build the output.\n     * @param n The LNode to print.\n     */\n    printRow(s, n) {\n        let line = this.printNode(s, n).toString();\n        if (console) {\n            console.log(line);\n        }\n        else if (process) {\n            process.stdout.write(line + '\\n');\n        }\n    }\n    /**\n     * Renders the LNode into the AString according to the column rules.\n     * Can be overridden by subclasses (e.g., to add color).\n     * @param s The AString buffer.\n     * @param n The LNode to print.\n     * @returns The same AString buffer (for chaining).\n     */\n    printNode(s, n) {\n        const workKeys = new Set();\n        // Print all defined columns\n        for (const c of this.columns) {\n            c.print(this, s, n, workKeys);\n        }\n        // If it's an error, append the stack trace\n        const err = n.get(aether_logging_1.LogKeys.EXCEPTION_STR);\n        if (err) {\n            s.add(\"\\n\");\n            // AString.addStackTrace is a mock, so we'll just add the stack manually.\n            s.add(err.stack || err.message);\n        }\n        return s;\n    }\n    /**\n     * Removes the listener from the global logger.\n     */\n    [Symbol.dispose]() {\n        this.listenerDisposer[Symbol.dispose]();\n    }\n    // --- Static Column Factories ---\n    /**\n     * Creates a column that prints a static string separator.\n     * @param text The static text to print.\n     */\n    static splitter(text) {\n        return new class extends ColumnBase {\n            getKey() {\n                return null;\n            }\n            print = (_p, out) => {\n                out.add(text);\n            };\n        }();\n    }\n    /**\n     * Creates a column that prints all remaining key-value pairs\n     * that haven't been printed by other columns.\n     */\n    static colAll() {\n        return new class extends ColumnBase {\n            getKey() {\n                return null;\n            }\n            print(_p, out, node, workKeys) {\n                out.add('{');\n                let first = true;\n                node.forEach((key, value) => {\n                    // Skip if already printed OR is a default log key\n                    if (workKeys.has(key) || Object.values(aether_logging_1.LogKeys).includes(key)) {\n                        return;\n                    }\n                    if (first)\n                        first = false;\n                    else\n                        out.add(\", \");\n                    out.add(key).add('=').add(value);\n                });\n                out.add('}');\n            }\n        }();\n    }\n    /**\n     * Creates a column that prints the value for a specific key.\n     * @param key The key to retrieve from the LNode.\n     * @param mapper An optional function to transform the value before printing.\n     */\n    static col(key, mapper) {\n        return new class extends ColumnBase {\n            getKey = () => key;\n            print(_p, out, node, workKeys) {\n                let v = node.get(key);\n                if (v !== undefined) {\n                    if (mapper) {\n                        v = mapper(v);\n                    }\n                    out.add(v);\n                }\n                workKeys.add(key);\n            }\n        }();\n    }\n}\nexports.LogPrinter = LogPrinter;\n//# sourceMappingURL=LogPrinter.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/LogPrinter.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_api.js":
/*!********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_api.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PairKeysSign = exports.PairKeysAsymSigned = exports.PairKeysAsym = exports.MoneyOperation = exports.Message = exports.IPAddressV6 = exports.IPAddressV4 = exports.IPAddressAndPortsList = exports.IPAddressAndPorts = exports.HydrogenSignPublic = exports.HydrogenSignPrivate = exports.HydrogenSecretBox = exports.HydrogenCurvePublic = exports.HydrogenCurvePrivate = exports.FinishResult = exports.CoderAndPort = exports.Cloud = exports.ClientStateForSave = exports.ClientInfo = exports.AetherStructDescriptor = exports.AetherStreamType = exports.AetherNullableType = exports.AetherModuleDescriptor = exports.AetherMethodDescriptor = exports.AetherFieldDescriptor = exports.AetherBaseType = exports.AetherArrayType = exports.AetherArgumentDescriptor = exports.AetherApiDefinition = exports.AccessGroup = exports.AccessCheckResult = exports.AccessCheckPair = exports.WorkProofConfig = exports.Telemetry = exports.Sign = exports.PairKeys = exports.KeySymmetric = exports.KeySignPublic = exports.KeySignPrivate = exports.KeySign = exports.KeyAsymmetricPublic = exports.KeyAsymmetricPrivate = exports.KeyAsymmetric = exports.Key = exports.IPAddress = exports.AetherTypeDescriptor = exports.Status = exports.PowMethod = exports.CryptoLib = exports.AetherCodec = void 0;\nexports.RegistrationRootApiLocal = exports.RegistrationRootApi = exports.ServerRegistrationApiLocal = exports.ServerRegistrationApi = exports.GlobalRegServerApiLocal = exports.GlobalRegServerApi = exports.ClientApiRegUnsafeLocal = exports.ClientApiRegUnsafe = exports.GlobalRegClientApiLocal = exports.GlobalRegClientApi = exports.ClientApiRegSafeLocal = exports.ClientApiRegSafe = exports.ServerApiByUidLocal = exports.ServerApiByUid = exports.ServerApiByUidClientLocal = exports.ServerApiByUidClient = exports.LoginApiLocal = exports.LoginApi = exports.AuthorizedApiLocal = exports.AuthorizedApi = exports.ClientApiSafeLocal = exports.ClientApiSafe = exports.ClientApiUnsafeLocal = exports.ClientApiUnsafe = exports.ServerRegistrationApiStream = exports.LoginStream = exports.LoginClientStream = exports.GlobalRegClientApiStream = exports.GlobalApi = exports.ClientInteractionClientStream = exports.ClientApiStream = exports.ClientApiRegSafeStream = exports.WorkProofDTO = exports.WorkProofBCrypt = exports.UUIDAndCloud = exports.TelemetryCPP = exports.SodiumSignPublic = exports.SodiumSignPrivate = exports.SodiumCurvePublic = exports.SodiumCurvePrivate = exports.SodiumChacha20Poly1305 = exports.SignHYDROGEN = exports.SignedKey = exports.SignAE_ED25519 = exports.ServerDescriptor = void 0;\nconst aether_client_1 = __webpack_require__(/*! ./aether_client */ \"./node_modules/aether-client/build/aether_client.js\");\nconst Impl = __importStar(__webpack_require__(/*! ./aether_api_impl */ \"./node_modules/aether-client/build/aether_api_impl.js\"));\n// This is always relative\nvar AetherCodec;\n(function (AetherCodec) {\n    AetherCodec[\"TCP\"] = \"TCP\";\n    AetherCodec[\"UDP\"] = \"UDP\";\n    AetherCodec[\"WS\"] = \"WS\";\n    AetherCodec[\"WSS\"] = \"WSS\";\n})(AetherCodec || (exports.AetherCodec = AetherCodec = {}));\n(function (AetherCodec) {\n    AetherCodec.META = new Impl.AetherCodecMetaImpl();\n})(AetherCodec || (exports.AetherCodec = AetherCodec = {}));\nvar CryptoLib;\n(function (CryptoLib) {\n    CryptoLib[\"SODIUM\"] = \"SODIUM\";\n    CryptoLib[\"HYDROGEN\"] = \"HYDROGEN\";\n})(CryptoLib || (exports.CryptoLib = CryptoLib = {}));\n(function (CryptoLib) {\n    CryptoLib.META = new Impl.CryptoLibMetaImpl();\n})(CryptoLib || (exports.CryptoLib = CryptoLib = {}));\nvar PowMethod;\n(function (PowMethod) {\n    PowMethod[\"AE_BCRYPT_CRC32\"] = \"AE_BCRYPT_CRC32\";\n})(PowMethod || (exports.PowMethod = PowMethod = {}));\n(function (PowMethod) {\n    PowMethod.META = new Impl.PowMethodMetaImpl();\n})(PowMethod || (exports.PowMethod = PowMethod = {}));\nvar Status;\n(function (Status) {\n    Status[\"PENDING\"] = \"PENDING\";\n    Status[\"COMPLETED\"] = \"COMPLETED\";\n    Status[\"FAILED\"] = \"FAILED\";\n})(Status || (exports.Status = Status = {}));\n(function (Status) {\n    Status.META = new Impl.StatusMetaImpl();\n})(Status || (exports.Status = Status = {}));\n/**\n * Represents the abstract AetherTypeDescriptor structure.\n */\nclass AetherTypeDescriptor {\n    id;\n    docId;\n    static META = new Impl.AetherTypeDescriptorMetaImpl();\n    /**\n     * Creates an instance of AetherTypeDescriptor.\n     * @param id - bigint\n     * @param docId - bigint\n     */\n    constructor(id, docId) {\n        this.id = id;\n        this.docId = docId;\n    }\n    getId() {\n        return this.id;\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherTypeDescriptor.\n     * @param {AetherTypeDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherTypeDescriptor with another object.\n     * @param {AetherTypeDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.AetherTypeDescriptor = AetherTypeDescriptor;\n/**\n * Represents the abstract IPAddress structure.\n */\nclass IPAddress {\n    static META = new Impl.IPAddressMetaImpl();\n    /**\n     * Creates an instance of IPAddress.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of IPAddress.\n     * @param {IPAddress | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of IPAddress with another object.\n     * @param {IPAddress | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.IPAddress = IPAddress;\n/**\n * Represents the abstract Key structure.\n */\nclass Key {\n    static META = new Impl.KeyMetaImpl();\n    /**\n     * Creates an instance of Key.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of Key.\n     * @param {Key | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Key with another object.\n     * @param {Key | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.Key = Key;\n/**\n * Represents the abstract KeyAsymmetric structure.\n */\nclass KeyAsymmetric extends Key {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeyAsymmetricMetaImpl();\n    /**\n     * Creates an instance of KeyAsymmetric.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeyAsymmetric.\n     * @param {KeyAsymmetric | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeyAsymmetric with another object.\n     * @param {KeyAsymmetric | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeyAsymmetric = KeyAsymmetric;\n/**\n * Represents the abstract KeyAsymmetricPrivate structure.\n */\nclass KeyAsymmetricPrivate extends KeyAsymmetric {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeyAsymmetricPrivateMetaImpl();\n    /**\n     * Creates an instance of KeyAsymmetricPrivate.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeyAsymmetricPrivate.\n     * @param {KeyAsymmetricPrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeyAsymmetricPrivate with another object.\n     * @param {KeyAsymmetricPrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeyAsymmetricPrivate = KeyAsymmetricPrivate;\n/**\n * Represents the abstract KeyAsymmetricPublic structure.\n */\nclass KeyAsymmetricPublic extends KeyAsymmetric {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeyAsymmetricPublicMetaImpl();\n    /**\n     * Creates an instance of KeyAsymmetricPublic.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeyAsymmetricPublic.\n     * @param {KeyAsymmetricPublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeyAsymmetricPublic with another object.\n     * @param {KeyAsymmetricPublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeyAsymmetricPublic = KeyAsymmetricPublic;\n/**\n * Represents the abstract KeySign structure.\n */\nclass KeySign extends Key {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeySignMetaImpl();\n    /**\n     * Creates an instance of KeySign.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeySign.\n     * @param {KeySign | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeySign with another object.\n     * @param {KeySign | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeySign = KeySign;\n/**\n * Represents the abstract KeySignPrivate structure.\n */\nclass KeySignPrivate extends KeySign {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeySignPrivateMetaImpl();\n    /**\n     * Creates an instance of KeySignPrivate.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeySignPrivate.\n     * @param {KeySignPrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeySignPrivate with another object.\n     * @param {KeySignPrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeySignPrivate = KeySignPrivate;\n/**\n * Represents the abstract KeySignPublic structure.\n */\nclass KeySignPublic extends KeySign {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeySignPublicMetaImpl();\n    /**\n     * Creates an instance of KeySignPublic.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeySignPublic.\n     * @param {KeySignPublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeySignPublic with another object.\n     * @param {KeySignPublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeySignPublic = KeySignPublic;\n/**\n * Represents the abstract KeySymmetric structure.\n */\nclass KeySymmetric extends Key {\n    getAetherTypeId() {\n        return -1;\n    }\n    static META = new Impl.KeySymmetricMetaImpl();\n    /**\n     * Creates an instance of KeySymmetric.\n     */\n    constructor() {\n        super();\n    }\n    /**\n     * Calculates a hash code for a static instance of KeySymmetric.\n     * @param {KeySymmetric | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of KeySymmetric with another object.\n     * @param {KeySymmetric | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.KeySymmetric = KeySymmetric;\n/**\n * Represents the abstract PairKeys structure.\n */\nclass PairKeys {\n    static META = new Impl.PairKeysMetaImpl();\n    /**\n     * Creates an instance of PairKeys.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of PairKeys.\n     * @param {PairKeys | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of PairKeys with another object.\n     * @param {PairKeys | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.PairKeys = PairKeys;\n/**\n * Represents the abstract Sign structure.\n */\nclass Sign {\n    static META = new Impl.SignMetaImpl();\n    /**\n     * Creates an instance of Sign.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of Sign.\n     * @param {Sign | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Sign with another object.\n     * @param {Sign | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.Sign = Sign;\n/**\n * Represents the abstract Telemetry structure.\n */\nclass Telemetry {\n    static META = new Impl.TelemetryMetaImpl();\n    /**\n     * Creates an instance of Telemetry.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of Telemetry.\n     * @param {Telemetry | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Telemetry with another object.\n     * @param {Telemetry | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.Telemetry = Telemetry;\n/**\n * Represents the abstract WorkProofConfig structure.\n */\nclass WorkProofConfig {\n    static META = new Impl.WorkProofConfigMetaImpl();\n    /**\n     * Creates an instance of WorkProofConfig.\n     */\n    constructor() {\n    }\n    /**\n     * Calculates a hash code for a static instance of WorkProofConfig.\n     * @param {WorkProofConfig | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of WorkProofConfig with another object.\n     * @param {WorkProofConfig | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.WorkProofConfig = WorkProofConfig;\n/**\n * Represents the AccessCheckPair structure.\n */\nclass AccessCheckPair {\n    sourceUid;\n    targetUid;\n    static META_BODY = new Impl.AccessCheckPairMetaBodyImpl();\n    static META = AccessCheckPair.META_BODY;\n    /**\n     * Creates an instance of AccessCheckPair.\n     * @param sourceUid - UUID\n     * @param targetUid - UUID\n     */\n    constructor(sourceUid, targetUid) {\n        this.sourceUid = sourceUid;\n        this.targetUid = targetUid;\n    }\n    getSourceUid() {\n        return this.sourceUid;\n    }\n    getTargetUid() {\n        return this.targetUid;\n    }\n    /**\n     * Calculates a hash code for a static instance of AccessCheckPair.\n     * @param {AccessCheckPair | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AccessCheckPair.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AccessCheckPair with another object.\n     * @param {AccessCheckPair | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AccessCheckPair.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AccessCheckPair.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AccessCheckPair.staticEquals(this, other);\n    }\n    toString(result) {\n        AccessCheckPair.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AccessCheckPair = AccessCheckPair;\n/**\n * Represents the AccessCheckResult structure.\n */\nclass AccessCheckResult {\n    sourceUid;\n    targetUid;\n    hasAccess;\n    static META_BODY = new Impl.AccessCheckResultMetaBodyImpl();\n    static META = AccessCheckResult.META_BODY;\n    /**\n     * Creates an instance of AccessCheckResult.\n     * @param sourceUid - UUID\n     * @param targetUid - UUID\n     * @param hasAccess - boolean\n     */\n    constructor(sourceUid, targetUid, hasAccess) {\n        this.sourceUid = sourceUid;\n        this.targetUid = targetUid;\n        this.hasAccess = hasAccess;\n    }\n    getSourceUid() {\n        return this.sourceUid;\n    }\n    getTargetUid() {\n        return this.targetUid;\n    }\n    isHasAccess() {\n        return this.hasAccess;\n    }\n    /**\n     * Calculates a hash code for a static instance of AccessCheckResult.\n     * @param {AccessCheckResult | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AccessCheckResult.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AccessCheckResult with another object.\n     * @param {AccessCheckResult | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AccessCheckResult.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AccessCheckResult.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AccessCheckResult.staticEquals(this, other);\n    }\n    toString(result) {\n        AccessCheckResult.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AccessCheckResult = AccessCheckResult;\n/**\n * Represents the AccessGroup structure.\n */\nclass AccessGroup {\n    owner;\n    id;\n    data;\n    static META_BODY = new Impl.AccessGroupMetaBodyImpl();\n    static META = AccessGroup.META_BODY;\n    /**\n     * Creates an instance of AccessGroup.\n     * @param owner - UUID\n     * @param id - bigint\n     * @param data - UUID[]\n     */\n    constructor(owner, id, data) {\n        this.owner = owner;\n        this.id = id;\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type AccessGroup.`);\n    }\n    getOwner() {\n        return this.owner;\n    }\n    getId() {\n        return this.id;\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of AccessGroup.\n     * @param {AccessGroup | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AccessGroup.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AccessGroup with another object.\n     * @param {AccessGroup | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AccessGroup.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AccessGroup.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AccessGroup.staticEquals(this, other);\n    }\n    toString(result) {\n        AccessGroup.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AccessGroup = AccessGroup;\n/**\n * Represents the AetherApiDefinition structure.\n */\nclass AetherApiDefinition {\n    id;\n    nameId;\n    methods;\n    docId;\n    static META_BODY = new Impl.AetherApiDefinitionMetaBodyImpl();\n    static META = AetherApiDefinition.META_BODY;\n    /**\n     * Creates an instance of AetherApiDefinition.\n     * @param id - bigint\n     * @param nameId - bigint\n     * @param methods - AetherMethodDescriptor[]\n     * @param docId - bigint\n     */\n    constructor(id, nameId, methods, docId) {\n        this.id = id;\n        this.nameId = nameId;\n        this.methods = methods;\n        this.docId = docId;\n        if (methods === null || methods === undefined)\n            throw new Error(`Field 'methods' cannot be null for type AetherApiDefinition.`);\n    }\n    getId() {\n        return this.id;\n    }\n    getNameId() {\n        return this.nameId;\n    }\n    getMethods() {\n        return this.methods;\n    }\n    methodsContains(el) {\n        return this.methods.includes(el);\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherApiDefinition.\n     * @param {AetherApiDefinition | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherApiDefinition.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherApiDefinition with another object.\n     * @param {AetherApiDefinition | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherApiDefinition.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherApiDefinition.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherApiDefinition.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherApiDefinition.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherApiDefinition = AetherApiDefinition;\n/**\n * Represents the AetherArgumentDescriptor structure.\n */\nclass AetherArgumentDescriptor {\n    nameId;\n    typeId;\n    docId;\n    static META_BODY = new Impl.AetherArgumentDescriptorMetaBodyImpl();\n    static META = AetherArgumentDescriptor.META_BODY;\n    /**\n     * Creates an instance of AetherArgumentDescriptor.\n     * @param nameId - bigint\n     * @param typeId - bigint\n     * @param docId - bigint\n     */\n    constructor(nameId, typeId, docId) {\n        this.nameId = nameId;\n        this.typeId = typeId;\n        this.docId = docId;\n    }\n    getNameId() {\n        return this.nameId;\n    }\n    getTypeId() {\n        return this.typeId;\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherArgumentDescriptor.\n     * @param {AetherArgumentDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherArgumentDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherArgumentDescriptor with another object.\n     * @param {AetherArgumentDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherArgumentDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherArgumentDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherArgumentDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherArgumentDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherArgumentDescriptor = AetherArgumentDescriptor;\n/**\n * Represents the AetherArrayType structure.\n */\nclass AetherArrayType extends AetherTypeDescriptor {\n    elementTypeId;\n    getKind() {\n        return \"ARRAY\";\n    }\n    getAetherTypeId() {\n        return -1;\n    }\n    static META_BODY = new Impl.AetherArrayTypeMetaBodyImpl();\n    static META = AetherArrayType.META_BODY;\n    /**\n     * Creates an instance of AetherArrayType.\n     * @param id - bigint\n     * @param docId - bigint\n     * @param elementTypeId - bigint\n     */\n    constructor(id, docId, elementTypeId) {\n        super(id, docId);\n        this.elementTypeId = elementTypeId;\n    }\n    getElementTypeId() {\n        return this.elementTypeId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherArrayType.\n     * @param {AetherArrayType | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherArrayType.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherArrayType with another object.\n     * @param {AetherArrayType | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherArrayType.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherArrayType.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherArrayType.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherArrayType.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherArrayType = AetherArrayType;\n/**\n * Represents the AetherBaseType structure.\n */\nclass AetherBaseType extends AetherTypeDescriptor {\n    nameId;\n    getKind() {\n        return \"BASE\";\n    }\n    getAetherTypeId() {\n        return -1;\n    }\n    static META_BODY = new Impl.AetherBaseTypeMetaBodyImpl();\n    static META = AetherBaseType.META_BODY;\n    /**\n     * Creates an instance of AetherBaseType.\n     * @param id - bigint\n     * @param docId - bigint\n     * @param nameId - bigint\n     */\n    constructor(id, docId, nameId) {\n        super(id, docId);\n        this.nameId = nameId;\n    }\n    getNameId() {\n        return this.nameId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherBaseType.\n     * @param {AetherBaseType | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherBaseType.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherBaseType with another object.\n     * @param {AetherBaseType | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherBaseType.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherBaseType.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherBaseType.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherBaseType.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherBaseType = AetherBaseType;\n/**\n * Represents the AetherFieldDescriptor structure.\n */\nclass AetherFieldDescriptor {\n    nameId;\n    typeId;\n    docId;\n    static META_BODY = new Impl.AetherFieldDescriptorMetaBodyImpl();\n    static META = AetherFieldDescriptor.META_BODY;\n    /**\n     * Creates an instance of AetherFieldDescriptor.\n     * @param nameId - bigint\n     * @param typeId - bigint\n     * @param docId - bigint\n     */\n    constructor(nameId, typeId, docId) {\n        this.nameId = nameId;\n        this.typeId = typeId;\n        this.docId = docId;\n    }\n    getNameId() {\n        return this.nameId;\n    }\n    getTypeId() {\n        return this.typeId;\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherFieldDescriptor.\n     * @param {AetherFieldDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherFieldDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherFieldDescriptor with another object.\n     * @param {AetherFieldDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherFieldDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherFieldDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherFieldDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherFieldDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherFieldDescriptor = AetherFieldDescriptor;\n/**\n * Represents the AetherMethodDescriptor structure.\n */\nclass AetherMethodDescriptor {\n    nameId;\n    args;\n    returnTypeId;\n    docId;\n    static META_BODY = new Impl.AetherMethodDescriptorMetaBodyImpl();\n    static META = AetherMethodDescriptor.META_BODY;\n    /**\n     * Creates an instance of AetherMethodDescriptor.\n     * @param nameId - bigint\n     * @param args - AetherArgumentDescriptor[]\n     * @param returnTypeId - bigint\n     * @param docId - bigint\n     */\n    constructor(nameId, args, returnTypeId, docId) {\n        this.nameId = nameId;\n        this.args = args;\n        this.returnTypeId = returnTypeId;\n        this.docId = docId;\n        if (args === null || args === undefined)\n            throw new Error(`Field 'args' cannot be null for type AetherMethodDescriptor.`);\n    }\n    getNameId() {\n        return this.nameId;\n    }\n    getArgs() {\n        return this.args;\n    }\n    argsContains(el) {\n        return this.args.includes(el);\n    }\n    getReturnTypeId() {\n        return this.returnTypeId;\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherMethodDescriptor.\n     * @param {AetherMethodDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherMethodDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherMethodDescriptor with another object.\n     * @param {AetherMethodDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherMethodDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherMethodDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherMethodDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherMethodDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherMethodDescriptor = AetherMethodDescriptor;\n/**\n * Represents the AetherModuleDescriptor structure.\n */\nclass AetherModuleDescriptor {\n    stringPool;\n    typeRegistry;\n    structs;\n    apis;\n    static META_BODY = new Impl.AetherModuleDescriptorMetaBodyImpl();\n    static META = AetherModuleDescriptor.META_BODY;\n    /**\n     * Creates an instance of AetherModuleDescriptor.\n     * @param stringPool - string[]\n     * @param typeRegistry - AetherTypeDescriptor[]\n     * @param structs - AetherStructDescriptor[]\n     * @param apis - AetherApiDefinition[]\n     */\n    constructor(stringPool, typeRegistry, structs, apis) {\n        this.stringPool = stringPool;\n        this.typeRegistry = typeRegistry;\n        this.structs = structs;\n        this.apis = apis;\n        if (stringPool === null || stringPool === undefined)\n            throw new Error(`Field 'stringPool' cannot be null for type AetherModuleDescriptor.`);\n        if (typeRegistry === null || typeRegistry === undefined)\n            throw new Error(`Field 'typeRegistry' cannot be null for type AetherModuleDescriptor.`);\n        if (structs === null || structs === undefined)\n            throw new Error(`Field 'structs' cannot be null for type AetherModuleDescriptor.`);\n        if (apis === null || apis === undefined)\n            throw new Error(`Field 'apis' cannot be null for type AetherModuleDescriptor.`);\n    }\n    getStringPool() {\n        return this.stringPool;\n    }\n    stringPoolContains(el) {\n        return this.stringPool.includes(el);\n    }\n    getTypeRegistry() {\n        return this.typeRegistry;\n    }\n    typeRegistryContains(el) {\n        return this.typeRegistry.includes(el);\n    }\n    getStructs() {\n        return this.structs;\n    }\n    structsContains(el) {\n        return this.structs.includes(el);\n    }\n    getApis() {\n        return this.apis;\n    }\n    apisContains(el) {\n        return this.apis.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherModuleDescriptor.\n     * @param {AetherModuleDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherModuleDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherModuleDescriptor with another object.\n     * @param {AetherModuleDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherModuleDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherModuleDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherModuleDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherModuleDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherModuleDescriptor = AetherModuleDescriptor;\n/**\n * Represents the AetherNullableType structure.\n */\nclass AetherNullableType extends AetherTypeDescriptor {\n    wrappedTypeId;\n    getKind() {\n        return \"NULLABLE\";\n    }\n    getAetherTypeId() {\n        return -1;\n    }\n    static META_BODY = new Impl.AetherNullableTypeMetaBodyImpl();\n    static META = AetherNullableType.META_BODY;\n    /**\n     * Creates an instance of AetherNullableType.\n     * @param id - bigint\n     * @param docId - bigint\n     * @param wrappedTypeId - bigint\n     */\n    constructor(id, docId, wrappedTypeId) {\n        super(id, docId);\n        this.wrappedTypeId = wrappedTypeId;\n    }\n    getWrappedTypeId() {\n        return this.wrappedTypeId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherNullableType.\n     * @param {AetherNullableType | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherNullableType.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherNullableType with another object.\n     * @param {AetherNullableType | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherNullableType.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherNullableType.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherNullableType.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherNullableType.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherNullableType = AetherNullableType;\n/**\n * Represents the AetherStreamType structure.\n */\nclass AetherStreamType extends AetherTypeDescriptor {\n    apiId;\n    isCrypto;\n    getKind() {\n        return \"STREAM\";\n    }\n    getAetherTypeId() {\n        return -1;\n    }\n    static META_BODY = new Impl.AetherStreamTypeMetaBodyImpl();\n    static META = AetherStreamType.META_BODY;\n    /**\n     * Creates an instance of AetherStreamType.\n     * @param id - bigint\n     * @param docId - bigint\n     * @param apiId - bigint\n     * @param isCrypto - boolean\n     */\n    constructor(id, docId, apiId, isCrypto) {\n        super(id, docId);\n        this.apiId = apiId;\n        this.isCrypto = isCrypto;\n    }\n    getApiId() {\n        return this.apiId;\n    }\n    isIsCrypto() {\n        return this.isCrypto;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherStreamType.\n     * @param {AetherStreamType | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherStreamType.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherStreamType with another object.\n     * @param {AetherStreamType | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherStreamType.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherStreamType.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherStreamType.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherStreamType.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherStreamType = AetherStreamType;\n/**\n * Represents the AetherStructDescriptor structure.\n */\nclass AetherStructDescriptor {\n    baseTypeId;\n    parentTypeId;\n    fields;\n    docId;\n    static META_BODY = new Impl.AetherStructDescriptorMetaBodyImpl();\n    static META = AetherStructDescriptor.META_BODY;\n    /**\n     * Creates an instance of AetherStructDescriptor.\n     * @param baseTypeId - bigint\n     * @param parentTypeId - bigint\n     * @param fields - AetherFieldDescriptor[]\n     * @param docId - bigint\n     */\n    constructor(baseTypeId, parentTypeId, fields, docId) {\n        this.baseTypeId = baseTypeId;\n        this.parentTypeId = parentTypeId;\n        this.fields = fields;\n        this.docId = docId;\n        if (fields === null || fields === undefined)\n            throw new Error(`Field 'fields' cannot be null for type AetherStructDescriptor.`);\n    }\n    getBaseTypeId() {\n        return this.baseTypeId;\n    }\n    getParentTypeId() {\n        return this.parentTypeId;\n    }\n    getFields() {\n        return this.fields;\n    }\n    fieldsContains(el) {\n        return this.fields.includes(el);\n    }\n    getDocId() {\n        return this.docId;\n    }\n    /**\n     * Calculates a hash code for a static instance of AetherStructDescriptor.\n     * @param {AetherStructDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return AetherStructDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of AetherStructDescriptor with another object.\n     * @param {AetherStructDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return AetherStructDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return AetherStructDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return AetherStructDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        AetherStructDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.AetherStructDescriptor = AetherStructDescriptor;\n/**\n * Represents the ClientInfo structure.\n */\nclass ClientInfo {\n    uid;\n    cloud;\n    static META_BODY = new Impl.ClientInfoMetaBodyImpl();\n    static META = ClientInfo.META_BODY;\n    /**\n     * Creates an instance of ClientInfo.\n     * @param uid - UUID\n     * @param cloud - Cloud\n     */\n    constructor(uid, cloud) {\n        this.uid = uid;\n        this.cloud = cloud;\n        if (cloud === null || cloud === undefined)\n            throw new Error(`Field 'cloud' cannot be null for type ClientInfo.`);\n    }\n    getUid() {\n        return this.uid;\n    }\n    getCloud() {\n        return this.cloud;\n    }\n    /**\n     * Calculates a hash code for a static instance of ClientInfo.\n     * @param {ClientInfo | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return ClientInfo.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of ClientInfo with another object.\n     * @param {ClientInfo | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return ClientInfo.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return ClientInfo.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return ClientInfo.staticEquals(this, other);\n    }\n    toString(result) {\n        ClientInfo.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.ClientInfo = ClientInfo;\n/**\n * Represents the ClientStateForSave structure.\n */\nclass ClientStateForSave {\n    registrationUri;\n    servers;\n    clients;\n    rootSigners;\n    cryptoLib;\n    pingDuration;\n    parentUid;\n    countServersForRegistration;\n    timeoutForConnectToRegistrationServer;\n    uid;\n    alias;\n    masterKey;\n    static META_BODY = new Impl.ClientStateForSaveMetaBodyImpl();\n    static META = ClientStateForSave.META_BODY;\n    /**\n     * Creates an instance of ClientStateForSave.\n     * @param registrationUri - URI[]\n     * @param servers - ServerDescriptor[]\n     * @param clients - ClientInfo[]\n     * @param rootSigners - Key[]\n     * @param cryptoLib - CryptoLib\n     * @param pingDuration - bigint\n     * @param parentUid - UUID\n     * @param countServersForRegistration - number\n     * @param timeoutForConnectToRegistrationServer - bigint\n     * @param uid - UUID\n     * @param alias - UUID\n     * @param masterKey - Key\n     */\n    constructor(registrationUri, servers, clients, rootSigners, cryptoLib, pingDuration, parentUid, countServersForRegistration, timeoutForConnectToRegistrationServer, uid, alias, masterKey) {\n        this.registrationUri = registrationUri;\n        this.servers = servers;\n        this.clients = clients;\n        this.rootSigners = rootSigners;\n        this.cryptoLib = cryptoLib;\n        this.pingDuration = pingDuration;\n        this.parentUid = parentUid;\n        this.countServersForRegistration = countServersForRegistration;\n        this.timeoutForConnectToRegistrationServer = timeoutForConnectToRegistrationServer;\n        this.uid = uid;\n        this.alias = alias;\n        this.masterKey = masterKey;\n        if (registrationUri === null || registrationUri === undefined)\n            throw new Error(`Field 'registrationUri' cannot be null for type ClientStateForSave.`);\n        if (servers === null || servers === undefined)\n            throw new Error(`Field 'servers' cannot be null for type ClientStateForSave.`);\n        if (clients === null || clients === undefined)\n            throw new Error(`Field 'clients' cannot be null for type ClientStateForSave.`);\n        if (rootSigners === null || rootSigners === undefined)\n            throw new Error(`Field 'rootSigners' cannot be null for type ClientStateForSave.`);\n        if (cryptoLib === null || cryptoLib === undefined)\n            throw new Error(`Field 'cryptoLib' cannot be null for type ClientStateForSave.`);\n        if (masterKey === null || masterKey === undefined)\n            throw new Error(`Field 'masterKey' cannot be null for type ClientStateForSave.`);\n    }\n    getRegistrationUri() {\n        return this.registrationUri;\n    }\n    registrationUriContains(el) {\n        return this.registrationUri.includes(el);\n    }\n    getServers() {\n        return this.servers;\n    }\n    serversContains(el) {\n        return this.servers.includes(el);\n    }\n    getClients() {\n        return this.clients;\n    }\n    clientsContains(el) {\n        return this.clients.includes(el);\n    }\n    getRootSigners() {\n        return this.rootSigners;\n    }\n    rootSignersContains(el) {\n        return this.rootSigners.includes(el);\n    }\n    getCryptoLib() {\n        return this.cryptoLib;\n    }\n    getPingDuration() {\n        return this.pingDuration;\n    }\n    getParentUid() {\n        return this.parentUid;\n    }\n    getCountServersForRegistration() {\n        return this.countServersForRegistration;\n    }\n    getTimeoutForConnectToRegistrationServer() {\n        return this.timeoutForConnectToRegistrationServer;\n    }\n    getUid() {\n        return this.uid;\n    }\n    getAlias() {\n        return this.alias;\n    }\n    getMasterKey() {\n        return this.masterKey;\n    }\n    /**\n     * Calculates a hash code for a static instance of ClientStateForSave.\n     * @param {ClientStateForSave | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return ClientStateForSave.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of ClientStateForSave with another object.\n     * @param {ClientStateForSave | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return ClientStateForSave.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return ClientStateForSave.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return ClientStateForSave.staticEquals(this, other);\n    }\n    toString(result) {\n        ClientStateForSave.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.ClientStateForSave = ClientStateForSave;\n/**\n * Represents the Cloud structure.\n */\nclass Cloud {\n    data;\n    static META_BODY = new Impl.CloudMetaBodyImpl();\n    static META = Cloud.META_BODY;\n    /**\n     * Creates an instance of Cloud.\n     * @param data - number[]\n     */\n    constructor(data) {\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type Cloud.`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of Cloud.\n     * @param {Cloud | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return Cloud.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Cloud with another object.\n     * @param {Cloud | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return Cloud.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return Cloud.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return Cloud.staticEquals(this, other);\n    }\n    toString(result) {\n        Cloud.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.Cloud = Cloud;\n/**\n * Represents the CoderAndPort structure.\n */\nclass CoderAndPort {\n    codec;\n    port;\n    static META_BODY = new Impl.CoderAndPortMetaBodyImpl();\n    static META = CoderAndPort.META_BODY;\n    /**\n     * Creates an instance of CoderAndPort.\n     * @param codec - AetherCodec\n     * @param port - number\n     */\n    constructor(codec, port) {\n        this.codec = codec;\n        this.port = port;\n        if (codec === null || codec === undefined)\n            throw new Error(`Field 'codec' cannot be null for type CoderAndPort.`);\n    }\n    getCodec() {\n        return this.codec;\n    }\n    getPort() {\n        return this.port;\n    }\n    /**\n     * Calculates a hash code for a static instance of CoderAndPort.\n     * @param {CoderAndPort | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return CoderAndPort.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of CoderAndPort with another object.\n     * @param {CoderAndPort | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return CoderAndPort.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return CoderAndPort.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return CoderAndPort.staticEquals(this, other);\n    }\n    toString(result) {\n        CoderAndPort.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.CoderAndPort = CoderAndPort;\n/**\n * Represents the FinishResult structure.\n */\nclass FinishResult {\n    alias;\n    uid;\n    cloud;\n    static META_BODY = new Impl.FinishResultMetaBodyImpl();\n    static META = FinishResult.META_BODY;\n    /**\n     * Creates an instance of FinishResult.\n     * @param alias - UUID\n     * @param uid - UUID\n     * @param cloud - Cloud\n     */\n    constructor(alias, uid, cloud) {\n        this.alias = alias;\n        this.uid = uid;\n        this.cloud = cloud;\n        if (cloud === null || cloud === undefined)\n            throw new Error(`Field 'cloud' cannot be null for type FinishResult.`);\n    }\n    getAlias() {\n        return this.alias;\n    }\n    getUid() {\n        return this.uid;\n    }\n    getCloud() {\n        return this.cloud;\n    }\n    /**\n     * Calculates a hash code for a static instance of FinishResult.\n     * @param {FinishResult | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return FinishResult.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of FinishResult with another object.\n     * @param {FinishResult | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return FinishResult.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return FinishResult.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return FinishResult.staticEquals(this, other);\n    }\n    toString(result) {\n        FinishResult.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.FinishResult = FinishResult;\n/**\n * Represents the HydrogenCurvePrivate structure.\n *\n * @aetherTypeId 1\n */\nclass HydrogenCurvePrivate extends KeyAsymmetricPrivate {\n    data;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.HydrogenCurvePrivateMetaBodyImpl();\n    static META = new Impl.HydrogenCurvePrivateMetaImpl();\n    /**\n     * Creates an instance of HydrogenCurvePrivate.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type HydrogenCurvePrivate.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type HydrogenCurvePrivate must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of HydrogenCurvePrivate.\n     * @param {HydrogenCurvePrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HydrogenCurvePrivate.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HydrogenCurvePrivate with another object.\n     * @param {HydrogenCurvePrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HydrogenCurvePrivate.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HydrogenCurvePrivate.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HydrogenCurvePrivate.staticEquals(this, other);\n    }\n    toString(result) {\n        HydrogenCurvePrivate.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HydrogenCurvePrivate = HydrogenCurvePrivate;\n/**\n * Represents the HydrogenCurvePublic structure.\n *\n * @aetherTypeId 2\n */\nclass HydrogenCurvePublic extends KeyAsymmetricPublic {\n    data;\n    getAetherTypeId() {\n        return 2;\n    }\n    static META_BODY = new Impl.HydrogenCurvePublicMetaBodyImpl();\n    static META = new Impl.HydrogenCurvePublicMetaImpl();\n    /**\n     * Creates an instance of HydrogenCurvePublic.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type HydrogenCurvePublic.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type HydrogenCurvePublic must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of HydrogenCurvePublic.\n     * @param {HydrogenCurvePublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HydrogenCurvePublic.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HydrogenCurvePublic with another object.\n     * @param {HydrogenCurvePublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HydrogenCurvePublic.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HydrogenCurvePublic.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HydrogenCurvePublic.staticEquals(this, other);\n    }\n    toString(result) {\n        HydrogenCurvePublic.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HydrogenCurvePublic = HydrogenCurvePublic;\n/**\n * Represents the HydrogenSecretBox structure.\n *\n * @aetherTypeId 3\n */\nclass HydrogenSecretBox extends KeySymmetric {\n    data;\n    getAetherTypeId() {\n        return 3;\n    }\n    static META_BODY = new Impl.HydrogenSecretBoxMetaBodyImpl();\n    static META = new Impl.HydrogenSecretBoxMetaImpl();\n    /**\n     * Creates an instance of HydrogenSecretBox.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type HydrogenSecretBox.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type HydrogenSecretBox must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of HydrogenSecretBox.\n     * @param {HydrogenSecretBox | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HydrogenSecretBox.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HydrogenSecretBox with another object.\n     * @param {HydrogenSecretBox | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HydrogenSecretBox.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HydrogenSecretBox.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HydrogenSecretBox.staticEquals(this, other);\n    }\n    toString(result) {\n        HydrogenSecretBox.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HydrogenSecretBox = HydrogenSecretBox;\n/**\n * Represents the HydrogenSignPrivate structure.\n *\n * @aetherTypeId 4\n */\nclass HydrogenSignPrivate extends KeySignPrivate {\n    data;\n    getAetherTypeId() {\n        return 4;\n    }\n    static META_BODY = new Impl.HydrogenSignPrivateMetaBodyImpl();\n    static META = new Impl.HydrogenSignPrivateMetaImpl();\n    /**\n     * Creates an instance of HydrogenSignPrivate.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type HydrogenSignPrivate.`);\n        if (data.length !== 64)\n            throw new Error(`Array length for field 'data' in type HydrogenSignPrivate must be 64 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of HydrogenSignPrivate.\n     * @param {HydrogenSignPrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HydrogenSignPrivate.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HydrogenSignPrivate with another object.\n     * @param {HydrogenSignPrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HydrogenSignPrivate.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HydrogenSignPrivate.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HydrogenSignPrivate.staticEquals(this, other);\n    }\n    toString(result) {\n        HydrogenSignPrivate.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HydrogenSignPrivate = HydrogenSignPrivate;\n/**\n * Represents the HydrogenSignPublic structure.\n *\n * @aetherTypeId 5\n */\nclass HydrogenSignPublic extends KeySignPublic {\n    data;\n    getAetherTypeId() {\n        return 5;\n    }\n    static META_BODY = new Impl.HydrogenSignPublicMetaBodyImpl();\n    static META = new Impl.HydrogenSignPublicMetaImpl();\n    /**\n     * Creates an instance of HydrogenSignPublic.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type HydrogenSignPublic.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type HydrogenSignPublic must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of HydrogenSignPublic.\n     * @param {HydrogenSignPublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HydrogenSignPublic.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HydrogenSignPublic with another object.\n     * @param {HydrogenSignPublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HydrogenSignPublic.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HydrogenSignPublic.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HydrogenSignPublic.staticEquals(this, other);\n    }\n    toString(result) {\n        HydrogenSignPublic.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HydrogenSignPublic = HydrogenSignPublic;\n/**\n * Represents the IPAddressAndPorts structure.\n */\nclass IPAddressAndPorts {\n    address;\n    coderAndPorts;\n    static META_BODY = new Impl.IPAddressAndPortsMetaBodyImpl();\n    static META = IPAddressAndPorts.META_BODY;\n    /**\n     * Creates an instance of IPAddressAndPorts.\n     * @param address - IPAddress\n     * @param coderAndPorts - CoderAndPort[]\n     */\n    constructor(address, coderAndPorts) {\n        this.address = address;\n        this.coderAndPorts = coderAndPorts;\n        if (address === null || address === undefined)\n            throw new Error(`Field 'address' cannot be null for type IPAddressAndPorts.`);\n        if (coderAndPorts === null || coderAndPorts === undefined)\n            throw new Error(`Field 'coderAndPorts' cannot be null for type IPAddressAndPorts.`);\n    }\n    getAddress() {\n        return this.address;\n    }\n    getCoderAndPorts() {\n        return this.coderAndPorts;\n    }\n    coderAndPortsContains(el) {\n        return this.coderAndPorts.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of IPAddressAndPorts.\n     * @param {IPAddressAndPorts | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return IPAddressAndPorts.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of IPAddressAndPorts with another object.\n     * @param {IPAddressAndPorts | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return IPAddressAndPorts.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return IPAddressAndPorts.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return IPAddressAndPorts.staticEquals(this, other);\n    }\n    toString(result) {\n        IPAddressAndPorts.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.IPAddressAndPorts = IPAddressAndPorts;\n/**\n * Represents the IPAddressAndPortsList structure.\n */\nclass IPAddressAndPortsList {\n    addresses;\n    static META_BODY = new Impl.IPAddressAndPortsListMetaBodyImpl();\n    static META = IPAddressAndPortsList.META_BODY;\n    /**\n     * Creates an instance of IPAddressAndPortsList.\n     * @param addresses - IPAddressAndPorts[]\n     */\n    constructor(addresses) {\n        this.addresses = addresses;\n        if (addresses === null || addresses === undefined)\n            throw new Error(`Field 'addresses' cannot be null for type IPAddressAndPortsList.`);\n    }\n    getAddresses() {\n        return this.addresses;\n    }\n    addressesContains(el) {\n        return this.addresses.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of IPAddressAndPortsList.\n     * @param {IPAddressAndPortsList | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return IPAddressAndPortsList.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of IPAddressAndPortsList with another object.\n     * @param {IPAddressAndPortsList | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return IPAddressAndPortsList.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return IPAddressAndPortsList.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return IPAddressAndPortsList.staticEquals(this, other);\n    }\n    toString(result) {\n        IPAddressAndPortsList.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.IPAddressAndPortsList = IPAddressAndPortsList;\n/**\n * Represents the IPAddressV4 structure.\n *\n * @aetherTypeId 1\n */\nclass IPAddressV4 extends IPAddress {\n    data;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.IPAddressV4MetaBodyImpl();\n    static META = new Impl.IPAddressV4MetaImpl();\n    /**\n     * Creates an instance of IPAddressV4.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type IPAddressV4.`);\n        if (data.length !== 4)\n            throw new Error(`Array length for field 'data' in type IPAddressV4 must be 4 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of IPAddressV4.\n     * @param {IPAddressV4 | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return IPAddressV4.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of IPAddressV4 with another object.\n     * @param {IPAddressV4 | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return IPAddressV4.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return IPAddressV4.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return IPAddressV4.staticEquals(this, other);\n    }\n    toString(result) {\n        IPAddressV4.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.IPAddressV4 = IPAddressV4;\n/**\n * Represents the IPAddressV6 structure.\n *\n * @aetherTypeId 2\n */\nclass IPAddressV6 extends IPAddress {\n    data;\n    getAetherTypeId() {\n        return 2;\n    }\n    static META_BODY = new Impl.IPAddressV6MetaBodyImpl();\n    static META = new Impl.IPAddressV6MetaImpl();\n    /**\n     * Creates an instance of IPAddressV6.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type IPAddressV6.`);\n        if (data.length !== 6)\n            throw new Error(`Array length for field 'data' in type IPAddressV6 must be 6 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of IPAddressV6.\n     * @param {IPAddressV6 | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return IPAddressV6.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of IPAddressV6 with another object.\n     * @param {IPAddressV6 | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return IPAddressV6.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return IPAddressV6.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return IPAddressV6.staticEquals(this, other);\n    }\n    toString(result) {\n        IPAddressV6.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.IPAddressV6 = IPAddressV6;\n/**\n * Represents the Message structure.\n */\nclass Message {\n    uid;\n    data;\n    static META_BODY = new Impl.MessageMetaBodyImpl();\n    static META = Message.META_BODY;\n    /**\n     * Creates an instance of Message.\n     * @param uid - UUID\n     * @param data - Uint8Array\n     */\n    constructor(uid, data) {\n        this.uid = uid;\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type Message.`);\n    }\n    getUid() {\n        return this.uid;\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of Message.\n     * @param {Message | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return Message.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Message with another object.\n     * @param {Message | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return Message.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return Message.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return Message.staticEquals(this, other);\n    }\n    toString(result) {\n        Message.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.Message = Message;\n/**\n * Represents the MoneyOperation structure.\n */\nclass MoneyOperation {\n    id;\n    from;\n    to;\n    amount;\n    time;\n    credit;\n    status;\n    static META_BODY = new Impl.MoneyOperationMetaBodyImpl();\n    static META = MoneyOperation.META_BODY;\n    /**\n     * Creates an instance of MoneyOperation.\n     * @param id - bigint\n     * @param from - UUID\n     * @param to - UUID\n     * @param amount - bigint\n     * @param time - bigint\n     * @param credit - boolean\n     * @param status - Status\n     */\n    constructor(id, from, to, amount, time, credit, status) {\n        this.id = id;\n        this.from = from;\n        this.to = to;\n        this.amount = amount;\n        this.time = time;\n        this.credit = credit;\n        this.status = status;\n        if (status === null || status === undefined)\n            throw new Error(`Field 'status' cannot be null for type MoneyOperation.`);\n    }\n    getId() {\n        return this.id;\n    }\n    getFrom() {\n        return this.from;\n    }\n    getTo() {\n        return this.to;\n    }\n    getAmount() {\n        return this.amount;\n    }\n    getTime() {\n        return this.time;\n    }\n    isCredit() {\n        return this.credit;\n    }\n    getStatus() {\n        return this.status;\n    }\n    /**\n     * Calculates a hash code for a static instance of MoneyOperation.\n     * @param {MoneyOperation | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return MoneyOperation.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of MoneyOperation with another object.\n     * @param {MoneyOperation | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return MoneyOperation.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return MoneyOperation.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return MoneyOperation.staticEquals(this, other);\n    }\n    toString(result) {\n        MoneyOperation.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.MoneyOperation = MoneyOperation;\n/**\n * Represents the PairKeysAsym structure.\n *\n * @aetherTypeId 1\n */\nclass PairKeysAsym extends PairKeys {\n    privateKey;\n    publicKey;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.PairKeysAsymMetaBodyImpl();\n    static META = new Impl.PairKeysAsymMetaImpl();\n    /**\n     * Creates an instance of PairKeysAsym.\n     * @param privateKey - Key\n     * @param publicKey - Key\n     */\n    constructor(privateKey, publicKey) {\n        super();\n        this.privateKey = privateKey;\n        this.publicKey = publicKey;\n        if (privateKey === null || privateKey === undefined)\n            throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsym.`);\n        if (publicKey === null || publicKey === undefined)\n            throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsym.`);\n    }\n    getPrivateKey() {\n        return this.privateKey;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n    /**\n     * Calculates a hash code for a static instance of PairKeysAsym.\n     * @param {PairKeysAsym | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return PairKeysAsym.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of PairKeysAsym with another object.\n     * @param {PairKeysAsym | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return PairKeysAsym.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return PairKeysAsym.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return PairKeysAsym.staticEquals(this, other);\n    }\n    toString(result) {\n        PairKeysAsym.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.PairKeysAsym = PairKeysAsym;\n/**\n * Represents the PairKeysAsymSigned structure.\n *\n * @aetherTypeId 2\n */\nclass PairKeysAsymSigned extends PairKeys {\n    privateKey;\n    publicKey;\n    getAetherTypeId() {\n        return 2;\n    }\n    static META_BODY = new Impl.PairKeysAsymSignedMetaBodyImpl();\n    static META = new Impl.PairKeysAsymSignedMetaImpl();\n    /**\n     * Creates an instance of PairKeysAsymSigned.\n     * @param privateKey - Key\n     * @param publicKey - SignedKey\n     */\n    constructor(privateKey, publicKey) {\n        super();\n        this.privateKey = privateKey;\n        this.publicKey = publicKey;\n        if (privateKey === null || privateKey === undefined)\n            throw new Error(`Field 'privateKey' cannot be null for type PairKeysAsymSigned.`);\n        if (publicKey === null || publicKey === undefined)\n            throw new Error(`Field 'publicKey' cannot be null for type PairKeysAsymSigned.`);\n    }\n    getPrivateKey() {\n        return this.privateKey;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n    /**\n     * Calculates a hash code for a static instance of PairKeysAsymSigned.\n     * @param {PairKeysAsymSigned | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return PairKeysAsymSigned.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of PairKeysAsymSigned with another object.\n     * @param {PairKeysAsymSigned | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return PairKeysAsymSigned.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return PairKeysAsymSigned.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return PairKeysAsymSigned.staticEquals(this, other);\n    }\n    toString(result) {\n        PairKeysAsymSigned.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.PairKeysAsymSigned = PairKeysAsymSigned;\n/**\n * Represents the PairKeysSign structure.\n *\n * @aetherTypeId 3\n */\nclass PairKeysSign extends PairKeys {\n    privateKey;\n    publicKey;\n    getAetherTypeId() {\n        return 3;\n    }\n    static META_BODY = new Impl.PairKeysSignMetaBodyImpl();\n    static META = new Impl.PairKeysSignMetaImpl();\n    /**\n     * Creates an instance of PairKeysSign.\n     * @param privateKey - Key\n     * @param publicKey - Key\n     */\n    constructor(privateKey, publicKey) {\n        super();\n        this.privateKey = privateKey;\n        this.publicKey = publicKey;\n        if (privateKey === null || privateKey === undefined)\n            throw new Error(`Field 'privateKey' cannot be null for type PairKeysSign.`);\n        if (publicKey === null || publicKey === undefined)\n            throw new Error(`Field 'publicKey' cannot be null for type PairKeysSign.`);\n    }\n    getPrivateKey() {\n        return this.privateKey;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n    /**\n     * Calculates a hash code for a static instance of PairKeysSign.\n     * @param {PairKeysSign | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return PairKeysSign.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of PairKeysSign with another object.\n     * @param {PairKeysSign | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return PairKeysSign.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return PairKeysSign.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return PairKeysSign.staticEquals(this, other);\n    }\n    toString(result) {\n        PairKeysSign.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.PairKeysSign = PairKeysSign;\n/**\n * Represents the ServerDescriptor structure.\n */\nclass ServerDescriptor {\n    id;\n    ipAddress;\n    static META_BODY = new Impl.ServerDescriptorMetaBodyImpl();\n    static META = ServerDescriptor.META_BODY;\n    /**\n     * Creates an instance of ServerDescriptor.\n     * @param id - number\n     * @param ipAddress - IPAddressAndPortsList\n     */\n    constructor(id, ipAddress) {\n        this.id = id;\n        this.ipAddress = ipAddress;\n        if (ipAddress === null || ipAddress === undefined)\n            throw new Error(`Field 'ipAddress' cannot be null for type ServerDescriptor.`);\n    }\n    getId() {\n        return this.id;\n    }\n    getIpAddress() {\n        return this.ipAddress;\n    }\n    /**\n     * Calculates a hash code for a static instance of ServerDescriptor.\n     * @param {ServerDescriptor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return ServerDescriptor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of ServerDescriptor with another object.\n     * @param {ServerDescriptor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return ServerDescriptor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return ServerDescriptor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return ServerDescriptor.staticEquals(this, other);\n    }\n    toString(result) {\n        ServerDescriptor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.ServerDescriptor = ServerDescriptor;\n/**\n * Represents the SignAE_ED25519 structure.\n *\n * @aetherTypeId 1\n */\nclass SignAE_ED25519 extends Sign {\n    data;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.SignAE_ED25519MetaBodyImpl();\n    static META = new Impl.SignAE_ED25519MetaImpl();\n    /**\n     * Creates an instance of SignAE_ED25519.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SignAE_ED25519.`);\n        if (data.length !== 64)\n            throw new Error(`Array length for field 'data' in type SignAE_ED25519 must be 64 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SignAE_ED25519.\n     * @param {SignAE_ED25519 | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SignAE_ED25519.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SignAE_ED25519 with another object.\n     * @param {SignAE_ED25519 | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SignAE_ED25519.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SignAE_ED25519.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SignAE_ED25519.staticEquals(this, other);\n    }\n    toString(result) {\n        SignAE_ED25519.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SignAE_ED25519 = SignAE_ED25519;\n/**\n * Represents the SignedKey structure.\n */\nclass SignedKey {\n    key;\n    sign;\n    static META_BODY = new Impl.SignedKeyMetaBodyImpl();\n    static META = SignedKey.META_BODY;\n    /**\n     * Creates an instance of SignedKey.\n     * @param key - Key\n     * @param sign - Sign\n     */\n    constructor(key, sign) {\n        this.key = key;\n        this.sign = sign;\n        if (key === null || key === undefined)\n            throw new Error(`Field 'key' cannot be null for type SignedKey.`);\n        if (sign === null || sign === undefined)\n            throw new Error(`Field 'sign' cannot be null for type SignedKey.`);\n    }\n    getKey() {\n        return this.key;\n    }\n    getSign() {\n        return this.sign;\n    }\n    /**\n     * Calculates a hash code for a static instance of SignedKey.\n     * @param {SignedKey | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SignedKey.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SignedKey with another object.\n     * @param {SignedKey | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SignedKey.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SignedKey.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SignedKey.staticEquals(this, other);\n    }\n    toString(result) {\n        SignedKey.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SignedKey = SignedKey;\n/**\n * Represents the SignHYDROGEN structure.\n *\n * @aetherTypeId 2\n */\nclass SignHYDROGEN extends Sign {\n    data;\n    getAetherTypeId() {\n        return 2;\n    }\n    static META_BODY = new Impl.SignHYDROGENMetaBodyImpl();\n    static META = new Impl.SignHYDROGENMetaImpl();\n    /**\n     * Creates an instance of SignHYDROGEN.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SignHYDROGEN.`);\n        if (data.length !== 64)\n            throw new Error(`Array length for field 'data' in type SignHYDROGEN must be 64 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SignHYDROGEN.\n     * @param {SignHYDROGEN | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SignHYDROGEN.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SignHYDROGEN with another object.\n     * @param {SignHYDROGEN | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SignHYDROGEN.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SignHYDROGEN.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SignHYDROGEN.staticEquals(this, other);\n    }\n    toString(result) {\n        SignHYDROGEN.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SignHYDROGEN = SignHYDROGEN;\n/**\n * Represents the SodiumChacha20Poly1305 structure.\n *\n * @aetherTypeId 6\n */\nclass SodiumChacha20Poly1305 extends KeySymmetric {\n    data;\n    getAetherTypeId() {\n        return 6;\n    }\n    static META_BODY = new Impl.SodiumChacha20Poly1305MetaBodyImpl();\n    static META = new Impl.SodiumChacha20Poly1305MetaImpl();\n    /**\n     * Creates an instance of SodiumChacha20Poly1305.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SodiumChacha20Poly1305.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type SodiumChacha20Poly1305 must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SodiumChacha20Poly1305.\n     * @param {SodiumChacha20Poly1305 | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SodiumChacha20Poly1305.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SodiumChacha20Poly1305 with another object.\n     * @param {SodiumChacha20Poly1305 | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SodiumChacha20Poly1305.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SodiumChacha20Poly1305.staticEquals(this, other);\n    }\n    toString(result) {\n        SodiumChacha20Poly1305.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SodiumChacha20Poly1305 = SodiumChacha20Poly1305;\n/**\n * Represents the SodiumCurvePrivate structure.\n *\n * @aetherTypeId 7\n */\nclass SodiumCurvePrivate extends KeyAsymmetricPrivate {\n    data;\n    getAetherTypeId() {\n        return 7;\n    }\n    static META_BODY = new Impl.SodiumCurvePrivateMetaBodyImpl();\n    static META = new Impl.SodiumCurvePrivateMetaImpl();\n    /**\n     * Creates an instance of SodiumCurvePrivate.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SodiumCurvePrivate.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type SodiumCurvePrivate must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SodiumCurvePrivate.\n     * @param {SodiumCurvePrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SodiumCurvePrivate.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SodiumCurvePrivate with another object.\n     * @param {SodiumCurvePrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SodiumCurvePrivate.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SodiumCurvePrivate.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SodiumCurvePrivate.staticEquals(this, other);\n    }\n    toString(result) {\n        SodiumCurvePrivate.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SodiumCurvePrivate = SodiumCurvePrivate;\n/**\n * Represents the SodiumCurvePublic structure.\n *\n * @aetherTypeId 8\n */\nclass SodiumCurvePublic extends KeyAsymmetricPublic {\n    data;\n    getAetherTypeId() {\n        return 8;\n    }\n    static META_BODY = new Impl.SodiumCurvePublicMetaBodyImpl();\n    static META = new Impl.SodiumCurvePublicMetaImpl();\n    /**\n     * Creates an instance of SodiumCurvePublic.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SodiumCurvePublic.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type SodiumCurvePublic must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SodiumCurvePublic.\n     * @param {SodiumCurvePublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SodiumCurvePublic.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SodiumCurvePublic with another object.\n     * @param {SodiumCurvePublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SodiumCurvePublic.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SodiumCurvePublic.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SodiumCurvePublic.staticEquals(this, other);\n    }\n    toString(result) {\n        SodiumCurvePublic.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SodiumCurvePublic = SodiumCurvePublic;\n/**\n * Represents the SodiumSignPrivate structure.\n *\n * @aetherTypeId 9\n */\nclass SodiumSignPrivate extends KeySignPrivate {\n    data;\n    getAetherTypeId() {\n        return 9;\n    }\n    static META_BODY = new Impl.SodiumSignPrivateMetaBodyImpl();\n    static META = new Impl.SodiumSignPrivateMetaImpl();\n    /**\n     * Creates an instance of SodiumSignPrivate.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SodiumSignPrivate.`);\n        if (data.length !== 64)\n            throw new Error(`Array length for field 'data' in type SodiumSignPrivate must be 64 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SodiumSignPrivate.\n     * @param {SodiumSignPrivate | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SodiumSignPrivate.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SodiumSignPrivate with another object.\n     * @param {SodiumSignPrivate | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SodiumSignPrivate.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SodiumSignPrivate.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SodiumSignPrivate.staticEquals(this, other);\n    }\n    toString(result) {\n        SodiumSignPrivate.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SodiumSignPrivate = SodiumSignPrivate;\n/**\n * Represents the SodiumSignPublic structure.\n *\n * @aetherTypeId 10\n */\nclass SodiumSignPublic extends KeySignPublic {\n    data;\n    getAetherTypeId() {\n        return 10;\n    }\n    static META_BODY = new Impl.SodiumSignPublicMetaBodyImpl();\n    static META = new Impl.SodiumSignPublicMetaImpl();\n    /**\n     * Creates an instance of SodiumSignPublic.\n     * @param data - Uint8Array\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n        if (data === null || data === undefined)\n            throw new Error(`Field 'data' cannot be null for type SodiumSignPublic.`);\n        if (data.length !== 32)\n            throw new Error(`Array length for field 'data' in type SodiumSignPublic must be 32 but was $ {\n            data ? data.length : 'null/undefined'\n        }\n        .`);\n    }\n    getData() {\n        return this.data;\n    }\n    dataContains(el) {\n        return this.data.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of SodiumSignPublic.\n     * @param {SodiumSignPublic | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return SodiumSignPublic.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of SodiumSignPublic with another object.\n     * @param {SodiumSignPublic | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return SodiumSignPublic.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return SodiumSignPublic.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return SodiumSignPublic.staticEquals(this, other);\n    }\n    toString(result) {\n        SodiumSignPublic.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.SodiumSignPublic = SodiumSignPublic;\n/**\n * Represents the TelemetryCPP structure.\n *\n * @aetherTypeId 1\n */\nclass TelemetryCPP extends Telemetry {\n    utm_id;\n    blob;\n    lib_version;\n    os;\n    compiler;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.TelemetryCPPMetaBodyImpl();\n    static META = new Impl.TelemetryCPPMetaImpl();\n    /**\n     * Creates an instance of TelemetryCPP.\n     * @param utm_id - number\n     * @param blob - Uint8Array\n     * @param lib_version - string\n     * @param os - string\n     * @param compiler - string\n     */\n    constructor(utm_id, blob, lib_version, os, compiler) {\n        super();\n        this.utm_id = utm_id;\n        this.blob = blob;\n        this.lib_version = lib_version;\n        this.os = os;\n        this.compiler = compiler;\n        if (blob === null || blob === undefined)\n            throw new Error(`Field 'blob' cannot be null for type TelemetryCPP.`);\n    }\n    getUtm_id() {\n        return this.utm_id;\n    }\n    getBlob() {\n        return this.blob;\n    }\n    blobContains(el) {\n        return this.blob.includes(el);\n    }\n    getLib_version() {\n        return this.lib_version;\n    }\n    getOs() {\n        return this.os;\n    }\n    getCompiler() {\n        return this.compiler;\n    }\n    /**\n     * Calculates a hash code for a static instance of TelemetryCPP.\n     * @param {TelemetryCPP | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return TelemetryCPP.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of TelemetryCPP with another object.\n     * @param {TelemetryCPP | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return TelemetryCPP.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return TelemetryCPP.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return TelemetryCPP.staticEquals(this, other);\n    }\n    toString(result) {\n        TelemetryCPP.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.TelemetryCPP = TelemetryCPP;\n/**\n * Represents the UUIDAndCloud structure.\n */\nclass UUIDAndCloud {\n    uid;\n    cloud;\n    static META_BODY = new Impl.UUIDAndCloudMetaBodyImpl();\n    static META = UUIDAndCloud.META_BODY;\n    /**\n     * Creates an instance of UUIDAndCloud.\n     * @param uid - UUID\n     * @param cloud - Cloud\n     */\n    constructor(uid, cloud) {\n        this.uid = uid;\n        this.cloud = cloud;\n        if (cloud === null || cloud === undefined)\n            throw new Error(`Field 'cloud' cannot be null for type UUIDAndCloud.`);\n    }\n    getUid() {\n        return this.uid;\n    }\n    getCloud() {\n        return this.cloud;\n    }\n    /**\n     * Calculates a hash code for a static instance of UUIDAndCloud.\n     * @param {UUIDAndCloud | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return UUIDAndCloud.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of UUIDAndCloud with another object.\n     * @param {UUIDAndCloud | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return UUIDAndCloud.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return UUIDAndCloud.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return UUIDAndCloud.staticEquals(this, other);\n    }\n    toString(result) {\n        UUIDAndCloud.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.UUIDAndCloud = UUIDAndCloud;\n/**\n * Represents the WorkProofBCrypt structure.\n *\n * @aetherTypeId 1\n */\nclass WorkProofBCrypt extends WorkProofConfig {\n    costBCrypt;\n    poolSize;\n    maxHashVal;\n    getAetherTypeId() {\n        return 1;\n    }\n    static META_BODY = new Impl.WorkProofBCryptMetaBodyImpl();\n    static META = new Impl.WorkProofBCryptMetaImpl();\n    /**\n     * Creates an instance of WorkProofBCrypt.\n     * @param costBCrypt - number\n     * @param poolSize - number\n     * @param maxHashVal - number\n     */\n    constructor(costBCrypt, poolSize, maxHashVal) {\n        super();\n        this.costBCrypt = costBCrypt;\n        this.poolSize = poolSize;\n        this.maxHashVal = maxHashVal;\n    }\n    getCostBCrypt() {\n        return this.costBCrypt;\n    }\n    getPoolSize() {\n        return this.poolSize;\n    }\n    getMaxHashVal() {\n        return this.maxHashVal;\n    }\n    /**\n     * Calculates a hash code for a static instance of WorkProofBCrypt.\n     * @param {WorkProofBCrypt | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return WorkProofBCrypt.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of WorkProofBCrypt with another object.\n     * @param {WorkProofBCrypt | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return WorkProofBCrypt.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return WorkProofBCrypt.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return WorkProofBCrypt.staticEquals(this, other);\n    }\n    toString(result) {\n        WorkProofBCrypt.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.WorkProofBCrypt = WorkProofBCrypt;\n/**\n * Represents the WorkProofDTO structure.\n */\nclass WorkProofDTO {\n    salt;\n    suffix;\n    poolSize;\n    maxHashVal;\n    globalKey;\n    static META_BODY = new Impl.WorkProofDTOMetaBodyImpl();\n    static META = WorkProofDTO.META_BODY;\n    /**\n     * Creates an instance of WorkProofDTO.\n     * @param salt - string\n     * @param suffix - string\n     * @param poolSize - number\n     * @param maxHashVal - number\n     * @param globalKey - SignedKey\n     */\n    constructor(salt, suffix, poolSize, maxHashVal, globalKey) {\n        this.salt = salt;\n        this.suffix = suffix;\n        this.poolSize = poolSize;\n        this.maxHashVal = maxHashVal;\n        this.globalKey = globalKey;\n        if (globalKey === null || globalKey === undefined)\n            throw new Error(`Field 'globalKey' cannot be null for type WorkProofDTO.`);\n    }\n    getSalt() {\n        return this.salt;\n    }\n    getSuffix() {\n        return this.suffix;\n    }\n    getPoolSize() {\n        return this.poolSize;\n    }\n    getMaxHashVal() {\n        return this.maxHashVal;\n    }\n    getGlobalKey() {\n        return this.globalKey;\n    }\n    /**\n     * Calculates a hash code for a static instance of WorkProofDTO.\n     * @param {WorkProofDTO | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return WorkProofDTO.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of WorkProofDTO with another object.\n     * @param {WorkProofDTO | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return WorkProofDTO.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return WorkProofDTO.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return WorkProofDTO.staticEquals(this, other);\n    }\n    toString(result) {\n        WorkProofDTO.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.WorkProofDTO = WorkProofDTO;\nclass ClientApiRegSafeStream {\n    data;\n    /**\n     * Creates an instance of ClientApiRegSafeStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.ClientApiRegSafeStreamMetaImpl();\n    toString(result) {\n        ClientApiRegSafeStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!ClientApiRegSafe.META)\n            throw new Error(`META not found for API type ClientApiRegSafe`);\n        ClientApiRegSafe.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new ClientApiRegSafeStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = ClientApiRegSafe.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new ClientApiRegSafeStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new ClientApiRegSafeStream(encryptedData);\n    }\n}\nexports.ClientApiRegSafeStream = ClientApiRegSafeStream;\nclass ClientApiStream {\n    data;\n    /**\n     * Creates an instance of ClientApiStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.ClientApiStreamMetaImpl();\n    toString(result) {\n        ClientApiStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, localApi) {\n        const dataInStatic = new aether_client_1.DataInOutStatic(this.data);\n        if (!ServerApiByUid.META)\n            throw new Error(`META not found for API type ServerApiByUid`);\n        ServerApiByUid.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        return new ClientApiStream(context.remoteDataToArrayAsArray());\n    }\n    static fromRemoteConsumer(context, remoteConsumer) {\n        const api = ServerApiByUid.META.makeRemote(context);\n        remoteConsumer(api);\n        return new ClientApiStream(context.remoteDataToArrayAsArray());\n    }\n}\nexports.ClientApiStream = ClientApiStream;\nclass ClientInteractionClientStream {\n    data;\n    /**\n     * Creates an instance of ClientInteractionClientStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.ClientInteractionClientStreamMetaImpl();\n    toString(result) {\n        ClientInteractionClientStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, localApi) {\n        const dataInStatic = new aether_client_1.DataInOutStatic(this.data);\n        if (!ServerApiByUidClient.META)\n            throw new Error(`META not found for API type ServerApiByUidClient`);\n        ServerApiByUidClient.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());\n    }\n    static fromRemoteConsumer(context, remoteConsumer) {\n        const api = ServerApiByUidClient.META.makeRemote(context);\n        remoteConsumer(api);\n        return new ClientInteractionClientStream(context.remoteDataToArrayAsArray());\n    }\n}\nexports.ClientInteractionClientStream = ClientInteractionClientStream;\nclass GlobalApi {\n    data;\n    /**\n     * Creates an instance of GlobalApi.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.GlobalApiMetaImpl();\n    toString(result) {\n        GlobalApi.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!GlobalRegServerApi.META)\n            throw new Error(`META not found for API type GlobalRegServerApi`);\n        GlobalRegServerApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new GlobalApi(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = GlobalRegServerApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new GlobalApi(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new GlobalApi(encryptedData);\n    }\n}\nexports.GlobalApi = GlobalApi;\nclass GlobalRegClientApiStream {\n    data;\n    /**\n     * Creates an instance of GlobalRegClientApiStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.GlobalRegClientApiStreamMetaImpl();\n    toString(result) {\n        GlobalRegClientApiStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!GlobalRegClientApi.META)\n            throw new Error(`META not found for API type GlobalRegClientApi`);\n        GlobalRegClientApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new GlobalRegClientApiStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = GlobalRegClientApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new GlobalRegClientApiStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new GlobalRegClientApiStream(encryptedData);\n    }\n}\nexports.GlobalRegClientApiStream = GlobalRegClientApiStream;\nclass LoginClientStream {\n    data;\n    /**\n     * Creates an instance of LoginClientStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.LoginClientStreamMetaImpl();\n    toString(result) {\n        LoginClientStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!ClientApiSafe.META)\n            throw new Error(`META not found for API type ClientApiSafe`);\n        ClientApiSafe.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new LoginClientStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = ClientApiSafe.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new LoginClientStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new LoginClientStream(encryptedData);\n    }\n}\nexports.LoginClientStream = LoginClientStream;\nclass LoginStream {\n    data;\n    /**\n     * Creates an instance of LoginStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.LoginStreamMetaImpl();\n    toString(result) {\n        LoginStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!AuthorizedApi.META)\n            throw new Error(`META not found for API type AuthorizedApi`);\n        AuthorizedApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new LoginStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = AuthorizedApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new LoginStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new LoginStream(encryptedData);\n    }\n}\nexports.LoginStream = LoginStream;\nclass ServerRegistrationApiStream {\n    data;\n    /**\n     * Creates an instance of ServerRegistrationApiStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    static META = new Impl.ServerRegistrationApiStreamMetaImpl();\n    toString(result) {\n        ServerRegistrationApiStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!ServerRegistrationApi.META)\n            throw new Error(`META not found for API type ServerRegistrationApi`);\n        ServerRegistrationApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new ServerRegistrationApiStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = ServerRegistrationApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new ServerRegistrationApiStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new ServerRegistrationApiStream(encryptedData);\n    }\n}\nexports.ServerRegistrationApiStream = ServerRegistrationApiStream;\nvar ClientApiUnsafe;\n(function (ClientApiUnsafe) {\n    ClientApiUnsafe.META = new Impl.ClientApiUnsafeMetaImpl();\n})(ClientApiUnsafe || (exports.ClientApiUnsafe = ClientApiUnsafe = {}));\nclass ClientApiUnsafeLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ClientApiUnsafeLocal = ClientApiUnsafeLocal;\nvar ClientApiSafe;\n(function (ClientApiSafe) {\n    ClientApiSafe.META = new Impl.ClientApiSafeMetaImpl();\n})(ClientApiSafe || (exports.ClientApiSafe = ClientApiSafe = {}));\nclass ClientApiSafeLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ClientApiSafeLocal = ClientApiSafeLocal;\nvar AuthorizedApi;\n(function (AuthorizedApi) {\n    AuthorizedApi.META = new Impl.AuthorizedApiMetaImpl();\n})(AuthorizedApi || (exports.AuthorizedApi = AuthorizedApi = {}));\nclass AuthorizedApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.AuthorizedApiLocal = AuthorizedApiLocal;\nvar LoginApi;\n(function (LoginApi) {\n    LoginApi.META = new Impl.LoginApiMetaImpl();\n})(LoginApi || (exports.LoginApi = LoginApi = {}));\nclass LoginApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.LoginApiLocal = LoginApiLocal;\nvar ServerApiByUidClient;\n(function (ServerApiByUidClient) {\n    ServerApiByUidClient.META = new Impl.ServerApiByUidClientMetaImpl();\n})(ServerApiByUidClient || (exports.ServerApiByUidClient = ServerApiByUidClient = {}));\nclass ServerApiByUidClientLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ServerApiByUidClientLocal = ServerApiByUidClientLocal;\nvar ServerApiByUid;\n(function (ServerApiByUid) {\n    ServerApiByUid.META = new Impl.ServerApiByUidMetaImpl();\n})(ServerApiByUid || (exports.ServerApiByUid = ServerApiByUid = {}));\nclass ServerApiByUidLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ServerApiByUidLocal = ServerApiByUidLocal;\nvar ClientApiRegSafe;\n(function (ClientApiRegSafe) {\n    ClientApiRegSafe.META = new Impl.ClientApiRegSafeMetaImpl();\n})(ClientApiRegSafe || (exports.ClientApiRegSafe = ClientApiRegSafe = {}));\nclass ClientApiRegSafeLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ClientApiRegSafeLocal = ClientApiRegSafeLocal;\nvar GlobalRegClientApi;\n(function (GlobalRegClientApi) {\n    GlobalRegClientApi.META = new Impl.GlobalRegClientApiMetaImpl();\n})(GlobalRegClientApi || (exports.GlobalRegClientApi = GlobalRegClientApi = {}));\nclass GlobalRegClientApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.GlobalRegClientApiLocal = GlobalRegClientApiLocal;\nvar ClientApiRegUnsafe;\n(function (ClientApiRegUnsafe) {\n    ClientApiRegUnsafe.META = new Impl.ClientApiRegUnsafeMetaImpl();\n})(ClientApiRegUnsafe || (exports.ClientApiRegUnsafe = ClientApiRegUnsafe = {}));\nclass ClientApiRegUnsafeLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ClientApiRegUnsafeLocal = ClientApiRegUnsafeLocal;\nvar GlobalRegServerApi;\n(function (GlobalRegServerApi) {\n    GlobalRegServerApi.META = new Impl.GlobalRegServerApiMetaImpl();\n})(GlobalRegServerApi || (exports.GlobalRegServerApi = GlobalRegServerApi = {}));\nclass GlobalRegServerApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.GlobalRegServerApiLocal = GlobalRegServerApiLocal;\nvar ServerRegistrationApi;\n(function (ServerRegistrationApi) {\n    ServerRegistrationApi.META = new Impl.ServerRegistrationApiMetaImpl();\n})(ServerRegistrationApi || (exports.ServerRegistrationApi = ServerRegistrationApi = {}));\nclass ServerRegistrationApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.ServerRegistrationApiLocal = ServerRegistrationApiLocal;\nvar RegistrationRootApi;\n(function (RegistrationRootApi) {\n    RegistrationRootApi.META = new Impl.RegistrationRootApiMetaImpl();\n})(RegistrationRootApi || (exports.RegistrationRootApi = RegistrationRootApi = {}));\nclass RegistrationRootApiLocal {\n    remoteApi;\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.RegistrationRootApiLocal = RegistrationRootApiLocal;\n//# sourceMappingURL=aether_api.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_api.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_api_impl.js":
/*!*************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_api_impl.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IPAddressV4MetaImpl = exports.IPAddressV4MetaBodyImpl = exports.IPAddressAndPortsListMetaBodyImpl = exports.IPAddressAndPortsMetaBodyImpl = exports.HydrogenSignPublicMetaImpl = exports.HydrogenSignPublicMetaBodyImpl = exports.HydrogenSignPrivateMetaImpl = exports.HydrogenSignPrivateMetaBodyImpl = exports.HydrogenSecretBoxMetaImpl = exports.HydrogenSecretBoxMetaBodyImpl = exports.HydrogenCurvePublicMetaImpl = exports.HydrogenCurvePublicMetaBodyImpl = exports.HydrogenCurvePrivateMetaImpl = exports.HydrogenCurvePrivateMetaBodyImpl = exports.FinishResultMetaBodyImpl = exports.CoderAndPortMetaBodyImpl = exports.CloudMetaBodyImpl = exports.ClientStateForSaveMetaBodyImpl = exports.ClientInfoMetaBodyImpl = exports.AetherStructDescriptorMetaBodyImpl = exports.AetherStreamTypeMetaBodyImpl = exports.AetherNullableTypeMetaBodyImpl = exports.AetherModuleDescriptorMetaBodyImpl = exports.AetherMethodDescriptorMetaBodyImpl = exports.AetherFieldDescriptorMetaBodyImpl = exports.AetherBaseTypeMetaBodyImpl = exports.AetherArrayTypeMetaBodyImpl = exports.AetherArgumentDescriptorMetaBodyImpl = exports.AetherApiDefinitionMetaBodyImpl = exports.AccessGroupMetaBodyImpl = exports.AccessCheckResultMetaBodyImpl = exports.AccessCheckPairMetaBodyImpl = exports.WorkProofConfigMetaImpl = exports.TelemetryMetaImpl = exports.SignMetaImpl = exports.PairKeysMetaImpl = exports.KeySymmetricMetaImpl = exports.KeySignPublicMetaImpl = exports.KeySignPrivateMetaImpl = exports.KeySignMetaImpl = exports.KeyAsymmetricPublicMetaImpl = exports.KeyAsymmetricPrivateMetaImpl = exports.KeyAsymmetricMetaImpl = exports.KeyMetaImpl = exports.IPAddressMetaImpl = exports.AetherTypeDescriptorMetaImpl = exports.StatusMetaImpl = exports.PowMethodMetaImpl = exports.CryptoLibMetaImpl = exports.AetherCodecMetaImpl = void 0;\nexports.GlobalRegServerApiMetaImpl = exports.ClientApiRegUnsafeMetaImpl = exports.GlobalRegClientApiMetaImpl = exports.ClientApiRegSafeMetaImpl = exports.ServerApiByUidMetaImpl = exports.ServerApiByUidClientMetaImpl = exports.LoginApiMetaImpl = exports.AuthorizedApiMetaImpl = exports.ClientApiSafeMetaImpl = exports.ClientApiUnsafeMetaImpl = exports.ServerRegistrationApiStreamMetaImpl = exports.LoginStreamMetaImpl = exports.LoginClientStreamMetaImpl = exports.GlobalRegClientApiStreamMetaImpl = exports.GlobalApiMetaImpl = exports.ClientInteractionClientStreamMetaImpl = exports.ClientApiStreamMetaImpl = exports.ClientApiRegSafeStreamMetaImpl = exports.WorkProofDTOMetaBodyImpl = exports.WorkProofBCryptMetaImpl = exports.WorkProofBCryptMetaBodyImpl = exports.UUIDAndCloudMetaBodyImpl = exports.TelemetryCPPMetaImpl = exports.TelemetryCPPMetaBodyImpl = exports.SodiumSignPublicMetaImpl = exports.SodiumSignPublicMetaBodyImpl = exports.SodiumSignPrivateMetaImpl = exports.SodiumSignPrivateMetaBodyImpl = exports.SodiumCurvePublicMetaImpl = exports.SodiumCurvePublicMetaBodyImpl = exports.SodiumCurvePrivateMetaImpl = exports.SodiumCurvePrivateMetaBodyImpl = exports.SodiumChacha20Poly1305MetaImpl = exports.SodiumChacha20Poly1305MetaBodyImpl = exports.SignHYDROGENMetaImpl = exports.SignHYDROGENMetaBodyImpl = exports.SignedKeyMetaBodyImpl = exports.SignAE_ED25519MetaImpl = exports.SignAE_ED25519MetaBodyImpl = exports.ServerDescriptorMetaBodyImpl = exports.PairKeysSignMetaImpl = exports.PairKeysSignMetaBodyImpl = exports.PairKeysAsymSignedMetaImpl = exports.PairKeysAsymSignedMetaBodyImpl = exports.PairKeysAsymMetaImpl = exports.PairKeysAsymMetaBodyImpl = exports.MoneyOperationMetaBodyImpl = exports.MessageMetaBodyImpl = exports.IPAddressV6MetaImpl = exports.IPAddressV6MetaBodyImpl = void 0;\nexports.RegistrationRootApiMetaImpl = exports.ServerRegistrationApiMetaImpl = void 0;\nconst aether_client_1 = __webpack_require__(/*! ./aether_client */ \"./node_modules/aether-client/build/aether_client.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\n// This is always relative\nclass AetherCodecMetaImpl {\n    serialize(_sCtx, obj, out) {\n        const values = Object.keys(aether_api_1.AetherCodec).filter(k => isNaN(parseInt(k)));\n        out.writeByte(values.indexOf(obj));\n    }\n    deserialize(_sCtx, in_) {\n        const ordinal = in_.readUByte();\n        const keys = Object.keys(aether_api_1.AetherCodec).filter(k => isNaN(parseInt(k)));\n        if (ordinal < 0 || ordinal >= keys.length)\n            throw new Error(`Invalid ordinal $ {\n            ordinal\n        }\n        for enum AetherCodec`);\n        return aether_api_1.AetherCodec[keys[ordinal]];\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_STRING.metaHashCode(obj);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_STRING.metaEquals(v1, v2);\n    }\n    metaToString(obj, res) {\n        res.add(obj);\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherCodecMetaImpl = AetherCodecMetaImpl;\nclass CryptoLibMetaImpl {\n    serialize(_sCtx, obj, out) {\n        const values = Object.keys(aether_api_1.CryptoLib).filter(k => isNaN(parseInt(k)));\n        out.writeByte(values.indexOf(obj));\n    }\n    deserialize(_sCtx, in_) {\n        const ordinal = in_.readUByte();\n        const keys = Object.keys(aether_api_1.CryptoLib).filter(k => isNaN(parseInt(k)));\n        if (ordinal < 0 || ordinal >= keys.length)\n            throw new Error(`Invalid ordinal $ {\n            ordinal\n        }\n        for enum CryptoLib`);\n        return aether_api_1.CryptoLib[keys[ordinal]];\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_STRING.metaHashCode(obj);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_STRING.metaEquals(v1, v2);\n    }\n    metaToString(obj, res) {\n        res.add(obj);\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.CryptoLibMetaImpl = CryptoLibMetaImpl;\nclass PowMethodMetaImpl {\n    serialize(_sCtx, obj, out) {\n        const values = Object.keys(aether_api_1.PowMethod).filter(k => isNaN(parseInt(k)));\n        out.writeByte(values.indexOf(obj));\n    }\n    deserialize(_sCtx, in_) {\n        const ordinal = in_.readUByte();\n        const keys = Object.keys(aether_api_1.PowMethod).filter(k => isNaN(parseInt(k)));\n        if (ordinal < 0 || ordinal >= keys.length)\n            throw new Error(`Invalid ordinal $ {\n            ordinal\n        }\n        for enum PowMethod`);\n        return aether_api_1.PowMethod[keys[ordinal]];\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_STRING.metaHashCode(obj);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_STRING.metaEquals(v1, v2);\n    }\n    metaToString(obj, res) {\n        res.add(obj);\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PowMethodMetaImpl = PowMethodMetaImpl;\nclass StatusMetaImpl {\n    serialize(_sCtx, obj, out) {\n        const values = Object.keys(aether_api_1.Status).filter(k => isNaN(parseInt(k)));\n        out.writeByte(values.indexOf(obj));\n    }\n    deserialize(_sCtx, in_) {\n        const ordinal = in_.readUByte();\n        const keys = Object.keys(aether_api_1.Status).filter(k => isNaN(parseInt(k)));\n        if (ordinal < 0 || ordinal >= keys.length)\n            throw new Error(`Invalid ordinal $ {\n            ordinal\n        }\n        for enum Status`);\n        return aether_api_1.Status[keys[ordinal]];\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_STRING.metaHashCode(obj);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_STRING.metaEquals(v1, v2);\n    }\n    metaToString(obj, res) {\n        res.add(obj);\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.StatusMetaImpl = StatusMetaImpl;\nclass AetherTypeDescriptorMetaImpl {\n    serialize(sCtx_0, obj_1, _out_2) {\n        const typeId = typeof obj_1.getAetherTypeId === 'function' ? obj_1.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'AetherTypeDescriptor' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_2.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'AetherTypeDescriptor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_0, in__3) {\n        const typeId = in__3.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'AetherTypeDescriptor'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'AetherTypeDescriptor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'AetherTypeDescriptor' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'AetherTypeDescriptor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherTypeDescriptorMetaImpl = AetherTypeDescriptorMetaImpl;\nclass IPAddressMetaImpl {\n    serialize(sCtx_4, obj_5, _out_6) {\n        const typeId = typeof obj_5.getAetherTypeId === 'function' ? obj_5.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'IPAddress' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_6.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.IPAddressV4.META_BODY.serialize(sCtx_4, obj_5, _out_6);\n                break;\n            case 2:\n                aether_api_1.IPAddressV6.META_BODY.serialize(sCtx_4, obj_5, _out_6);\n                break;\n            default: throw new Error(`Cannot serialize 'IPAddress' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_4, in__7) {\n        const typeId = in__7.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.IPAddressV4.META_BODY.deserialize(sCtx_4, in__7);\n            case 2: return aether_api_1.IPAddressV6.META_BODY.deserialize(sCtx_4, in__7);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'IPAddress'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.IPAddressV4.META.metaHashCode(obj);\n            case 2: return aether_api_1.IPAddressV6.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'IPAddress' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.IPAddressV4.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.IPAddressV6.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'IPAddress' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.IPAddressV4.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.IPAddressV6.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'IPAddress' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressMetaImpl = IPAddressMetaImpl;\nclass KeyMetaImpl {\n    serialize(sCtx_8, obj_9, _out_10) {\n        const typeId = typeof obj_9.getAetherTypeId === 'function' ? obj_9.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Key' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_10.writeByte(typeId);\n        switch (typeId) {\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_8, obj_9, _out_10);\n                break;\n            default: throw new Error(`Cannot serialize 'Key' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_8, in__11) {\n        const typeId = in__11.readUByte();\n        switch (typeId) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_8, in__11);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_8, in__11);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_8, in__11);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_8, in__11);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_8, in__11);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_8, in__11);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_8, in__11);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_8, in__11);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_8, in__11);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_8, in__11);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Key'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Key' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Key' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Key' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeyMetaImpl = KeyMetaImpl;\nclass KeyAsymmetricMetaImpl {\n    serialize(sCtx_12, obj_14, _out_15) {\n        const typeId = typeof obj_14.getAetherTypeId === 'function' ? obj_14.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeyAsymmetric' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_15.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeyAsymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_13, in__16) {\n        const typeId = in__16.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeyAsymmetric'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeyAsymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeyAsymmetric' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeyAsymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeyAsymmetricMetaImpl = KeyAsymmetricMetaImpl;\nclass KeyAsymmetricPrivateMetaImpl {\n    serialize(sCtx_17, obj_19, _out_20) {\n        const typeId = typeof obj_19.getAetherTypeId === 'function' ? obj_19.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_20.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeyAsymmetricPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_18, in__21) {\n        const typeId = in__21.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeyAsymmetricPrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeyAsymmetricPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeyAsymmetricPrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeyAsymmetricPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeyAsymmetricPrivateMetaImpl = KeyAsymmetricPrivateMetaImpl;\nclass KeyAsymmetricPublicMetaImpl {\n    serialize(sCtx_22, obj_24, _out_25) {\n        const typeId = typeof obj_24.getAetherTypeId === 'function' ? obj_24.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_25.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeyAsymmetricPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_23, in__26) {\n        const typeId = in__26.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeyAsymmetricPublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeyAsymmetricPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeyAsymmetricPublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeyAsymmetricPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeyAsymmetricPublicMetaImpl = KeyAsymmetricPublicMetaImpl;\nclass KeySignMetaImpl {\n    serialize(sCtx_27, obj_29, _out_30) {\n        const typeId = typeof obj_29.getAetherTypeId === 'function' ? obj_29.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeySign' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_30.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeySign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_28, in__31) {\n        const typeId = in__31.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeySign'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeySign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeySign' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeySign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeySignMetaImpl = KeySignMetaImpl;\nclass KeySignPrivateMetaImpl {\n    serialize(sCtx_32, obj_34, _out_35) {\n        const typeId = typeof obj_34.getAetherTypeId === 'function' ? obj_34.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeySignPrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_35.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeySignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_33, in__36) {\n        const typeId = in__36.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeySignPrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeySignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeySignPrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeySignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeySignPrivateMetaImpl = KeySignPrivateMetaImpl;\nclass KeySignPublicMetaImpl {\n    serialize(sCtx_37, obj_39, _out_40) {\n        const typeId = typeof obj_39.getAetherTypeId === 'function' ? obj_39.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeySignPublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_40.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeySignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_38, in__41) {\n        const typeId = in__41.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeySignPublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeySignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeySignPublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeySignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeySignPublicMetaImpl = KeySignPublicMetaImpl;\nclass KeySymmetricMetaImpl {\n    serialize(sCtx_42, obj_44, _out_45) {\n        const typeId = typeof obj_44.getAetherTypeId === 'function' ? obj_44.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'KeySymmetric' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_45.writeByte(typeId);\n        switch (typeId) {\n            default: throw new Error(`Cannot serialize 'KeySymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_43, in__46) {\n        const typeId = in__46.readUByte();\n        switch (typeId) {\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'KeySymmetric'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot hashCode 'KeySymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            default: throw new Error(`Cannot equals 'KeySymmetric' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            default: throw new Error(`Cannot toString 'KeySymmetric' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.KeySymmetricMetaImpl = KeySymmetricMetaImpl;\nclass PairKeysMetaImpl {\n    serialize(sCtx_47, obj_48, _out_49) {\n        const typeId = typeof obj_48.getAetherTypeId === 'function' ? obj_48.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'PairKeys' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_49.writeByte(typeId);\n        switch (typeId) {\n            case 3:\n                aether_api_1.PairKeysSign.META_BODY.serialize(sCtx_47, obj_48, _out_49);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META_BODY.serialize(sCtx_47, obj_48, _out_49);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META_BODY.serialize(sCtx_47, obj_48, _out_49);\n                break;\n            default: throw new Error(`Cannot serialize 'PairKeys' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_47, in__50) {\n        const typeId = in__50.readUByte();\n        switch (typeId) {\n            case 3: return aether_api_1.PairKeysSign.META_BODY.deserialize(sCtx_47, in__50);\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.deserialize(sCtx_47, in__50);\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.deserialize(sCtx_47, in__50);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'PairKeys'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3: return aether_api_1.PairKeysSign.META.metaHashCode(obj);\n            case 1: return aether_api_1.PairKeysAsym.META.metaHashCode(obj);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'PairKeys' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 3: return aether_api_1.PairKeysSign.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.PairKeysAsym.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'PairKeys' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3:\n                aether_api_1.PairKeysSign.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'PairKeys' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysMetaImpl = PairKeysMetaImpl;\nclass SignMetaImpl {\n    serialize(sCtx_51, obj_52, _out_53) {\n        const typeId = typeof obj_52.getAetherTypeId === 'function' ? obj_52.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Sign' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_53.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.SignAE_ED25519.META_BODY.serialize(sCtx_51, obj_52, _out_53);\n                break;\n            case 2:\n                aether_api_1.SignHYDROGEN.META_BODY.serialize(sCtx_51, obj_52, _out_53);\n                break;\n            default: throw new Error(`Cannot serialize 'Sign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_51, in__54) {\n        const typeId = in__54.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.SignAE_ED25519.META_BODY.deserialize(sCtx_51, in__54);\n            case 2: return aether_api_1.SignHYDROGEN.META_BODY.deserialize(sCtx_51, in__54);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Sign'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.SignAE_ED25519.META.metaHashCode(obj);\n            case 2: return aether_api_1.SignHYDROGEN.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Sign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.SignAE_ED25519.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.SignHYDROGEN.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Sign' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.SignAE_ED25519.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.SignHYDROGEN.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Sign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignMetaImpl = SignMetaImpl;\nclass TelemetryMetaImpl {\n    serialize(sCtx_55, obj_56, _out_57) {\n        const typeId = typeof obj_56.getAetherTypeId === 'function' ? obj_56.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Telemetry' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_57.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.TelemetryCPP.META_BODY.serialize(sCtx_55, obj_56, _out_57);\n                break;\n            default: throw new Error(`Cannot serialize 'Telemetry' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_55, in__58) {\n        const typeId = in__58.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.TelemetryCPP.META_BODY.deserialize(sCtx_55, in__58);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Telemetry'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.TelemetryCPP.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Telemetry' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.TelemetryCPP.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Telemetry' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.TelemetryCPP.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Telemetry' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.TelemetryMetaImpl = TelemetryMetaImpl;\nclass WorkProofConfigMetaImpl {\n    serialize(sCtx_59, obj_60, _out_61) {\n        const typeId = typeof obj_60.getAetherTypeId === 'function' ? obj_60.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'WorkProofConfig' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_61.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.WorkProofBCrypt.META_BODY.serialize(sCtx_59, obj_60, _out_61);\n                break;\n            default: throw new Error(`Cannot serialize 'WorkProofConfig' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_59, in__62) {\n        const typeId = in__62.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.WorkProofBCrypt.META_BODY.deserialize(sCtx_59, in__62);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'WorkProofConfig'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.WorkProofBCrypt.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'WorkProofConfig' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.WorkProofBCrypt.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'WorkProofConfig' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.WorkProofBCrypt.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'WorkProofConfig' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.WorkProofConfigMetaImpl = WorkProofConfigMetaImpl;\nclass AccessCheckPairMetaBodyImpl {\n    serialize(sCtx_63, obj_64, _out_65) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_63, obj_64.sourceUid, _out_65);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_63, obj_64.targetUid, _out_65);\n    }\n    deserialize(sCtx_63, in__66) {\n        let sourceUid_67;\n        let targetUid_68;\n        sourceUid_67 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_63, in__66);\n        targetUid_68 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_63, in__66);\n        return new aether_api_1.AccessCheckPair(sourceUid_67, targetUid_68);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.sourceUid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.targetUid);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AccessCheckPair))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.sourceUid, v2.sourceUid))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.targetUid, v2.targetUid))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AccessCheckPair(');\n        res.add('sourceUid:').add(obj.sourceUid);\n        res.add(', ');\n        res.add('targetUid:').add(obj.targetUid);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AccessCheckPairMetaBodyImpl = AccessCheckPairMetaBodyImpl;\nclass AccessCheckResultMetaBodyImpl {\n    serialize(sCtx_69, obj_70, _out_71) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_69, obj_70.sourceUid, _out_71);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_69, obj_70.targetUid, _out_71);\n        _out_71.writeBoolean(obj_70.hasAccess);\n    }\n    deserialize(sCtx_69, in__72) {\n        let sourceUid_73;\n        let targetUid_74;\n        let hasAccess_75;\n        sourceUid_73 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_69, in__72);\n        targetUid_74 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_69, in__72);\n        hasAccess_75 = in__72.readBoolean();\n        return new aether_api_1.AccessCheckResult(sourceUid_73, targetUid_74, hasAccess_75);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.sourceUid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.targetUid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_BOOLEAN.metaHashCode(obj.hasAccess);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AccessCheckResult))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.sourceUid, v2.sourceUid))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.targetUid, v2.targetUid))\n            return false;\n        if (!aether_client_1.FastMeta.META_BOOLEAN.metaEquals(v1.hasAccess, v2.hasAccess))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AccessCheckResult(');\n        res.add('sourceUid:').add(obj.sourceUid);\n        res.add(', ');\n        res.add('targetUid:').add(obj.targetUid);\n        res.add(', ');\n        res.add('hasAccess:').add(obj.hasAccess);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AccessCheckResultMetaBodyImpl = AccessCheckResultMetaBodyImpl;\nclass AccessGroupMetaBodyImpl {\n    serialize(sCtx_76, obj_77, _out_78) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_76, obj_77.owner, _out_78);\n        _out_78.writeLong(obj_77.id);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_78, obj_77.data.length);\n        for (const el_80 of obj_77.data) {\n            aether_client_1.FastMeta.META_UUID.serialize(sCtx_76, el_80, _out_78);\n        }\n    }\n    deserialize(sCtx_76, in__79) {\n        let owner_81;\n        let id_82;\n        let data_83;\n        owner_81 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_76, in__79);\n        id_82 = in__79.readLong();\n        const len_85 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__79));\n        data_83 = new Array(len_85);\n        for (let idx_84 = 0; idx_84 < len_85; idx_84++) {\n            data_83[idx_84] = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_76, in__79);\n        }\n        return new aether_api_1.AccessGroup(owner_81, id_82, data_83);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.owner);\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_UUID).metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AccessGroup))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.owner, v2.owner))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_UUID).metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AccessGroup(');\n        res.add('owner:').add(obj.owner);\n        res.add(', ');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AccessGroupMetaBodyImpl = AccessGroupMetaBodyImpl;\nclass AetherApiDefinitionMetaBodyImpl {\n    serialize(sCtx_86, obj_87, _out_88) {\n        let _mask = 0;\n        if (obj_87.docId === null)\n            _mask |= 1;\n        _out_88.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_88, obj_87.id);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_88, obj_87.nameId);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_88, obj_87.methods.length);\n        for (const el_90 of obj_87.methods) {\n            aether_api_1.AetherMethodDescriptor.META.serialize(sCtx_86, el_90, _out_88);\n        }\n        if (obj_87.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_88, obj_87.docId);\n        }\n    }\n    deserialize(sCtx_86, in__89) {\n        let id_91;\n        let nameId_92;\n        let methods_93;\n        let docId_94;\n        const _mask = in__89.readByte();\n        id_91 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__89);\n        nameId_92 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__89);\n        const len_96 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__89));\n        methods_93 = new Array(len_96);\n        for (let idx_95 = 0; idx_95 < len_96; idx_95++) {\n            methods_93[idx_95] = aether_api_1.AetherMethodDescriptor.META.deserialize(sCtx_86, in__89);\n        }\n        if (((_mask & 1) === 0)) {\n            docId_94 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__89);\n        }\n        else {\n            docId_94 = null;\n        }\n        return new aether_api_1.AetherApiDefinition(id_91, nameId_92, methods_93, docId_94);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.nameId);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherMethodDescriptor.META).metaHashCode(obj.methods);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherApiDefinition))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.nameId, v2.nameId))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherMethodDescriptor.META).metaEquals(v1.methods, v2.methods))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherApiDefinition(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('nameId:').add(obj.nameId);\n        res.add(', ');\n        res.add('methods:').add(obj.methods);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherApiDefinitionMetaBodyImpl = AetherApiDefinitionMetaBodyImpl;\nclass AetherArgumentDescriptorMetaBodyImpl {\n    serialize(sCtx_97, obj_98, _out_99) {\n        let _mask = 0;\n        if (obj_98.docId === null)\n            _mask |= 1;\n        _out_99.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_99, obj_98.nameId);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_99, obj_98.typeId);\n        if (obj_98.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_99, obj_98.docId);\n        }\n    }\n    deserialize(sCtx_97, in__100) {\n        let nameId_101;\n        let typeId_102;\n        let docId_103;\n        const _mask = in__100.readByte();\n        nameId_101 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__100);\n        typeId_102 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__100);\n        if (((_mask & 1) === 0)) {\n            docId_103 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__100);\n        }\n        else {\n            docId_103 = null;\n        }\n        return new aether_api_1.AetherArgumentDescriptor(nameId_101, typeId_102, docId_103);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.nameId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.typeId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherArgumentDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.nameId, v2.nameId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.typeId, v2.typeId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherArgumentDescriptor(');\n        res.add('nameId:').add(obj.nameId);\n        res.add(', ');\n        res.add('typeId:').add(obj.typeId);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherArgumentDescriptorMetaBodyImpl = AetherArgumentDescriptorMetaBodyImpl;\nclass AetherArrayTypeMetaBodyImpl {\n    serialize(sCtx_104, obj_105, _out_106) {\n        let _mask = 0;\n        if (obj_105.docId === null)\n            _mask |= 1;\n        _out_106.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_106, obj_105.id);\n        if (obj_105.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_106, obj_105.docId);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_106, obj_105.elementTypeId);\n    }\n    deserialize(sCtx_104, in__107) {\n        let id_108;\n        let docId_109;\n        let elementTypeId_110;\n        const _mask = in__107.readByte();\n        id_108 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__107);\n        if (((_mask & 1) === 0)) {\n            docId_109 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__107);\n        }\n        else {\n            docId_109 = null;\n        }\n        elementTypeId_110 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__107);\n        return new aether_api_1.AetherArrayType(id_108, docId_109, elementTypeId_110);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.elementTypeId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherArrayType))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.elementTypeId, v2.elementTypeId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherArrayType(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(', ');\n        res.add('elementTypeId:').add(obj.elementTypeId);\n        res.add(', ');\n        res.add('kind:').add(obj.getKind());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherArrayTypeMetaBodyImpl = AetherArrayTypeMetaBodyImpl;\nclass AetherBaseTypeMetaBodyImpl {\n    serialize(sCtx_111, obj_112, _out_113) {\n        let _mask = 0;\n        if (obj_112.docId === null)\n            _mask |= 1;\n        _out_113.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_113, obj_112.id);\n        if (obj_112.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_113, obj_112.docId);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_113, obj_112.nameId);\n    }\n    deserialize(sCtx_111, in__114) {\n        let id_115;\n        let docId_116;\n        let nameId_117;\n        const _mask = in__114.readByte();\n        id_115 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__114);\n        if (((_mask & 1) === 0)) {\n            docId_116 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__114);\n        }\n        else {\n            docId_116 = null;\n        }\n        nameId_117 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__114);\n        return new aether_api_1.AetherBaseType(id_115, docId_116, nameId_117);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.nameId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherBaseType))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.nameId, v2.nameId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherBaseType(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(', ');\n        res.add('nameId:').add(obj.nameId);\n        res.add(', ');\n        res.add('kind:').add(obj.getKind());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherBaseTypeMetaBodyImpl = AetherBaseTypeMetaBodyImpl;\nclass AetherFieldDescriptorMetaBodyImpl {\n    serialize(sCtx_118, obj_119, _out_120) {\n        let _mask = 0;\n        if (obj_119.docId === null)\n            _mask |= 1;\n        _out_120.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_120, obj_119.nameId);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_120, obj_119.typeId);\n        if (obj_119.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_120, obj_119.docId);\n        }\n    }\n    deserialize(sCtx_118, in__121) {\n        let nameId_122;\n        let typeId_123;\n        let docId_124;\n        const _mask = in__121.readByte();\n        nameId_122 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__121);\n        typeId_123 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__121);\n        if (((_mask & 1) === 0)) {\n            docId_124 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__121);\n        }\n        else {\n            docId_124 = null;\n        }\n        return new aether_api_1.AetherFieldDescriptor(nameId_122, typeId_123, docId_124);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.nameId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.typeId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherFieldDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.nameId, v2.nameId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.typeId, v2.typeId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherFieldDescriptor(');\n        res.add('nameId:').add(obj.nameId);\n        res.add(', ');\n        res.add('typeId:').add(obj.typeId);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherFieldDescriptorMetaBodyImpl = AetherFieldDescriptorMetaBodyImpl;\nclass AetherMethodDescriptorMetaBodyImpl {\n    serialize(sCtx_125, obj_126, _out_127) {\n        let _mask = 0;\n        if (obj_126.docId === null)\n            _mask |= 1;\n        _out_127.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_127, obj_126.nameId);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_127, obj_126.args.length);\n        for (const el_129 of obj_126.args) {\n            aether_api_1.AetherArgumentDescriptor.META.serialize(sCtx_125, el_129, _out_127);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_127, obj_126.returnTypeId);\n        if (obj_126.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_127, obj_126.docId);\n        }\n    }\n    deserialize(sCtx_125, in__128) {\n        let nameId_130;\n        let args_131;\n        let returnTypeId_132;\n        let docId_133;\n        const _mask = in__128.readByte();\n        nameId_130 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__128);\n        const len_135 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__128));\n        args_131 = new Array(len_135);\n        for (let idx_134 = 0; idx_134 < len_135; idx_134++) {\n            args_131[idx_134] = aether_api_1.AetherArgumentDescriptor.META.deserialize(sCtx_125, in__128);\n        }\n        returnTypeId_132 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__128);\n        if (((_mask & 1) === 0)) {\n            docId_133 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__128);\n        }\n        else {\n            docId_133 = null;\n        }\n        return new aether_api_1.AetherMethodDescriptor(nameId_130, args_131, returnTypeId_132, docId_133);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.nameId);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherArgumentDescriptor.META).metaHashCode(obj.args);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.returnTypeId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherMethodDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.nameId, v2.nameId))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherArgumentDescriptor.META).metaEquals(v1.args, v2.args))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.returnTypeId, v2.returnTypeId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherMethodDescriptor(');\n        res.add('nameId:').add(obj.nameId);\n        res.add(', ');\n        res.add('args:').add(obj.args);\n        res.add(', ');\n        res.add('returnTypeId:').add(obj.returnTypeId);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherMethodDescriptorMetaBodyImpl = AetherMethodDescriptorMetaBodyImpl;\nclass AetherModuleDescriptorMetaBodyImpl {\n    serialize(sCtx_136, obj_137, _out_138) {\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_138, obj_137.stringPool.length);\n        for (const el_140 of obj_137.stringPool) {\n            const stringBytes_141 = new TextEncoder().encode(el_140);\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_138, stringBytes_141.length);\n            _out_138.write(stringBytes_141);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_138, obj_137.typeRegistry.length);\n        for (const el_143 of obj_137.typeRegistry) {\n            aether_api_1.AetherTypeDescriptor.META.serialize(sCtx_136, el_143, _out_138);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_138, obj_137.structs.length);\n        for (const el_144 of obj_137.structs) {\n            aether_api_1.AetherStructDescriptor.META.serialize(sCtx_136, el_144, _out_138);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_138, obj_137.apis.length);\n        for (const el_145 of obj_137.apis) {\n            aether_api_1.AetherApiDefinition.META.serialize(sCtx_136, el_145, _out_138);\n        }\n    }\n    deserialize(sCtx_136, in__139) {\n        let stringPool_146;\n        let typeRegistry_147;\n        let structs_148;\n        let apis_149;\n        const len_151 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__139));\n        stringPool_146 = new Array(len_151);\n        for (let idx_150 = 0; idx_150 < len_151; idx_150++) {\n            let stringBytes_152;\n            const len_154 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__139));\n            const bytes_155 = in__139.readBytes(len_154);\n            stringBytes_152 = bytes_155;\n            stringPool_146[idx_150] = new TextDecoder('utf-8').decode(stringBytes_152);\n        }\n        const len_157 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__139));\n        typeRegistry_147 = new Array(len_157);\n        for (let idx_156 = 0; idx_156 < len_157; idx_156++) {\n            typeRegistry_147[idx_156] = aether_api_1.AetherTypeDescriptor.META.deserialize(sCtx_136, in__139);\n        }\n        const len_159 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__139));\n        structs_148 = new Array(len_159);\n        for (let idx_158 = 0; idx_158 < len_159; idx_158++) {\n            structs_148[idx_158] = aether_api_1.AetherStructDescriptor.META.deserialize(sCtx_136, in__139);\n        }\n        const len_161 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__139));\n        apis_149 = new Array(len_161);\n        for (let idx_160 = 0; idx_160 < len_161; idx_160++) {\n            apis_149[idx_160] = aether_api_1.AetherApiDefinition.META.deserialize(sCtx_136, in__139);\n        }\n        return new aether_api_1.AetherModuleDescriptor(stringPool_146, typeRegistry_147, structs_148, apis_149);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_STRING).metaHashCode(obj.stringPool);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherTypeDescriptor.META).metaHashCode(obj.typeRegistry);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherStructDescriptor.META).metaHashCode(obj.structs);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherApiDefinition.META).metaHashCode(obj.apis);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherModuleDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_STRING).metaEquals(v1.stringPool, v2.stringPool))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherTypeDescriptor.META).metaEquals(v1.typeRegistry, v2.typeRegistry))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherStructDescriptor.META).metaEquals(v1.structs, v2.structs))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherApiDefinition.META).metaEquals(v1.apis, v2.apis))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherModuleDescriptor(');\n        res.add('stringPool:').add(obj.stringPool);\n        res.add(', ');\n        res.add('typeRegistry:').add(obj.typeRegistry);\n        res.add(', ');\n        res.add('structs:').add(obj.structs);\n        res.add(', ');\n        res.add('apis:').add(obj.apis);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherModuleDescriptorMetaBodyImpl = AetherModuleDescriptorMetaBodyImpl;\nclass AetherNullableTypeMetaBodyImpl {\n    serialize(sCtx_162, obj_163, _out_164) {\n        let _mask = 0;\n        if (obj_163.docId === null)\n            _mask |= 1;\n        _out_164.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_164, obj_163.id);\n        if (obj_163.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_164, obj_163.docId);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_164, obj_163.wrappedTypeId);\n    }\n    deserialize(sCtx_162, in__165) {\n        let id_166;\n        let docId_167;\n        let wrappedTypeId_168;\n        const _mask = in__165.readByte();\n        id_166 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__165);\n        if (((_mask & 1) === 0)) {\n            docId_167 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__165);\n        }\n        else {\n            docId_167 = null;\n        }\n        wrappedTypeId_168 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__165);\n        return new aether_api_1.AetherNullableType(id_166, docId_167, wrappedTypeId_168);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.wrappedTypeId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherNullableType))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.wrappedTypeId, v2.wrappedTypeId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherNullableType(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(', ');\n        res.add('wrappedTypeId:').add(obj.wrappedTypeId);\n        res.add(', ');\n        res.add('kind:').add(obj.getKind());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherNullableTypeMetaBodyImpl = AetherNullableTypeMetaBodyImpl;\nclass AetherStreamTypeMetaBodyImpl {\n    serialize(sCtx_169, obj_170, _out_171) {\n        let _mask = 0;\n        if (obj_170.docId === null)\n            _mask |= 1;\n        _out_171.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_171, obj_170.id);\n        if (obj_170.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_171, obj_170.docId);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_171, obj_170.apiId);\n        _out_171.writeBoolean(obj_170.isCrypto);\n    }\n    deserialize(sCtx_169, in__172) {\n        let id_173;\n        let docId_174;\n        let apiId_175;\n        let isCrypto_176;\n        const _mask = in__172.readByte();\n        id_173 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__172);\n        if (((_mask & 1) === 0)) {\n            docId_174 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__172);\n        }\n        else {\n            docId_174 = null;\n        }\n        apiId_175 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__172);\n        isCrypto_176 = in__172.readBoolean();\n        return new aether_api_1.AetherStreamType(id_173, docId_174, apiId_175, isCrypto_176);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.apiId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_BOOLEAN.metaHashCode(obj.isCrypto);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherStreamType))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.apiId, v2.apiId))\n            return false;\n        if (!aether_client_1.FastMeta.META_BOOLEAN.metaEquals(v1.isCrypto, v2.isCrypto))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherStreamType(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(', ');\n        res.add('apiId:').add(obj.apiId);\n        res.add(', ');\n        res.add('isCrypto:').add(obj.isCrypto);\n        res.add(', ');\n        res.add('kind:').add(obj.getKind());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherStreamTypeMetaBodyImpl = AetherStreamTypeMetaBodyImpl;\nclass AetherStructDescriptorMetaBodyImpl {\n    serialize(sCtx_177, obj_178, _out_179) {\n        let _mask = 0;\n        if (obj_178.parentTypeId === null)\n            _mask |= 1;\n        if (obj_178.docId === null)\n            _mask |= (1 << 1);\n        _out_179.writeByte(_mask);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_179, obj_178.baseTypeId);\n        if (obj_178.parentTypeId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_179, obj_178.parentTypeId);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_179, obj_178.fields.length);\n        for (const el_181 of obj_178.fields) {\n            aether_api_1.AetherFieldDescriptor.META.serialize(sCtx_177, el_181, _out_179);\n        }\n        if (obj_178.docId !== null) {\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_179, obj_178.docId);\n        }\n    }\n    deserialize(sCtx_177, in__180) {\n        let baseTypeId_182;\n        let parentTypeId_183;\n        let fields_184;\n        let docId_185;\n        const _mask = in__180.readByte();\n        baseTypeId_182 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__180);\n        if (((_mask & 1) === 0)) {\n            parentTypeId_183 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__180);\n        }\n        else {\n            parentTypeId_183 = null;\n        }\n        const len_187 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__180));\n        fields_184 = new Array(len_187);\n        for (let idx_186 = 0; idx_186 < len_187; idx_186++) {\n            fields_184[idx_186] = aether_api_1.AetherFieldDescriptor.META.deserialize(sCtx_177, in__180);\n        }\n        if (((_mask & (1 << 1)) === 0)) {\n            docId_185 = aether_client_1.DeserializerPackNumber.INSTANCE.put(in__180);\n        }\n        else {\n            docId_185 = null;\n        }\n        return new aether_api_1.AetherStructDescriptor(baseTypeId_182, parentTypeId_183, fields_184, docId_185);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.baseTypeId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.parentTypeId);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherFieldDescriptor.META).metaHashCode(obj.fields);\n        hash = 37 * hash + aether_client_1.FastMeta.META_PACK.metaHashCode(obj.docId);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.AetherStructDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.baseTypeId, v2.baseTypeId))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.parentTypeId, v2.parentTypeId))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.AetherFieldDescriptor.META).metaEquals(v1.fields, v2.fields))\n            return false;\n        if (!aether_client_1.FastMeta.META_PACK.metaEquals(v1.docId, v2.docId))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('AetherStructDescriptor(');\n        res.add('baseTypeId:').add(obj.baseTypeId);\n        res.add(', ');\n        res.add('parentTypeId:').add(obj.parentTypeId);\n        res.add(', ');\n        res.add('fields:').add(obj.fields);\n        res.add(', ');\n        res.add('docId:').add(obj.docId);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.AetherStructDescriptorMetaBodyImpl = AetherStructDescriptorMetaBodyImpl;\nclass ClientInfoMetaBodyImpl {\n    serialize(sCtx_188, obj_189, _out_190) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_188, obj_189.uid, _out_190);\n        aether_api_1.Cloud.META.serialize(sCtx_188, obj_189.cloud, _out_190);\n    }\n    deserialize(sCtx_188, in__191) {\n        let uid_192;\n        let cloud_193;\n        uid_192 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_188, in__191);\n        cloud_193 = aether_api_1.Cloud.META.deserialize(sCtx_188, in__191);\n        return new aether_api_1.ClientInfo(uid_192, cloud_193);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.uid);\n        hash = 37 * hash + aether_api_1.Cloud.META.metaHashCode(obj.cloud);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.ClientInfo))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.uid, v2.uid))\n            return false;\n        if (!aether_api_1.Cloud.META.metaEquals(v1.cloud, v2.cloud))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ClientInfo(');\n        res.add('uid:').add(obj.uid);\n        res.add(', ');\n        res.add('cloud:').add(obj.cloud);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientInfoMetaBodyImpl = ClientInfoMetaBodyImpl;\nclass ClientStateForSaveMetaBodyImpl {\n    serialize(sCtx_194, obj_195, _out_196) {\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_196, obj_195.registrationUri.length);\n        for (const el_198 of obj_195.registrationUri) {\n            aether_client_1.FastMeta.META_URI.serialize(sCtx_194, el_198, _out_196);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_196, obj_195.servers.length);\n        for (const el_199 of obj_195.servers) {\n            aether_api_1.ServerDescriptor.META.serialize(sCtx_194, el_199, _out_196);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_196, obj_195.clients.length);\n        for (const el_200 of obj_195.clients) {\n            aether_api_1.ClientInfo.META.serialize(sCtx_194, el_200, _out_196);\n        }\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_196, obj_195.rootSigners.length);\n        for (const el_201 of obj_195.rootSigners) {\n            aether_api_1.Key.META.serialize(sCtx_194, el_201, _out_196);\n        }\n        aether_api_1.CryptoLib.META.serialize(sCtx_194, obj_195.cryptoLib, _out_196);\n        _out_196.writeLong(obj_195.pingDuration);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_194, obj_195.parentUid, _out_196);\n        _out_196.writeInt(obj_195.countServersForRegistration);\n        _out_196.writeLong(obj_195.timeoutForConnectToRegistrationServer);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_194, obj_195.uid, _out_196);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_194, obj_195.alias, _out_196);\n        aether_api_1.Key.META.serialize(sCtx_194, obj_195.masterKey, _out_196);\n    }\n    deserialize(sCtx_194, in__197) {\n        let registrationUri_202;\n        let servers_203;\n        let clients_204;\n        let rootSigners_205;\n        let cryptoLib_206;\n        let pingDuration_207;\n        let parentUid_208;\n        let countServersForRegistration_209;\n        let timeoutForConnectToRegistrationServer_210;\n        let uid_211;\n        let alias_212;\n        let masterKey_213;\n        const len_215 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__197));\n        registrationUri_202 = new Array(len_215);\n        for (let idx_214 = 0; idx_214 < len_215; idx_214++) {\n            registrationUri_202[idx_214] = aether_client_1.FastMeta.META_URI.deserialize(sCtx_194, in__197);\n        }\n        const len_217 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__197));\n        servers_203 = new Array(len_217);\n        for (let idx_216 = 0; idx_216 < len_217; idx_216++) {\n            servers_203[idx_216] = aether_api_1.ServerDescriptor.META.deserialize(sCtx_194, in__197);\n        }\n        const len_219 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__197));\n        clients_204 = new Array(len_219);\n        for (let idx_218 = 0; idx_218 < len_219; idx_218++) {\n            clients_204[idx_218] = aether_api_1.ClientInfo.META.deserialize(sCtx_194, in__197);\n        }\n        const len_221 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__197));\n        rootSigners_205 = new Array(len_221);\n        for (let idx_220 = 0; idx_220 < len_221; idx_220++) {\n            rootSigners_205[idx_220] = aether_api_1.Key.META.deserialize(sCtx_194, in__197);\n        }\n        cryptoLib_206 = aether_api_1.CryptoLib.META.deserialize(sCtx_194, in__197);\n        pingDuration_207 = in__197.readLong();\n        parentUid_208 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_194, in__197);\n        countServersForRegistration_209 = in__197.readInt();\n        timeoutForConnectToRegistrationServer_210 = in__197.readLong();\n        uid_211 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_194, in__197);\n        alias_212 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_194, in__197);\n        masterKey_213 = aether_api_1.Key.META.deserialize(sCtx_194, in__197);\n        return new aether_api_1.ClientStateForSave(registrationUri_202, servers_203, clients_204, rootSigners_205, cryptoLib_206, pingDuration_207, parentUid_208, countServersForRegistration_209, timeoutForConnectToRegistrationServer_210, uid_211, alias_212, masterKey_213);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_URI).metaHashCode(obj.registrationUri);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.ServerDescriptor.META).metaHashCode(obj.servers);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.ClientInfo.META).metaHashCode(obj.clients);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.Key.META).metaHashCode(obj.rootSigners);\n        hash = 37 * hash + aether_api_1.CryptoLib.META.metaHashCode(obj.cryptoLib);\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.pingDuration);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.parentUid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.countServersForRegistration);\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.timeoutForConnectToRegistrationServer);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.uid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.alias);\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.masterKey);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.ClientStateForSave))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_URI).metaEquals(v1.registrationUri, v2.registrationUri))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.ServerDescriptor.META).metaEquals(v1.servers, v2.servers))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.ClientInfo.META).metaEquals(v1.clients, v2.clients))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.Key.META).metaEquals(v1.rootSigners, v2.rootSigners))\n            return false;\n        if (!aether_api_1.CryptoLib.META.metaEquals(v1.cryptoLib, v2.cryptoLib))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.pingDuration, v2.pingDuration))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.parentUid, v2.parentUid))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.countServersForRegistration, v2.countServersForRegistration))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.timeoutForConnectToRegistrationServer, v2.timeoutForConnectToRegistrationServer))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.uid, v2.uid))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.alias, v2.alias))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.masterKey, v2.masterKey))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ClientStateForSave(');\n        res.add('registrationUri:').add(obj.registrationUri);\n        res.add(', ');\n        res.add('servers:').add(obj.servers);\n        res.add(', ');\n        res.add('clients:').add(obj.clients);\n        res.add(', ');\n        res.add('rootSigners:').add(obj.rootSigners);\n        res.add(', ');\n        res.add('cryptoLib:').add(obj.cryptoLib);\n        res.add(', ');\n        res.add('pingDuration:').add(obj.pingDuration);\n        res.add(', ');\n        res.add('parentUid:').add(obj.parentUid);\n        res.add(', ');\n        res.add('countServersForRegistration:').add(obj.countServersForRegistration);\n        res.add(', ');\n        res.add('timeoutForConnectToRegistrationServer:').add(obj.timeoutForConnectToRegistrationServer);\n        res.add(', ');\n        res.add('uid:').add(obj.uid);\n        res.add(', ');\n        res.add('alias:').add(obj.alias);\n        res.add(', ');\n        res.add('masterKey:').add(obj.masterKey);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientStateForSaveMetaBodyImpl = ClientStateForSaveMetaBodyImpl;\nclass CloudMetaBodyImpl {\n    serialize(sCtx_222, obj_223, _out_224) {\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_224, obj_223.data.length);\n        for (const el_226 of obj_223.data) {\n            _out_224.writeShort(el_226);\n        }\n    }\n    deserialize(sCtx_222, in__225) {\n        let data_227;\n        const len_229 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__225));\n        data_227 = new Array(len_229);\n        for (let idx_228 = 0; idx_228 < len_229; idx_228++) {\n            data_227[idx_228] = in__225.readShort();\n        }\n        return new aether_api_1.Cloud(data_227);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_SHORT).metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.Cloud))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_SHORT).metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('Cloud(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.CloudMetaBodyImpl = CloudMetaBodyImpl;\nclass CoderAndPortMetaBodyImpl {\n    serialize(sCtx_230, obj_231, _out_232) {\n        aether_api_1.AetherCodec.META.serialize(sCtx_230, obj_231.codec, _out_232);\n        _out_232.writeShort(obj_231.port);\n    }\n    deserialize(sCtx_230, in__233) {\n        let codec_234;\n        let port_235;\n        codec_234 = aether_api_1.AetherCodec.META.deserialize(sCtx_230, in__233);\n        port_235 = in__233.readShort();\n        return new aether_api_1.CoderAndPort(codec_234, port_235);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.AetherCodec.META.metaHashCode(obj.codec);\n        hash = 37 * hash + aether_client_1.FastMeta.META_SHORT.metaHashCode(obj.port);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.CoderAndPort))\n            return false;\n        if (!aether_api_1.AetherCodec.META.metaEquals(v1.codec, v2.codec))\n            return false;\n        if (!aether_client_1.FastMeta.META_SHORT.metaEquals(v1.port, v2.port))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('CoderAndPort(');\n        res.add('codec:').add(obj.codec);\n        res.add(', ');\n        res.add('port:').add(obj.port);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.CoderAndPortMetaBodyImpl = CoderAndPortMetaBodyImpl;\nclass FinishResultMetaBodyImpl {\n    serialize(sCtx_236, obj_237, _out_238) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_236, obj_237.alias, _out_238);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_236, obj_237.uid, _out_238);\n        aether_api_1.Cloud.META.serialize(sCtx_236, obj_237.cloud, _out_238);\n    }\n    deserialize(sCtx_236, in__239) {\n        let alias_240;\n        let uid_241;\n        let cloud_242;\n        alias_240 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_236, in__239);\n        uid_241 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_236, in__239);\n        cloud_242 = aether_api_1.Cloud.META.deserialize(sCtx_236, in__239);\n        return new aether_api_1.FinishResult(alias_240, uid_241, cloud_242);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.alias);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.uid);\n        hash = 37 * hash + aether_api_1.Cloud.META.metaHashCode(obj.cloud);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.FinishResult))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.alias, v2.alias))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.uid, v2.uid))\n            return false;\n        if (!aether_api_1.Cloud.META.metaEquals(v1.cloud, v2.cloud))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('FinishResult(');\n        res.add('alias:').add(obj.alias);\n        res.add(', ');\n        res.add('uid:').add(obj.uid);\n        res.add(', ');\n        res.add('cloud:').add(obj.cloud);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.FinishResultMetaBodyImpl = FinishResultMetaBodyImpl;\nclass HydrogenCurvePrivateMetaBodyImpl {\n    serialize(sCtx_243, obj_244, _out_245) {\n        if (obj_244.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_244.data must be 32 but was $ {\n            obj_244.data.length\n        }\n        `);\n        _out_245.write(obj_244.data);\n    }\n    deserialize(sCtx_243, in__246) {\n        let data_248;\n        const len_250 = 32;\n        const bytes_251 = in__246.readBytes(len_250);\n        data_248 = bytes_251;\n        return new aether_api_1.HydrogenCurvePrivate(data_248);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HydrogenCurvePrivate))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HydrogenCurvePrivate(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenCurvePrivateMetaBodyImpl = HydrogenCurvePrivateMetaBodyImpl;\nclass HydrogenCurvePrivateMetaImpl {\n    serialize(sCtx_252, obj_253, _out_254) {\n        const typeId = typeof obj_253.getAetherTypeId === 'function' ? obj_253.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_254.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_252, obj_253, _out_254);\n                break;\n            default: throw new Error(`Cannot serialize 'HydrogenCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_252, in__255) {\n        const typeId = in__255.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_252, in__255);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_252, in__255);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_252, in__255);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_252, in__255);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_252, in__255);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_252, in__255);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_252, in__255);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_252, in__255);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_252, in__255);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_252, in__255);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HydrogenCurvePrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HydrogenCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HydrogenCurvePrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HydrogenCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenCurvePrivateMetaImpl = HydrogenCurvePrivateMetaImpl;\nclass HydrogenCurvePublicMetaBodyImpl {\n    serialize(sCtx_256, obj_257, _out_258) {\n        if (obj_257.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_257.data must be 32 but was $ {\n            obj_257.data.length\n        }\n        `);\n        _out_258.write(obj_257.data);\n    }\n    deserialize(sCtx_256, in__259) {\n        let data_261;\n        const len_263 = 32;\n        const bytes_264 = in__259.readBytes(len_263);\n        data_261 = bytes_264;\n        return new aether_api_1.HydrogenCurvePublic(data_261);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HydrogenCurvePublic))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HydrogenCurvePublic(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenCurvePublicMetaBodyImpl = HydrogenCurvePublicMetaBodyImpl;\nclass HydrogenCurvePublicMetaImpl {\n    serialize(sCtx_265, obj_266, _out_267) {\n        const typeId = typeof obj_266.getAetherTypeId === 'function' ? obj_266.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HydrogenCurvePublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_267.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_265, obj_266, _out_267);\n                break;\n            default: throw new Error(`Cannot serialize 'HydrogenCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_265, in__268) {\n        const typeId = in__268.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_265, in__268);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_265, in__268);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_265, in__268);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_265, in__268);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_265, in__268);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_265, in__268);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_265, in__268);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_265, in__268);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_265, in__268);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_265, in__268);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HydrogenCurvePublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HydrogenCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HydrogenCurvePublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HydrogenCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenCurvePublicMetaImpl = HydrogenCurvePublicMetaImpl;\nclass HydrogenSecretBoxMetaBodyImpl {\n    serialize(sCtx_269, obj_270, _out_271) {\n        if (obj_270.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_270.data must be 32 but was $ {\n            obj_270.data.length\n        }\n        `);\n        _out_271.write(obj_270.data);\n    }\n    deserialize(sCtx_269, in__272) {\n        let data_274;\n        const len_276 = 32;\n        const bytes_277 = in__272.readBytes(len_276);\n        data_274 = bytes_277;\n        return new aether_api_1.HydrogenSecretBox(data_274);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HydrogenSecretBox))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HydrogenSecretBox(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSecretBoxMetaBodyImpl = HydrogenSecretBoxMetaBodyImpl;\nclass HydrogenSecretBoxMetaImpl {\n    serialize(sCtx_278, obj_279, _out_280) {\n        const typeId = typeof obj_279.getAetherTypeId === 'function' ? obj_279.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HydrogenSecretBox' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_280.writeByte(typeId);\n        switch (typeId) {\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_278, obj_279, _out_280);\n                break;\n            default: throw new Error(`Cannot serialize 'HydrogenSecretBox' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_278, in__281) {\n        const typeId = in__281.readUByte();\n        switch (typeId) {\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_278, in__281);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_278, in__281);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_278, in__281);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_278, in__281);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_278, in__281);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_278, in__281);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_278, in__281);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_278, in__281);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_278, in__281);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_278, in__281);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HydrogenSecretBox'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HydrogenSecretBox' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HydrogenSecretBox' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HydrogenSecretBox' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSecretBoxMetaImpl = HydrogenSecretBoxMetaImpl;\nclass HydrogenSignPrivateMetaBodyImpl {\n    serialize(sCtx_282, obj_283, _out_284) {\n        if (obj_283.data.length !== 64)\n            throw new Error(`IllegalStateException: Array length for obj_283.data must be 64 but was $ {\n            obj_283.data.length\n        }\n        `);\n        _out_284.write(obj_283.data);\n    }\n    deserialize(sCtx_282, in__285) {\n        let data_287;\n        const len_289 = 64;\n        const bytes_290 = in__285.readBytes(len_289);\n        data_287 = bytes_290;\n        return new aether_api_1.HydrogenSignPrivate(data_287);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HydrogenSignPrivate))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HydrogenSignPrivate(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSignPrivateMetaBodyImpl = HydrogenSignPrivateMetaBodyImpl;\nclass HydrogenSignPrivateMetaImpl {\n    serialize(sCtx_291, obj_292, _out_293) {\n        const typeId = typeof obj_292.getAetherTypeId === 'function' ? obj_292.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HydrogenSignPrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_293.writeByte(typeId);\n        switch (typeId) {\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_291, obj_292, _out_293);\n                break;\n            default: throw new Error(`Cannot serialize 'HydrogenSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_291, in__294) {\n        const typeId = in__294.readUByte();\n        switch (typeId) {\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_291, in__294);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_291, in__294);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_291, in__294);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_291, in__294);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_291, in__294);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_291, in__294);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_291, in__294);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_291, in__294);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_291, in__294);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_291, in__294);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HydrogenSignPrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HydrogenSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HydrogenSignPrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HydrogenSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSignPrivateMetaImpl = HydrogenSignPrivateMetaImpl;\nclass HydrogenSignPublicMetaBodyImpl {\n    serialize(sCtx_295, obj_296, _out_297) {\n        if (obj_296.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_296.data must be 32 but was $ {\n            obj_296.data.length\n        }\n        `);\n        _out_297.write(obj_296.data);\n    }\n    deserialize(sCtx_295, in__298) {\n        let data_300;\n        const len_302 = 32;\n        const bytes_303 = in__298.readBytes(len_302);\n        data_300 = bytes_303;\n        return new aether_api_1.HydrogenSignPublic(data_300);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HydrogenSignPublic))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HydrogenSignPublic(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSignPublicMetaBodyImpl = HydrogenSignPublicMetaBodyImpl;\nclass HydrogenSignPublicMetaImpl {\n    serialize(sCtx_304, obj_305, _out_306) {\n        const typeId = typeof obj_305.getAetherTypeId === 'function' ? obj_305.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HydrogenSignPublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_306.writeByte(typeId);\n        switch (typeId) {\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_304, obj_305, _out_306);\n                break;\n            default: throw new Error(`Cannot serialize 'HydrogenSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_304, in__307) {\n        const typeId = in__307.readUByte();\n        switch (typeId) {\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_304, in__307);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_304, in__307);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_304, in__307);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_304, in__307);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_304, in__307);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_304, in__307);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_304, in__307);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_304, in__307);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_304, in__307);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_304, in__307);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HydrogenSignPublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HydrogenSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HydrogenSignPublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HydrogenSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HydrogenSignPublicMetaImpl = HydrogenSignPublicMetaImpl;\nclass IPAddressAndPortsMetaBodyImpl {\n    serialize(sCtx_308, obj_309, _out_310) {\n        aether_api_1.IPAddress.META.serialize(sCtx_308, obj_309.address, _out_310);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_310, obj_309.coderAndPorts.length);\n        for (const el_312 of obj_309.coderAndPorts) {\n            aether_api_1.CoderAndPort.META.serialize(sCtx_308, el_312, _out_310);\n        }\n    }\n    deserialize(sCtx_308, in__311) {\n        let address_313;\n        let coderAndPorts_314;\n        address_313 = aether_api_1.IPAddress.META.deserialize(sCtx_308, in__311);\n        const len_316 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__311));\n        coderAndPorts_314 = new Array(len_316);\n        for (let idx_315 = 0; idx_315 < len_316; idx_315++) {\n            coderAndPorts_314[idx_315] = aether_api_1.CoderAndPort.META.deserialize(sCtx_308, in__311);\n        }\n        return new aether_api_1.IPAddressAndPorts(address_313, coderAndPorts_314);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.IPAddress.META.metaHashCode(obj.address);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.CoderAndPort.META).metaHashCode(obj.coderAndPorts);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.IPAddressAndPorts))\n            return false;\n        if (!aether_api_1.IPAddress.META.metaEquals(v1.address, v2.address))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.CoderAndPort.META).metaEquals(v1.coderAndPorts, v2.coderAndPorts))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('IPAddressAndPorts(');\n        res.add('address:').add(obj.address);\n        res.add(', ');\n        res.add('coderAndPorts:').add(obj.coderAndPorts);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressAndPortsMetaBodyImpl = IPAddressAndPortsMetaBodyImpl;\nclass IPAddressAndPortsListMetaBodyImpl {\n    serialize(sCtx_317, obj_318, _out_319) {\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_319, obj_318.addresses.length);\n        for (const el_321 of obj_318.addresses) {\n            aether_api_1.IPAddressAndPorts.META.serialize(sCtx_317, el_321, _out_319);\n        }\n    }\n    deserialize(sCtx_317, in__320) {\n        let addresses_322;\n        const len_324 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__320));\n        addresses_322 = new Array(len_324);\n        for (let idx_323 = 0; idx_323 < len_324; idx_323++) {\n            addresses_322[idx_323] = aether_api_1.IPAddressAndPorts.META.deserialize(sCtx_317, in__320);\n        }\n        return new aether_api_1.IPAddressAndPortsList(addresses_322);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.IPAddressAndPorts.META).metaHashCode(obj.addresses);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.IPAddressAndPortsList))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.IPAddressAndPorts.META).metaEquals(v1.addresses, v2.addresses))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('IPAddressAndPortsList(');\n        res.add('addresses:').add(obj.addresses);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressAndPortsListMetaBodyImpl = IPAddressAndPortsListMetaBodyImpl;\nclass IPAddressV4MetaBodyImpl {\n    serialize(sCtx_325, obj_326, _out_327) {\n        if (obj_326.data.length !== 4)\n            throw new Error(`IllegalStateException: Array length for obj_326.data must be 4 but was $ {\n            obj_326.data.length\n        }\n        `);\n        _out_327.write(obj_326.data);\n    }\n    deserialize(sCtx_325, in__328) {\n        let data_330;\n        const len_332 = 4;\n        const bytes_333 = in__328.readBytes(len_332);\n        data_330 = bytes_333;\n        return new aether_api_1.IPAddressV4(data_330);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.IPAddressV4))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('IPAddressV4(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressV4MetaBodyImpl = IPAddressV4MetaBodyImpl;\nclass IPAddressV4MetaImpl {\n    serialize(sCtx_334, obj_335, _out_336) {\n        const typeId = typeof obj_335.getAetherTypeId === 'function' ? obj_335.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'IPAddressV4' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_336.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.IPAddressV4.META_BODY.serialize(sCtx_334, obj_335, _out_336);\n                break;\n            case 2:\n                aether_api_1.IPAddressV6.META_BODY.serialize(sCtx_334, obj_335, _out_336);\n                break;\n            default: throw new Error(`Cannot serialize 'IPAddressV4' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_334, in__337) {\n        const typeId = in__337.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.IPAddressV4.META_BODY.deserialize(sCtx_334, in__337);\n            case 2: return aether_api_1.IPAddressV6.META_BODY.deserialize(sCtx_334, in__337);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'IPAddressV4'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.IPAddressV4.META_BODY.metaHashCode(obj);\n            case 2: return aether_api_1.IPAddressV6.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'IPAddressV4' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.IPAddressV4.META_BODY.metaEquals(v1, v2);\n            case 2: return aether_api_1.IPAddressV6.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'IPAddressV4' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.IPAddressV4.META_BODY.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.IPAddressV6.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'IPAddressV4' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressV4MetaImpl = IPAddressV4MetaImpl;\nclass IPAddressV6MetaBodyImpl {\n    serialize(sCtx_338, obj_339, _out_340) {\n        if (obj_339.data.length !== 6)\n            throw new Error(`IllegalStateException: Array length for obj_339.data must be 6 but was $ {\n            obj_339.data.length\n        }\n        `);\n        _out_340.write(obj_339.data);\n    }\n    deserialize(sCtx_338, in__341) {\n        let data_343;\n        const len_345 = 6;\n        const bytes_346 = in__341.readBytes(len_345);\n        data_343 = bytes_346;\n        return new aether_api_1.IPAddressV6(data_343);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.IPAddressV6))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('IPAddressV6(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressV6MetaBodyImpl = IPAddressV6MetaBodyImpl;\nclass IPAddressV6MetaImpl {\n    serialize(sCtx_347, obj_348, _out_349) {\n        const typeId = typeof obj_348.getAetherTypeId === 'function' ? obj_348.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'IPAddressV6' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_349.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.IPAddressV6.META_BODY.serialize(sCtx_347, obj_348, _out_349);\n                break;\n            case 1:\n                aether_api_1.IPAddressV4.META_BODY.serialize(sCtx_347, obj_348, _out_349);\n                break;\n            default: throw new Error(`Cannot serialize 'IPAddressV6' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_347, in__350) {\n        const typeId = in__350.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.IPAddressV6.META_BODY.deserialize(sCtx_347, in__350);\n            case 1: return aether_api_1.IPAddressV4.META_BODY.deserialize(sCtx_347, in__350);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'IPAddressV6'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.IPAddressV6.META_BODY.metaHashCode(obj);\n            case 1: return aether_api_1.IPAddressV4.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'IPAddressV6' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.IPAddressV6.META_BODY.metaEquals(v1, v2);\n            case 1: return aether_api_1.IPAddressV4.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'IPAddressV6' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.IPAddressV6.META_BODY.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.IPAddressV4.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'IPAddressV6' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.IPAddressV6MetaImpl = IPAddressV6MetaImpl;\nclass MessageMetaBodyImpl {\n    serialize(sCtx_351, obj_352, _out_353) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_351, obj_352.uid, _out_353);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_353, obj_352.data.length);\n        _out_353.write(obj_352.data);\n    }\n    deserialize(sCtx_351, in__354) {\n        let uid_356;\n        let data_357;\n        uid_356 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_351, in__354);\n        const len_359 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__354));\n        const bytes_360 = in__354.readBytes(len_359);\n        data_357 = bytes_360;\n        return new aether_api_1.Message(uid_356, data_357);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.uid);\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.Message))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.uid, v2.uid))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('Message(');\n        res.add('uid:').add(obj.uid);\n        res.add(', ');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.MessageMetaBodyImpl = MessageMetaBodyImpl;\nclass MoneyOperationMetaBodyImpl {\n    serialize(sCtx_361, obj_362, _out_363) {\n        _out_363.writeLong(obj_362.id);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_361, obj_362.from, _out_363);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_361, obj_362.to, _out_363);\n        _out_363.writeLong(obj_362.amount);\n        _out_363.writeLong(obj_362.time);\n        _out_363.writeBoolean(obj_362.credit);\n        aether_api_1.Status.META.serialize(sCtx_361, obj_362.status, _out_363);\n    }\n    deserialize(sCtx_361, in__364) {\n        let id_365;\n        let from_366;\n        let to_367;\n        let amount_368;\n        let time_369;\n        let credit_370;\n        let status_371;\n        id_365 = in__364.readLong();\n        from_366 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_361, in__364);\n        to_367 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_361, in__364);\n        amount_368 = in__364.readLong();\n        time_369 = in__364.readLong();\n        credit_370 = in__364.readBoolean();\n        status_371 = aether_api_1.Status.META.deserialize(sCtx_361, in__364);\n        return new aether_api_1.MoneyOperation(id_365, from_366, to_367, amount_368, time_369, credit_370, status_371);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.from);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.to);\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.amount);\n        hash = 37 * hash + aether_client_1.FastMeta.META_LONG.metaHashCode(obj.time);\n        hash = 37 * hash + aether_client_1.FastMeta.META_BOOLEAN.metaHashCode(obj.credit);\n        hash = 37 * hash + aether_api_1.Status.META.metaHashCode(obj.status);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.MoneyOperation))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.from, v2.from))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.to, v2.to))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.amount, v2.amount))\n            return false;\n        if (!aether_client_1.FastMeta.META_LONG.metaEquals(v1.time, v2.time))\n            return false;\n        if (!aether_client_1.FastMeta.META_BOOLEAN.metaEquals(v1.credit, v2.credit))\n            return false;\n        if (!aether_api_1.Status.META.metaEquals(v1.status, v2.status))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('MoneyOperation(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('from:').add(obj.from);\n        res.add(', ');\n        res.add('to:').add(obj.to);\n        res.add(', ');\n        res.add('amount:').add(obj.amount);\n        res.add(', ');\n        res.add('time:').add(obj.time);\n        res.add(', ');\n        res.add('credit:').add(obj.credit);\n        res.add(', ');\n        res.add('status:').add(obj.status);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.MoneyOperationMetaBodyImpl = MoneyOperationMetaBodyImpl;\nclass PairKeysAsymMetaBodyImpl {\n    serialize(sCtx_372, obj_373, _out_374) {\n        aether_api_1.Key.META.serialize(sCtx_372, obj_373.privateKey, _out_374);\n        aether_api_1.Key.META.serialize(sCtx_372, obj_373.publicKey, _out_374);\n    }\n    deserialize(sCtx_372, in__375) {\n        let privateKey_376;\n        let publicKey_377;\n        privateKey_376 = aether_api_1.Key.META.deserialize(sCtx_372, in__375);\n        publicKey_377 = aether_api_1.Key.META.deserialize(sCtx_372, in__375);\n        return new aether_api_1.PairKeysAsym(privateKey_376, publicKey_377);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.privateKey);\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.publicKey);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.PairKeysAsym))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.privateKey, v2.privateKey))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.publicKey, v2.publicKey))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('PairKeysAsym(');\n        res.add('privateKey:').add(obj.privateKey);\n        res.add(', ');\n        res.add('publicKey:').add(obj.publicKey);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysAsymMetaBodyImpl = PairKeysAsymMetaBodyImpl;\nclass PairKeysAsymMetaImpl {\n    serialize(sCtx_378, obj_379, _out_380) {\n        const typeId = typeof obj_379.getAetherTypeId === 'function' ? obj_379.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'PairKeysAsym' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_380.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.PairKeysAsym.META_BODY.serialize(sCtx_378, obj_379, _out_380);\n                break;\n            case 3:\n                aether_api_1.PairKeysSign.META_BODY.serialize(sCtx_378, obj_379, _out_380);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META_BODY.serialize(sCtx_378, obj_379, _out_380);\n                break;\n            default: throw new Error(`Cannot serialize 'PairKeysAsym' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_378, in__381) {\n        const typeId = in__381.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.deserialize(sCtx_378, in__381);\n            case 3: return aether_api_1.PairKeysSign.META_BODY.deserialize(sCtx_378, in__381);\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.deserialize(sCtx_378, in__381);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'PairKeysAsym'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.metaHashCode(obj);\n            case 3: return aether_api_1.PairKeysSign.META.metaHashCode(obj);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'PairKeysAsym' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.metaEquals(v1, v2);\n            case 3: return aether_api_1.PairKeysSign.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'PairKeysAsym' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.PairKeysAsym.META_BODY.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.PairKeysSign.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'PairKeysAsym' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysAsymMetaImpl = PairKeysAsymMetaImpl;\nclass PairKeysAsymSignedMetaBodyImpl {\n    serialize(sCtx_382, obj_383, _out_384) {\n        aether_api_1.Key.META.serialize(sCtx_382, obj_383.privateKey, _out_384);\n        aether_api_1.SignedKey.META.serialize(sCtx_382, obj_383.publicKey, _out_384);\n    }\n    deserialize(sCtx_382, in__385) {\n        let privateKey_386;\n        let publicKey_387;\n        privateKey_386 = aether_api_1.Key.META.deserialize(sCtx_382, in__385);\n        publicKey_387 = aether_api_1.SignedKey.META.deserialize(sCtx_382, in__385);\n        return new aether_api_1.PairKeysAsymSigned(privateKey_386, publicKey_387);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.privateKey);\n        hash = 37 * hash + aether_api_1.SignedKey.META.metaHashCode(obj.publicKey);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.PairKeysAsymSigned))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.privateKey, v2.privateKey))\n            return false;\n        if (!aether_api_1.SignedKey.META.metaEquals(v1.publicKey, v2.publicKey))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('PairKeysAsymSigned(');\n        res.add('privateKey:').add(obj.privateKey);\n        res.add(', ');\n        res.add('publicKey:').add(obj.publicKey);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysAsymSignedMetaBodyImpl = PairKeysAsymSignedMetaBodyImpl;\nclass PairKeysAsymSignedMetaImpl {\n    serialize(sCtx_388, obj_389, _out_390) {\n        const typeId = typeof obj_389.getAetherTypeId === 'function' ? obj_389.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'PairKeysAsymSigned' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_390.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META_BODY.serialize(sCtx_388, obj_389, _out_390);\n                break;\n            case 3:\n                aether_api_1.PairKeysSign.META_BODY.serialize(sCtx_388, obj_389, _out_390);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META_BODY.serialize(sCtx_388, obj_389, _out_390);\n                break;\n            default: throw new Error(`Cannot serialize 'PairKeysAsymSigned' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_388, in__391) {\n        const typeId = in__391.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.deserialize(sCtx_388, in__391);\n            case 3: return aether_api_1.PairKeysSign.META_BODY.deserialize(sCtx_388, in__391);\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.deserialize(sCtx_388, in__391);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'PairKeysAsymSigned'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.metaHashCode(obj);\n            case 3: return aether_api_1.PairKeysSign.META.metaHashCode(obj);\n            case 1: return aether_api_1.PairKeysAsym.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'PairKeysAsymSigned' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.metaEquals(v1, v2);\n            case 3: return aether_api_1.PairKeysSign.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.PairKeysAsym.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'PairKeysAsymSigned' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META_BODY.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.PairKeysSign.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'PairKeysAsymSigned' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysAsymSignedMetaImpl = PairKeysAsymSignedMetaImpl;\nclass PairKeysSignMetaBodyImpl {\n    serialize(sCtx_392, obj_393, _out_394) {\n        aether_api_1.Key.META.serialize(sCtx_392, obj_393.privateKey, _out_394);\n        aether_api_1.Key.META.serialize(sCtx_392, obj_393.publicKey, _out_394);\n    }\n    deserialize(sCtx_392, in__395) {\n        let privateKey_396;\n        let publicKey_397;\n        privateKey_396 = aether_api_1.Key.META.deserialize(sCtx_392, in__395);\n        publicKey_397 = aether_api_1.Key.META.deserialize(sCtx_392, in__395);\n        return new aether_api_1.PairKeysSign(privateKey_396, publicKey_397);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.privateKey);\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.publicKey);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.PairKeysSign))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.privateKey, v2.privateKey))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.publicKey, v2.publicKey))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('PairKeysSign(');\n        res.add('privateKey:').add(obj.privateKey);\n        res.add(', ');\n        res.add('publicKey:').add(obj.publicKey);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysSignMetaBodyImpl = PairKeysSignMetaBodyImpl;\nclass PairKeysSignMetaImpl {\n    serialize(sCtx_398, obj_399, _out_400) {\n        const typeId = typeof obj_399.getAetherTypeId === 'function' ? obj_399.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'PairKeysSign' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_400.writeByte(typeId);\n        switch (typeId) {\n            case 3:\n                aether_api_1.PairKeysSign.META_BODY.serialize(sCtx_398, obj_399, _out_400);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META_BODY.serialize(sCtx_398, obj_399, _out_400);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META_BODY.serialize(sCtx_398, obj_399, _out_400);\n                break;\n            default: throw new Error(`Cannot serialize 'PairKeysSign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_398, in__401) {\n        const typeId = in__401.readUByte();\n        switch (typeId) {\n            case 3: return aether_api_1.PairKeysSign.META_BODY.deserialize(sCtx_398, in__401);\n            case 1: return aether_api_1.PairKeysAsym.META_BODY.deserialize(sCtx_398, in__401);\n            case 2: return aether_api_1.PairKeysAsymSigned.META_BODY.deserialize(sCtx_398, in__401);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'PairKeysSign'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3: return aether_api_1.PairKeysSign.META_BODY.metaHashCode(obj);\n            case 1: return aether_api_1.PairKeysAsym.META.metaHashCode(obj);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'PairKeysSign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 3: return aether_api_1.PairKeysSign.META_BODY.metaEquals(v1, v2);\n            case 1: return aether_api_1.PairKeysAsym.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.PairKeysAsymSigned.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'PairKeysSign' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 3:\n                aether_api_1.PairKeysSign.META_BODY.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.PairKeysAsym.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.PairKeysAsymSigned.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'PairKeysSign' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PairKeysSignMetaImpl = PairKeysSignMetaImpl;\nclass ServerDescriptorMetaBodyImpl {\n    serialize(sCtx_402, obj_403, _out_404) {\n        _out_404.writeShort(obj_403.id);\n        aether_api_1.IPAddressAndPortsList.META.serialize(sCtx_402, obj_403.ipAddress, _out_404);\n    }\n    deserialize(sCtx_402, in__405) {\n        let id_406;\n        let ipAddress_407;\n        id_406 = in__405.readShort();\n        ipAddress_407 = aether_api_1.IPAddressAndPortsList.META.deserialize(sCtx_402, in__405);\n        return new aether_api_1.ServerDescriptor(id_406, ipAddress_407);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_SHORT.metaHashCode(obj.id);\n        hash = 37 * hash + aether_api_1.IPAddressAndPortsList.META.metaHashCode(obj.ipAddress);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.ServerDescriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_SHORT.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_api_1.IPAddressAndPortsList.META.metaEquals(v1.ipAddress, v2.ipAddress))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ServerDescriptor(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('ipAddress:').add(obj.ipAddress);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ServerDescriptorMetaBodyImpl = ServerDescriptorMetaBodyImpl;\nclass SignAE_ED25519MetaBodyImpl {\n    serialize(sCtx_408, obj_409, _out_410) {\n        if (obj_409.data.length !== 64)\n            throw new Error(`IllegalStateException: Array length for obj_409.data must be 64 but was $ {\n            obj_409.data.length\n        }\n        `);\n        _out_410.write(obj_409.data);\n    }\n    deserialize(sCtx_408, in__411) {\n        let data_413;\n        const len_415 = 64;\n        const bytes_416 = in__411.readBytes(len_415);\n        data_413 = bytes_416;\n        return new aether_api_1.SignAE_ED25519(data_413);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SignAE_ED25519))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SignAE_ED25519(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignAE_ED25519MetaBodyImpl = SignAE_ED25519MetaBodyImpl;\nclass SignAE_ED25519MetaImpl {\n    serialize(sCtx_417, obj_418, _out_419) {\n        const typeId = typeof obj_418.getAetherTypeId === 'function' ? obj_418.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SignAE_ED25519' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_419.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.SignAE_ED25519.META_BODY.serialize(sCtx_417, obj_418, _out_419);\n                break;\n            case 2:\n                aether_api_1.SignHYDROGEN.META_BODY.serialize(sCtx_417, obj_418, _out_419);\n                break;\n            default: throw new Error(`Cannot serialize 'SignAE_ED25519' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_417, in__420) {\n        const typeId = in__420.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.SignAE_ED25519.META_BODY.deserialize(sCtx_417, in__420);\n            case 2: return aether_api_1.SignHYDROGEN.META_BODY.deserialize(sCtx_417, in__420);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SignAE_ED25519'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.SignAE_ED25519.META_BODY.metaHashCode(obj);\n            case 2: return aether_api_1.SignHYDROGEN.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SignAE_ED25519' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.SignAE_ED25519.META_BODY.metaEquals(v1, v2);\n            case 2: return aether_api_1.SignHYDROGEN.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SignAE_ED25519' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.SignAE_ED25519.META_BODY.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.SignHYDROGEN.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SignAE_ED25519' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignAE_ED25519MetaImpl = SignAE_ED25519MetaImpl;\nclass SignedKeyMetaBodyImpl {\n    serialize(sCtx_421, obj_422, _out_423) {\n        aether_api_1.Key.META.serialize(sCtx_421, obj_422.key, _out_423);\n        aether_api_1.Sign.META.serialize(sCtx_421, obj_422.sign, _out_423);\n    }\n    deserialize(sCtx_421, in__424) {\n        let _key_425;\n        let sign_426;\n        _key_425 = aether_api_1.Key.META.deserialize(sCtx_421, in__424);\n        sign_426 = aether_api_1.Sign.META.deserialize(sCtx_421, in__424);\n        return new aether_api_1.SignedKey(_key_425, sign_426);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_api_1.Key.META.metaHashCode(obj.key);\n        hash = 37 * hash + aether_api_1.Sign.META.metaHashCode(obj.sign);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SignedKey))\n            return false;\n        if (!aether_api_1.Key.META.metaEquals(v1.key, v2.key))\n            return false;\n        if (!aether_api_1.Sign.META.metaEquals(v1.sign, v2.sign))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SignedKey(');\n        res.add('key:').add(obj.key);\n        res.add(', ');\n        res.add('sign:').add(obj.sign);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignedKeyMetaBodyImpl = SignedKeyMetaBodyImpl;\nclass SignHYDROGENMetaBodyImpl {\n    serialize(sCtx_427, obj_428, _out_429) {\n        if (obj_428.data.length !== 64)\n            throw new Error(`IllegalStateException: Array length for obj_428.data must be 64 but was $ {\n            obj_428.data.length\n        }\n        `);\n        _out_429.write(obj_428.data);\n    }\n    deserialize(sCtx_427, in__430) {\n        let data_432;\n        const len_434 = 64;\n        const bytes_435 = in__430.readBytes(len_434);\n        data_432 = bytes_435;\n        return new aether_api_1.SignHYDROGEN(data_432);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SignHYDROGEN))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SignHYDROGEN(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignHYDROGENMetaBodyImpl = SignHYDROGENMetaBodyImpl;\nclass SignHYDROGENMetaImpl {\n    serialize(sCtx_436, obj_437, _out_438) {\n        const typeId = typeof obj_437.getAetherTypeId === 'function' ? obj_437.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SignHYDROGEN' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_438.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.SignHYDROGEN.META_BODY.serialize(sCtx_436, obj_437, _out_438);\n                break;\n            case 1:\n                aether_api_1.SignAE_ED25519.META_BODY.serialize(sCtx_436, obj_437, _out_438);\n                break;\n            default: throw new Error(`Cannot serialize 'SignHYDROGEN' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_436, in__439) {\n        const typeId = in__439.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.SignHYDROGEN.META_BODY.deserialize(sCtx_436, in__439);\n            case 1: return aether_api_1.SignAE_ED25519.META_BODY.deserialize(sCtx_436, in__439);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SignHYDROGEN'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.SignHYDROGEN.META_BODY.metaHashCode(obj);\n            case 1: return aether_api_1.SignAE_ED25519.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SignHYDROGEN' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.SignHYDROGEN.META_BODY.metaEquals(v1, v2);\n            case 1: return aether_api_1.SignAE_ED25519.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SignHYDROGEN' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.SignHYDROGEN.META_BODY.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.SignAE_ED25519.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SignHYDROGEN' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SignHYDROGENMetaImpl = SignHYDROGENMetaImpl;\nclass SodiumChacha20Poly1305MetaBodyImpl {\n    serialize(sCtx_440, obj_441, _out_442) {\n        if (obj_441.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_441.data must be 32 but was $ {\n            obj_441.data.length\n        }\n        `);\n        _out_442.write(obj_441.data);\n    }\n    deserialize(sCtx_440, in__443) {\n        let data_445;\n        const len_447 = 32;\n        const bytes_448 = in__443.readBytes(len_447);\n        data_445 = bytes_448;\n        return new aether_api_1.SodiumChacha20Poly1305(data_445);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SodiumChacha20Poly1305))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SodiumChacha20Poly1305(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumChacha20Poly1305MetaBodyImpl = SodiumChacha20Poly1305MetaBodyImpl;\nclass SodiumChacha20Poly1305MetaImpl {\n    serialize(sCtx_449, obj_450, _out_451) {\n        const typeId = typeof obj_450.getAetherTypeId === 'function' ? obj_450.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_451.writeByte(typeId);\n        switch (typeId) {\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_449, obj_450, _out_451);\n                break;\n            default: throw new Error(`Cannot serialize 'SodiumChacha20Poly1305' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_449, in__452) {\n        const typeId = in__452.readUByte();\n        switch (typeId) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_449, in__452);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_449, in__452);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_449, in__452);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_449, in__452);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_449, in__452);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_449, in__452);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_449, in__452);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_449, in__452);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_449, in__452);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_449, in__452);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SodiumChacha20Poly1305'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SodiumChacha20Poly1305' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SodiumChacha20Poly1305' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SodiumChacha20Poly1305' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumChacha20Poly1305MetaImpl = SodiumChacha20Poly1305MetaImpl;\nclass SodiumCurvePrivateMetaBodyImpl {\n    serialize(sCtx_453, obj_454, _out_455) {\n        if (obj_454.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_454.data must be 32 but was $ {\n            obj_454.data.length\n        }\n        `);\n        _out_455.write(obj_454.data);\n    }\n    deserialize(sCtx_453, in__456) {\n        let data_458;\n        const len_460 = 32;\n        const bytes_461 = in__456.readBytes(len_460);\n        data_458 = bytes_461;\n        return new aether_api_1.SodiumCurvePrivate(data_458);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SodiumCurvePrivate))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SodiumCurvePrivate(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumCurvePrivateMetaBodyImpl = SodiumCurvePrivateMetaBodyImpl;\nclass SodiumCurvePrivateMetaImpl {\n    serialize(sCtx_462, obj_463, _out_464) {\n        const typeId = typeof obj_463.getAetherTypeId === 'function' ? obj_463.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SodiumCurvePrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_464.writeByte(typeId);\n        switch (typeId) {\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_462, obj_463, _out_464);\n                break;\n            default: throw new Error(`Cannot serialize 'SodiumCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_462, in__465) {\n        const typeId = in__465.readUByte();\n        switch (typeId) {\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_462, in__465);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_462, in__465);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_462, in__465);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_462, in__465);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_462, in__465);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_462, in__465);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_462, in__465);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_462, in__465);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_462, in__465);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_462, in__465);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SodiumCurvePrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SodiumCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SodiumCurvePrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SodiumCurvePrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumCurvePrivateMetaImpl = SodiumCurvePrivateMetaImpl;\nclass SodiumCurvePublicMetaBodyImpl {\n    serialize(sCtx_466, obj_467, _out_468) {\n        if (obj_467.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_467.data must be 32 but was $ {\n            obj_467.data.length\n        }\n        `);\n        _out_468.write(obj_467.data);\n    }\n    deserialize(sCtx_466, in__469) {\n        let data_471;\n        const len_473 = 32;\n        const bytes_474 = in__469.readBytes(len_473);\n        data_471 = bytes_474;\n        return new aether_api_1.SodiumCurvePublic(data_471);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SodiumCurvePublic))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SodiumCurvePublic(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumCurvePublicMetaBodyImpl = SodiumCurvePublicMetaBodyImpl;\nclass SodiumCurvePublicMetaImpl {\n    serialize(sCtx_475, obj_476, _out_477) {\n        const typeId = typeof obj_476.getAetherTypeId === 'function' ? obj_476.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SodiumCurvePublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_477.writeByte(typeId);\n        switch (typeId) {\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_475, obj_476, _out_477);\n                break;\n            default: throw new Error(`Cannot serialize 'SodiumCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_475, in__478) {\n        const typeId = in__478.readUByte();\n        switch (typeId) {\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_475, in__478);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_475, in__478);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_475, in__478);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_475, in__478);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_475, in__478);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_475, in__478);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_475, in__478);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_475, in__478);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_475, in__478);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_475, in__478);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SodiumCurvePublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SodiumCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SodiumCurvePublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SodiumCurvePublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumCurvePublicMetaImpl = SodiumCurvePublicMetaImpl;\nclass SodiumSignPrivateMetaBodyImpl {\n    serialize(sCtx_479, obj_480, _out_481) {\n        if (obj_480.data.length !== 64)\n            throw new Error(`IllegalStateException: Array length for obj_480.data must be 64 but was $ {\n            obj_480.data.length\n        }\n        `);\n        _out_481.write(obj_480.data);\n    }\n    deserialize(sCtx_479, in__482) {\n        let data_484;\n        const len_486 = 64;\n        const bytes_487 = in__482.readBytes(len_486);\n        data_484 = bytes_487;\n        return new aether_api_1.SodiumSignPrivate(data_484);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SodiumSignPrivate))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SodiumSignPrivate(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumSignPrivateMetaBodyImpl = SodiumSignPrivateMetaBodyImpl;\nclass SodiumSignPrivateMetaImpl {\n    serialize(sCtx_488, obj_489, _out_490) {\n        const typeId = typeof obj_489.getAetherTypeId === 'function' ? obj_489.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SodiumSignPrivate' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_490.writeByte(typeId);\n        switch (typeId) {\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_488, obj_489, _out_490);\n                break;\n            default: throw new Error(`Cannot serialize 'SodiumSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_488, in__491) {\n        const typeId = in__491.readUByte();\n        switch (typeId) {\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_488, in__491);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_488, in__491);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_488, in__491);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_488, in__491);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_488, in__491);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_488, in__491);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_488, in__491);\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_488, in__491);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_488, in__491);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_488, in__491);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SodiumSignPrivate'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SodiumSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 10: return aether_api_1.SodiumSignPublic.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SodiumSignPrivate' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 10:\n                aether_api_1.SodiumSignPublic.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SodiumSignPrivate' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumSignPrivateMetaImpl = SodiumSignPrivateMetaImpl;\nclass SodiumSignPublicMetaBodyImpl {\n    serialize(sCtx_492, obj_493, _out_494) {\n        if (obj_493.data.length !== 32)\n            throw new Error(`IllegalStateException: Array length for obj_493.data must be 32 but was $ {\n            obj_493.data.length\n        }\n        `);\n        _out_494.write(obj_493.data);\n    }\n    deserialize(sCtx_492, in__495) {\n        let data_497;\n        const len_499 = 32;\n        const bytes_500 = in__495.readBytes(len_499);\n        data_497 = bytes_500;\n        return new aether_api_1.SodiumSignPublic(data_497);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.data);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.SodiumSignPublic))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.data, v2.data))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SodiumSignPublic(');\n        res.add('data:').add(obj.data);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumSignPublicMetaBodyImpl = SodiumSignPublicMetaBodyImpl;\nclass SodiumSignPublicMetaImpl {\n    serialize(sCtx_501, obj_502, _out_503) {\n        const typeId = typeof obj_502.getAetherTypeId === 'function' ? obj_502.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'SodiumSignPublic' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_503.writeByte(typeId);\n        switch (typeId) {\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META_BODY.serialize(sCtx_501, obj_502, _out_503);\n                break;\n            default: throw new Error(`Cannot serialize 'SodiumSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_501, in__504) {\n        const typeId = in__504.readUByte();\n        switch (typeId) {\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.deserialize(sCtx_501, in__504);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META_BODY.deserialize(sCtx_501, in__504);\n            case 3: return aether_api_1.HydrogenSecretBox.META_BODY.deserialize(sCtx_501, in__504);\n            case 2: return aether_api_1.HydrogenCurvePublic.META_BODY.deserialize(sCtx_501, in__504);\n            case 8: return aether_api_1.SodiumCurvePublic.META_BODY.deserialize(sCtx_501, in__504);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META_BODY.deserialize(sCtx_501, in__504);\n            case 7: return aether_api_1.SodiumCurvePrivate.META_BODY.deserialize(sCtx_501, in__504);\n            case 5: return aether_api_1.HydrogenSignPublic.META_BODY.deserialize(sCtx_501, in__504);\n            case 9: return aether_api_1.SodiumSignPrivate.META_BODY.deserialize(sCtx_501, in__504);\n            case 4: return aether_api_1.HydrogenSignPrivate.META_BODY.deserialize(sCtx_501, in__504);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'SodiumSignPublic'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.metaHashCode(obj);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaHashCode(obj);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaHashCode(obj);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaHashCode(obj);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaHashCode(obj);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaHashCode(obj);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaHashCode(obj);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaHashCode(obj);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaHashCode(obj);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'SodiumSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 10: return aether_api_1.SodiumSignPublic.META_BODY.metaEquals(v1, v2);\n            case 6: return aether_api_1.SodiumChacha20Poly1305.META.metaEquals(v1, v2);\n            case 3: return aether_api_1.HydrogenSecretBox.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HydrogenCurvePublic.META.metaEquals(v1, v2);\n            case 8: return aether_api_1.SodiumCurvePublic.META.metaEquals(v1, v2);\n            case 1: return aether_api_1.HydrogenCurvePrivate.META.metaEquals(v1, v2);\n            case 7: return aether_api_1.SodiumCurvePrivate.META.metaEquals(v1, v2);\n            case 5: return aether_api_1.HydrogenSignPublic.META.metaEquals(v1, v2);\n            case 9: return aether_api_1.SodiumSignPrivate.META.metaEquals(v1, v2);\n            case 4: return aether_api_1.HydrogenSignPrivate.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'SodiumSignPublic' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 10:\n                aether_api_1.SodiumSignPublic.META_BODY.metaToString(obj, res);\n                break;\n            case 6:\n                aether_api_1.SodiumChacha20Poly1305.META.metaToString(obj, res);\n                break;\n            case 3:\n                aether_api_1.HydrogenSecretBox.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HydrogenCurvePublic.META.metaToString(obj, res);\n                break;\n            case 8:\n                aether_api_1.SodiumCurvePublic.META.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HydrogenCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 7:\n                aether_api_1.SodiumCurvePrivate.META.metaToString(obj, res);\n                break;\n            case 5:\n                aether_api_1.HydrogenSignPublic.META.metaToString(obj, res);\n                break;\n            case 9:\n                aether_api_1.SodiumSignPrivate.META.metaToString(obj, res);\n                break;\n            case 4:\n                aether_api_1.HydrogenSignPrivate.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'SodiumSignPublic' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SodiumSignPublicMetaImpl = SodiumSignPublicMetaImpl;\nclass TelemetryCPPMetaBodyImpl {\n    serialize(sCtx_505, obj_506, _out_507) {\n        _out_507.writeInt(obj_506.utm_id);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_507, obj_506.blob.length);\n        _out_507.write(obj_506.blob);\n        const stringBytes_510 = new TextEncoder().encode(obj_506.lib_version);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_507, stringBytes_510.length);\n        _out_507.write(stringBytes_510);\n        const stringBytes_512 = new TextEncoder().encode(obj_506.os);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_507, stringBytes_512.length);\n        _out_507.write(stringBytes_512);\n        const stringBytes_514 = new TextEncoder().encode(obj_506.compiler);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_507, stringBytes_514.length);\n        _out_507.write(stringBytes_514);\n    }\n    deserialize(sCtx_505, in__508) {\n        let utm_id_516;\n        let blob_517;\n        let lib_version_518;\n        let os_519;\n        let compiler_520;\n        utm_id_516 = in__508.readInt();\n        const len_522 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__508));\n        const bytes_523 = in__508.readBytes(len_522);\n        blob_517 = bytes_523;\n        let stringBytes_524;\n        const len_526 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__508));\n        const bytes_527 = in__508.readBytes(len_526);\n        stringBytes_524 = bytes_527;\n        lib_version_518 = new TextDecoder('utf-8').decode(stringBytes_524);\n        let stringBytes_528;\n        const len_530 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__508));\n        const bytes_531 = in__508.readBytes(len_530);\n        stringBytes_528 = bytes_531;\n        os_519 = new TextDecoder('utf-8').decode(stringBytes_528);\n        let stringBytes_532;\n        const len_534 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__508));\n        const bytes_535 = in__508.readBytes(len_534);\n        stringBytes_532 = bytes_535;\n        compiler_520 = new TextDecoder('utf-8').decode(stringBytes_532);\n        return new aether_api_1.TelemetryCPP(utm_id_516, blob_517, lib_version_518, os_519, compiler_520);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.utm_id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj.blob);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.lib_version);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.os);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.compiler);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.TelemetryCPP))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.utm_id, v2.utm_id))\n            return false;\n        if (!aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1.blob, v2.blob))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.lib_version, v2.lib_version))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.os, v2.os))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.compiler, v2.compiler))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('TelemetryCPP(');\n        res.add('utm_id:').add(obj.utm_id);\n        res.add(', ');\n        res.add('blob:').add(obj.blob);\n        res.add(', ');\n        res.add('lib_version:').add(obj.lib_version);\n        res.add(', ');\n        res.add('os:').add(obj.os);\n        res.add(', ');\n        res.add('compiler:').add(obj.compiler);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.TelemetryCPPMetaBodyImpl = TelemetryCPPMetaBodyImpl;\nclass TelemetryCPPMetaImpl {\n    serialize(sCtx_536, obj_537, _out_538) {\n        const typeId = typeof obj_537.getAetherTypeId === 'function' ? obj_537.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'TelemetryCPP' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_538.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.TelemetryCPP.META_BODY.serialize(sCtx_536, obj_537, _out_538);\n                break;\n            default: throw new Error(`Cannot serialize 'TelemetryCPP' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_536, in__539) {\n        const typeId = in__539.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.TelemetryCPP.META_BODY.deserialize(sCtx_536, in__539);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'TelemetryCPP'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.TelemetryCPP.META_BODY.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'TelemetryCPP' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.TelemetryCPP.META_BODY.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'TelemetryCPP' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.TelemetryCPP.META_BODY.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'TelemetryCPP' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.TelemetryCPPMetaImpl = TelemetryCPPMetaImpl;\nclass UUIDAndCloudMetaBodyImpl {\n    serialize(sCtx_540, obj_541, _out_542) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_540, obj_541.uid, _out_542);\n        aether_api_1.Cloud.META.serialize(sCtx_540, obj_541.cloud, _out_542);\n    }\n    deserialize(sCtx_540, in__543) {\n        let uid_544;\n        let cloud_545;\n        uid_544 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_540, in__543);\n        cloud_545 = aether_api_1.Cloud.META.deserialize(sCtx_540, in__543);\n        return new aether_api_1.UUIDAndCloud(uid_544, cloud_545);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.uid);\n        hash = 37 * hash + aether_api_1.Cloud.META.metaHashCode(obj.cloud);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.UUIDAndCloud))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.uid, v2.uid))\n            return false;\n        if (!aether_api_1.Cloud.META.metaEquals(v1.cloud, v2.cloud))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('UUIDAndCloud(');\n        res.add('uid:').add(obj.uid);\n        res.add(', ');\n        res.add('cloud:').add(obj.cloud);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.UUIDAndCloudMetaBodyImpl = UUIDAndCloudMetaBodyImpl;\nclass WorkProofBCryptMetaBodyImpl {\n    serialize(sCtx_546, obj_547, _out_548) {\n        _out_548.writeByte(obj_547.costBCrypt);\n        _out_548.writeByte(obj_547.poolSize);\n        _out_548.writeInt(obj_547.maxHashVal);\n    }\n    deserialize(sCtx_546, in__549) {\n        let costBCrypt_550;\n        let poolSize_551;\n        let maxHashVal_552;\n        costBCrypt_550 = in__549.readByte();\n        poolSize_551 = in__549.readByte();\n        maxHashVal_552 = in__549.readInt();\n        return new aether_api_1.WorkProofBCrypt(costBCrypt_550, poolSize_551, maxHashVal_552);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_BYTE.metaHashCode(obj.costBCrypt);\n        hash = 37 * hash + aether_client_1.FastMeta.META_BYTE.metaHashCode(obj.poolSize);\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.maxHashVal);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.WorkProofBCrypt))\n            return false;\n        if (!aether_client_1.FastMeta.META_BYTE.metaEquals(v1.costBCrypt, v2.costBCrypt))\n            return false;\n        if (!aether_client_1.FastMeta.META_BYTE.metaEquals(v1.poolSize, v2.poolSize))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.maxHashVal, v2.maxHashVal))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('WorkProofBCrypt(');\n        res.add('costBCrypt:').add(obj.costBCrypt);\n        res.add(', ');\n        res.add('poolSize:').add(obj.poolSize);\n        res.add(', ');\n        res.add('maxHashVal:').add(obj.maxHashVal);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.WorkProofBCryptMetaBodyImpl = WorkProofBCryptMetaBodyImpl;\nclass WorkProofBCryptMetaImpl {\n    serialize(sCtx_553, obj_554, _out_555) {\n        const typeId = typeof obj_554.getAetherTypeId === 'function' ? obj_554.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'WorkProofBCrypt' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_555.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.WorkProofBCrypt.META_BODY.serialize(sCtx_553, obj_554, _out_555);\n                break;\n            default: throw new Error(`Cannot serialize 'WorkProofBCrypt' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_553, in__556) {\n        const typeId = in__556.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.WorkProofBCrypt.META_BODY.deserialize(sCtx_553, in__556);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'WorkProofBCrypt'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.WorkProofBCrypt.META_BODY.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'WorkProofBCrypt' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.WorkProofBCrypt.META_BODY.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'WorkProofBCrypt' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.WorkProofBCrypt.META_BODY.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'WorkProofBCrypt' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.WorkProofBCryptMetaImpl = WorkProofBCryptMetaImpl;\nclass WorkProofDTOMetaBodyImpl {\n    serialize(sCtx_557, obj_558, _out_559) {\n        const stringBytes_561 = new TextEncoder().encode(obj_558.salt);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_559, stringBytes_561.length);\n        _out_559.write(stringBytes_561);\n        const stringBytes_563 = new TextEncoder().encode(obj_558.suffix);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_559, stringBytes_563.length);\n        _out_559.write(stringBytes_563);\n        _out_559.writeByte(obj_558.poolSize);\n        _out_559.writeInt(obj_558.maxHashVal);\n        aether_api_1.SignedKey.META.serialize(sCtx_557, obj_558.globalKey, _out_559);\n    }\n    deserialize(sCtx_557, in__560) {\n        let salt_565;\n        let suffix_566;\n        let poolSize_567;\n        let maxHashVal_568;\n        let globalKey_569;\n        let stringBytes_570;\n        const len_572 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__560));\n        const bytes_573 = in__560.readBytes(len_572);\n        stringBytes_570 = bytes_573;\n        salt_565 = new TextDecoder('utf-8').decode(stringBytes_570);\n        let stringBytes_574;\n        const len_576 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__560));\n        const bytes_577 = in__560.readBytes(len_576);\n        stringBytes_574 = bytes_577;\n        suffix_566 = new TextDecoder('utf-8').decode(stringBytes_574);\n        poolSize_567 = in__560.readByte();\n        maxHashVal_568 = in__560.readInt();\n        globalKey_569 = aether_api_1.SignedKey.META.deserialize(sCtx_557, in__560);\n        return new aether_api_1.WorkProofDTO(salt_565, suffix_566, poolSize_567, maxHashVal_568, globalKey_569);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.salt);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.suffix);\n        hash = 37 * hash + aether_client_1.FastMeta.META_BYTE.metaHashCode(obj.poolSize);\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.maxHashVal);\n        hash = 37 * hash + aether_api_1.SignedKey.META.metaHashCode(obj.globalKey);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.WorkProofDTO))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.salt, v2.salt))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.suffix, v2.suffix))\n            return false;\n        if (!aether_client_1.FastMeta.META_BYTE.metaEquals(v1.poolSize, v2.poolSize))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.maxHashVal, v2.maxHashVal))\n            return false;\n        if (!aether_api_1.SignedKey.META.metaEquals(v1.globalKey, v2.globalKey))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('WorkProofDTO(');\n        res.add('salt:').add(obj.salt);\n        res.add(', ');\n        res.add('suffix:').add(obj.suffix);\n        res.add(', ');\n        res.add('poolSize:').add(obj.poolSize);\n        res.add(', ');\n        res.add('maxHashVal:').add(obj.maxHashVal);\n        res.add(', ');\n        res.add('globalKey:').add(obj.globalKey);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.WorkProofDTOMetaBodyImpl = WorkProofDTOMetaBodyImpl;\nclass ClientApiRegSafeStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.ClientApiRegSafeStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.ClientApiRegSafeStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ClientApiRegSafeStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientApiRegSafeStreamMetaImpl = ClientApiRegSafeStreamMetaImpl;\nclass ClientApiStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.ClientApiStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.ClientApiStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ClientApiStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientApiStreamMetaImpl = ClientApiStreamMetaImpl;\nclass ClientInteractionClientStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.ClientInteractionClientStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.ClientInteractionClientStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ClientInteractionClientStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientInteractionClientStreamMetaImpl = ClientInteractionClientStreamMetaImpl;\nclass GlobalApiMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.GlobalApi(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.GlobalApi) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('GlobalApi(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.GlobalApiMetaImpl = GlobalApiMetaImpl;\nclass GlobalRegClientApiStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.GlobalRegClientApiStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.GlobalRegClientApiStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('GlobalRegClientApiStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.GlobalRegClientApiStreamMetaImpl = GlobalRegClientApiStreamMetaImpl;\nclass LoginClientStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.LoginClientStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.LoginClientStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('LoginClientStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.LoginClientStreamMetaImpl = LoginClientStreamMetaImpl;\nclass LoginStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.LoginStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.LoginStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('LoginStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.LoginStreamMetaImpl = LoginStreamMetaImpl;\nclass ServerRegistrationApiStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.ServerRegistrationApiStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj?.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1?.data, (v2 instanceof aether_api_1.ServerRegistrationApiStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('ServerRegistrationApiStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ServerRegistrationApiStreamMetaImpl = ServerRegistrationApiStreamMetaImpl;\nclass ClientApiUnsafeMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let backId_579;\n                    let data_580;\n                    backId_579 = dataIn.readByte();\n                    data_580 = aether_api_1.LoginClientStream.META.deserialize(ctx, dataIn);\n                    const argsNames_581 = [\"backId\", \"data\"];\n                    const argsValues_582 = [backId_579, data_580];\n                    ctx.invokeLocalMethodBefore(\"sendSafeApiDataMulti\", argsNames_581, argsValues_582);\n                    localApi.sendSafeApiDataMulti(backId_579, data_580);\n                    ctx.invokeLocalMethodAfter(\"sendSafeApiDataMulti\", null, argsNames_581, argsValues_582);\n                    break;\n                }\n                case 4: {\n                    let data_584;\n                    data_584 = aether_api_1.LoginClientStream.META.deserialize(ctx, dataIn);\n                    const argsNames_585 = [\"data\"];\n                    const argsValues_586 = [data_584];\n                    ctx.invokeLocalMethodBefore(\"sendSafeApiData\", argsNames_585, argsValues_586);\n                    localApi.sendSafeApiData(data_584);\n                    ctx.invokeLocalMethodAfter(\"sendSafeApiData\", null, argsNames_585, argsValues_586);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_587) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_587.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_587, sendSafeApiDataMulti: (backId, data) => {\n                const dataOut_589 = new aether_client_1.DataInOut();\n                dataOut_589.writeByte(3);\n                const argsNames_591 = [\"backId\", \"data\"];\n                const argsValues_592 = [backId, data];\n                sCtx_587.invokeRemoteMethodAfter(\"sendSafeApiDataMulti\", null, argsNames_591, argsValues_592);\n                dataOut_589.writeByte(backId);\n                aether_api_1.LoginClientStream.META.serialize(sCtx_587, data, dataOut_589);\n                sCtx_587.sendToRemote(dataOut_589.toArray());\n            },\n            sendSafeApiData: (data) => {\n                const dataOut_594 = new aether_client_1.DataInOut();\n                dataOut_594.writeByte(4);\n                const argsNames_596 = [\"data\"];\n                const argsValues_597 = [data];\n                sCtx_587.invokeRemoteMethodAfter(\"sendSafeApiData\", null, argsNames_596, argsValues_597);\n                aether_api_1.LoginClientStream.META.serialize(sCtx_587, data, dataOut_594);\n                sCtx_587.sendToRemote(dataOut_594.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ClientApiUnsafeMetaImpl = ClientApiUnsafeMetaImpl;\nclass ClientApiSafeMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let uid_599;\n                    uid_599 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_600 = [\"uid\"];\n                    const argsValues_601 = [uid_599];\n                    ctx.invokeLocalMethodBefore(\"changeParent\", argsNames_600, argsValues_601);\n                    localApi.changeParent(uid_599);\n                    ctx.invokeLocalMethodAfter(\"changeParent\", null, argsNames_600, argsValues_601);\n                    break;\n                }\n                case 4: {\n                    let alias_603;\n                    alias_603 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_604 = [\"alias\"];\n                    const argsValues_605 = [alias_603];\n                    ctx.invokeLocalMethodBefore(\"changeAlias\", argsNames_604, argsValues_605);\n                    localApi.changeAlias(alias_603);\n                    ctx.invokeLocalMethodAfter(\"changeAlias\", null, argsNames_604, argsValues_605);\n                    break;\n                }\n                case 5: {\n                    let uid_607;\n                    uid_607 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_608 = [\"uid\"];\n                    const argsValues_609 = [uid_607];\n                    ctx.invokeLocalMethodBefore(\"newChild\", argsNames_608, argsValues_609);\n                    localApi.newChild(uid_607);\n                    ctx.invokeLocalMethodAfter(\"newChild\", null, argsNames_608, argsValues_609);\n                    break;\n                }\n                case 6: {\n                    let msg_611;\n                    const len_613 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    msg_611 = new Array(len_613);\n                    for (let idx_612 = 0; idx_612 < len_613; idx_612++) {\n                        msg_611[idx_612] = aether_api_1.Message.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_614 = [\"msg\"];\n                    const argsValues_615 = [msg_611];\n                    ctx.invokeLocalMethodBefore(\"sendMessages\", argsNames_614, argsValues_615);\n                    localApi.sendMessages(msg_611);\n                    ctx.invokeLocalMethodAfter(\"sendMessages\", null, argsNames_614, argsValues_615);\n                    break;\n                }\n                case 7: {\n                    let serverDescriptor_617;\n                    serverDescriptor_617 = aether_api_1.ServerDescriptor.META.deserialize(ctx, dataIn);\n                    const argsNames_618 = [\"serverDescriptor\"];\n                    const argsValues_619 = [serverDescriptor_617];\n                    ctx.invokeLocalMethodBefore(\"sendServerDescriptor\", argsNames_618, argsValues_619);\n                    localApi.sendServerDescriptor(serverDescriptor_617);\n                    ctx.invokeLocalMethodAfter(\"sendServerDescriptor\", null, argsNames_618, argsValues_619);\n                    break;\n                }\n                case 8: {\n                    let serverDescriptors_621;\n                    const len_623 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    serverDescriptors_621 = new Array(len_623);\n                    for (let idx_622 = 0; idx_622 < len_623; idx_622++) {\n                        serverDescriptors_621[idx_622] = aether_api_1.ServerDescriptor.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_624 = [\"serverDescriptors\"];\n                    const argsValues_625 = [serverDescriptors_621];\n                    ctx.invokeLocalMethodBefore(\"sendServerDescriptors\", argsNames_624, argsValues_625);\n                    localApi.sendServerDescriptors(serverDescriptors_621);\n                    ctx.invokeLocalMethodAfter(\"sendServerDescriptors\", null, argsNames_624, argsValues_625);\n                    break;\n                }\n                case 9: {\n                    let uid_627;\n                    let cloud_628;\n                    uid_627 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    cloud_628 = aether_api_1.Cloud.META.deserialize(ctx, dataIn);\n                    const argsNames_629 = [\"uid\", \"cloud\"];\n                    const argsValues_630 = [uid_627, cloud_628];\n                    ctx.invokeLocalMethodBefore(\"sendCloud\", argsNames_629, argsValues_630);\n                    localApi.sendCloud(uid_627, cloud_628);\n                    ctx.invokeLocalMethodAfter(\"sendCloud\", null, argsNames_629, argsValues_630);\n                    break;\n                }\n                case 10: {\n                    let clouds_632;\n                    const len_634 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    clouds_632 = new Array(len_634);\n                    for (let idx_633 = 0; idx_633 < len_634; idx_633++) {\n                        clouds_632[idx_633] = aether_api_1.UUIDAndCloud.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_635 = [\"clouds\"];\n                    const argsValues_636 = [clouds_632];\n                    ctx.invokeLocalMethodBefore(\"sendClouds\", argsNames_635, argsValues_636);\n                    localApi.sendClouds(clouds_632);\n                    ctx.invokeLocalMethodAfter(\"sendClouds\", null, argsNames_635, argsValues_636);\n                    break;\n                }\n                case 11: {\n                    const argsNames_638 = [];\n                    const argsValues_639 = [];\n                    ctx.invokeLocalMethodBefore(\"requestTelemetry\", argsNames_638, argsValues_639);\n                    localApi.requestTelemetry();\n                    ctx.invokeLocalMethodAfter(\"requestTelemetry\", null, argsNames_638, argsValues_639);\n                    break;\n                }\n                case 12: {\n                    let groups_641;\n                    const len_643 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_641 = new Array(len_643);\n                    for (let idx_642 = 0; idx_642 < len_643; idx_642++) {\n                        groups_641[idx_642] = aether_api_1.AccessGroup.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_644 = [\"groups\"];\n                    const argsValues_645 = [groups_641];\n                    ctx.invokeLocalMethodBefore(\"sendAccessGroups\", argsNames_644, argsValues_645);\n                    localApi.sendAccessGroups(groups_641);\n                    ctx.invokeLocalMethodAfter(\"sendAccessGroups\", null, argsNames_644, argsValues_645);\n                    break;\n                }\n                case 13: {\n                    let uid_647;\n                    let groups_648;\n                    uid_647 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_650 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_648 = new Array(len_650);\n                    for (let idx_649 = 0; idx_649 < len_650; idx_649++) {\n                        groups_648[idx_649] = dataIn.readLong();\n                    }\n                    const argsNames_651 = [\"uid\", \"groups\"];\n                    const argsValues_652 = [uid_647, groups_648];\n                    ctx.invokeLocalMethodBefore(\"sendAccessGroupForClient\", argsNames_651, argsValues_652);\n                    localApi.sendAccessGroupForClient(uid_647, groups_648);\n                    ctx.invokeLocalMethodAfter(\"sendAccessGroupForClient\", null, argsNames_651, argsValues_652);\n                    break;\n                }\n                case 14: {\n                    let id_654;\n                    let groups_655;\n                    id_654 = dataIn.readLong();\n                    const len_657 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_655 = new Array(len_657);\n                    for (let idx_656 = 0; idx_656 < len_657; idx_656++) {\n                        groups_655[idx_656] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_658 = [\"id\", \"groups\"];\n                    const argsValues_659 = [id_654, groups_655];\n                    ctx.invokeLocalMethodBefore(\"addItemsToAccessGroup\", argsNames_658, argsValues_659);\n                    localApi.addItemsToAccessGroup(id_654, groups_655);\n                    ctx.invokeLocalMethodAfter(\"addItemsToAccessGroup\", null, argsNames_658, argsValues_659);\n                    break;\n                }\n                case 15: {\n                    let id_661;\n                    let groups_662;\n                    id_661 = dataIn.readLong();\n                    const len_664 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_662 = new Array(len_664);\n                    for (let idx_663 = 0; idx_663 < len_664; idx_663++) {\n                        groups_662[idx_663] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_665 = [\"id\", \"groups\"];\n                    const argsValues_666 = [id_661, groups_662];\n                    ctx.invokeLocalMethodBefore(\"removeItemsFromAccessGroup\", argsNames_665, argsValues_666);\n                    localApi.removeItemsFromAccessGroup(id_661, groups_662);\n                    ctx.invokeLocalMethodAfter(\"removeItemsFromAccessGroup\", null, argsNames_665, argsValues_666);\n                    break;\n                }\n                case 16: {\n                    let uid_668;\n                    let groups_669;\n                    uid_668 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_671 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_669 = new Array(len_671);\n                    for (let idx_670 = 0; idx_670 < len_671; idx_670++) {\n                        groups_669[idx_670] = dataIn.readLong();\n                    }\n                    const argsNames_672 = [\"uid\", \"groups\"];\n                    const argsValues_673 = [uid_668, groups_669];\n                    ctx.invokeLocalMethodBefore(\"addAccessGroupsToClient\", argsNames_672, argsValues_673);\n                    localApi.addAccessGroupsToClient(uid_668, groups_669);\n                    ctx.invokeLocalMethodAfter(\"addAccessGroupsToClient\", null, argsNames_672, argsValues_673);\n                    break;\n                }\n                case 17: {\n                    let uid_675;\n                    let groups_676;\n                    uid_675 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_678 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_676 = new Array(len_678);\n                    for (let idx_677 = 0; idx_677 < len_678; idx_677++) {\n                        groups_676[idx_677] = dataIn.readLong();\n                    }\n                    const argsNames_679 = [\"uid\", \"groups\"];\n                    const argsValues_680 = [uid_675, groups_676];\n                    ctx.invokeLocalMethodBefore(\"removeAccessGroupsFromClient\", argsNames_679, argsValues_680);\n                    localApi.removeAccessGroupsFromClient(uid_675, groups_676);\n                    ctx.invokeLocalMethodAfter(\"removeAccessGroupsFromClient\", null, argsNames_679, argsValues_680);\n                    break;\n                }\n                case 18: {\n                    let uid_682;\n                    let accessedClients_683;\n                    uid_682 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_685 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    accessedClients_683 = new Array(len_685);\n                    for (let idx_684 = 0; idx_684 < len_685; idx_684++) {\n                        accessedClients_683[idx_684] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_686 = [\"uid\", \"accessedClients\"];\n                    const argsValues_687 = [uid_682, accessedClients_683];\n                    ctx.invokeLocalMethodBefore(\"sendAllAccessedClients\", argsNames_686, argsValues_687);\n                    localApi.sendAllAccessedClients(uid_682, accessedClients_683);\n                    ctx.invokeLocalMethodAfter(\"sendAllAccessedClients\", null, argsNames_686, argsValues_687);\n                    break;\n                }\n                case 19: {\n                    let results_689;\n                    const len_691 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    results_689 = new Array(len_691);\n                    for (let idx_690 = 0; idx_690 < len_691; idx_690++) {\n                        results_689[idx_690] = aether_api_1.AccessCheckResult.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_692 = [\"results\"];\n                    const argsValues_693 = [results_689];\n                    ctx.invokeLocalMethodBefore(\"sendAccessCheckResults\", argsNames_692, argsValues_693);\n                    localApi.sendAccessCheckResults(results_689);\n                    ctx.invokeLocalMethodAfter(\"sendAccessCheckResults\", null, argsNames_692, argsValues_693);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_694) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_694.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_694, changeParent: (uid) => {\n                const dataOut_696 = new aether_client_1.DataInOut();\n                dataOut_696.writeByte(3);\n                const argsNames_698 = [\"uid\"];\n                const argsValues_699 = [uid];\n                sCtx_694.invokeRemoteMethodAfter(\"changeParent\", null, argsNames_698, argsValues_699);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_696);\n                sCtx_694.sendToRemote(dataOut_696.toArray());\n            },\n            changeAlias: (alias) => {\n                const dataOut_701 = new aether_client_1.DataInOut();\n                dataOut_701.writeByte(4);\n                const argsNames_703 = [\"alias\"];\n                const argsValues_704 = [alias];\n                sCtx_694.invokeRemoteMethodAfter(\"changeAlias\", null, argsNames_703, argsValues_704);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, alias, dataOut_701);\n                sCtx_694.sendToRemote(dataOut_701.toArray());\n            },\n            newChild: (uid) => {\n                const dataOut_706 = new aether_client_1.DataInOut();\n                dataOut_706.writeByte(5);\n                const argsNames_708 = [\"uid\"];\n                const argsValues_709 = [uid];\n                sCtx_694.invokeRemoteMethodAfter(\"newChild\", null, argsNames_708, argsValues_709);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_706);\n                sCtx_694.sendToRemote(dataOut_706.toArray());\n            },\n            sendMessages: (msg) => {\n                const dataOut_711 = new aether_client_1.DataInOut();\n                dataOut_711.writeByte(6);\n                const argsNames_713 = [\"msg\"];\n                const argsValues_714 = [msg];\n                sCtx_694.invokeRemoteMethodAfter(\"sendMessages\", null, argsNames_713, argsValues_714);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_711, msg.length);\n                for (const el_715 of msg) {\n                    aether_api_1.Message.META.serialize(sCtx_694, el_715, dataOut_711);\n                }\n                sCtx_694.sendToRemote(dataOut_711.toArray());\n            },\n            sendServerDescriptor: (serverDescriptor) => {\n                const dataOut_717 = new aether_client_1.DataInOut();\n                dataOut_717.writeByte(7);\n                const argsNames_719 = [\"serverDescriptor\"];\n                const argsValues_720 = [serverDescriptor];\n                sCtx_694.invokeRemoteMethodAfter(\"sendServerDescriptor\", null, argsNames_719, argsValues_720);\n                aether_api_1.ServerDescriptor.META.serialize(sCtx_694, serverDescriptor, dataOut_717);\n                sCtx_694.sendToRemote(dataOut_717.toArray());\n            },\n            sendServerDescriptors: (serverDescriptors) => {\n                const dataOut_722 = new aether_client_1.DataInOut();\n                dataOut_722.writeByte(8);\n                const argsNames_724 = [\"serverDescriptors\"];\n                const argsValues_725 = [serverDescriptors];\n                sCtx_694.invokeRemoteMethodAfter(\"sendServerDescriptors\", null, argsNames_724, argsValues_725);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_722, serverDescriptors.length);\n                for (const el_726 of serverDescriptors) {\n                    aether_api_1.ServerDescriptor.META.serialize(sCtx_694, el_726, dataOut_722);\n                }\n                sCtx_694.sendToRemote(dataOut_722.toArray());\n            },\n            sendCloud: (uid, cloud) => {\n                const dataOut_728 = new aether_client_1.DataInOut();\n                dataOut_728.writeByte(9);\n                const argsNames_730 = [\"uid\", \"cloud\"];\n                const argsValues_731 = [uid, cloud];\n                sCtx_694.invokeRemoteMethodAfter(\"sendCloud\", null, argsNames_730, argsValues_731);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_728);\n                aether_api_1.Cloud.META.serialize(sCtx_694, cloud, dataOut_728);\n                sCtx_694.sendToRemote(dataOut_728.toArray());\n            },\n            sendClouds: (clouds) => {\n                const dataOut_733 = new aether_client_1.DataInOut();\n                dataOut_733.writeByte(10);\n                const argsNames_735 = [\"clouds\"];\n                const argsValues_736 = [clouds];\n                sCtx_694.invokeRemoteMethodAfter(\"sendClouds\", null, argsNames_735, argsValues_736);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_733, clouds.length);\n                for (const el_737 of clouds) {\n                    aether_api_1.UUIDAndCloud.META.serialize(sCtx_694, el_737, dataOut_733);\n                }\n                sCtx_694.sendToRemote(dataOut_733.toArray());\n            },\n            requestTelemetry: () => {\n                const dataOut_739 = new aether_client_1.DataInOut();\n                dataOut_739.writeByte(11);\n                const argsNames_741 = [];\n                const argsValues_742 = [];\n                sCtx_694.invokeRemoteMethodAfter(\"requestTelemetry\", null, argsNames_741, argsValues_742);\n                sCtx_694.sendToRemote(dataOut_739.toArray());\n            },\n            sendAccessGroups: (groups) => {\n                const dataOut_744 = new aether_client_1.DataInOut();\n                dataOut_744.writeByte(12);\n                const argsNames_746 = [\"groups\"];\n                const argsValues_747 = [groups];\n                sCtx_694.invokeRemoteMethodAfter(\"sendAccessGroups\", null, argsNames_746, argsValues_747);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_744, groups.length);\n                for (const el_748 of groups) {\n                    aether_api_1.AccessGroup.META.serialize(sCtx_694, el_748, dataOut_744);\n                }\n                sCtx_694.sendToRemote(dataOut_744.toArray());\n            },\n            sendAccessGroupForClient: (uid, groups) => {\n                const dataOut_750 = new aether_client_1.DataInOut();\n                dataOut_750.writeByte(13);\n                const argsNames_752 = [\"uid\", \"groups\"];\n                const argsValues_753 = [uid, groups];\n                sCtx_694.invokeRemoteMethodAfter(\"sendAccessGroupForClient\", null, argsNames_752, argsValues_753);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_750);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_750, groups.length);\n                for (const el_754 of groups) {\n                    dataOut_750.writeLong(el_754);\n                }\n                sCtx_694.sendToRemote(dataOut_750.toArray());\n            },\n            addItemsToAccessGroup: (id, groups) => {\n                const dataOut_756 = new aether_client_1.DataInOut();\n                dataOut_756.writeByte(14);\n                const argsNames_758 = [\"id\", \"groups\"];\n                const argsValues_759 = [id, groups];\n                sCtx_694.invokeRemoteMethodAfter(\"addItemsToAccessGroup\", null, argsNames_758, argsValues_759);\n                dataOut_756.writeLong(id);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_756, groups.length);\n                for (const el_760 of groups) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, el_760, dataOut_756);\n                }\n                sCtx_694.sendToRemote(dataOut_756.toArray());\n            },\n            removeItemsFromAccessGroup: (id, groups) => {\n                const dataOut_762 = new aether_client_1.DataInOut();\n                dataOut_762.writeByte(15);\n                const argsNames_764 = [\"id\", \"groups\"];\n                const argsValues_765 = [id, groups];\n                sCtx_694.invokeRemoteMethodAfter(\"removeItemsFromAccessGroup\", null, argsNames_764, argsValues_765);\n                dataOut_762.writeLong(id);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_762, groups.length);\n                for (const el_766 of groups) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, el_766, dataOut_762);\n                }\n                sCtx_694.sendToRemote(dataOut_762.toArray());\n            },\n            addAccessGroupsToClient: (uid, groups) => {\n                const dataOut_768 = new aether_client_1.DataInOut();\n                dataOut_768.writeByte(16);\n                const argsNames_770 = [\"uid\", \"groups\"];\n                const argsValues_771 = [uid, groups];\n                sCtx_694.invokeRemoteMethodAfter(\"addAccessGroupsToClient\", null, argsNames_770, argsValues_771);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_768);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_768, groups.length);\n                for (const el_772 of groups) {\n                    dataOut_768.writeLong(el_772);\n                }\n                sCtx_694.sendToRemote(dataOut_768.toArray());\n            },\n            removeAccessGroupsFromClient: (uid, groups) => {\n                const dataOut_774 = new aether_client_1.DataInOut();\n                dataOut_774.writeByte(17);\n                const argsNames_776 = [\"uid\", \"groups\"];\n                const argsValues_777 = [uid, groups];\n                sCtx_694.invokeRemoteMethodAfter(\"removeAccessGroupsFromClient\", null, argsNames_776, argsValues_777);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_774);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_774, groups.length);\n                for (const el_778 of groups) {\n                    dataOut_774.writeLong(el_778);\n                }\n                sCtx_694.sendToRemote(dataOut_774.toArray());\n            },\n            sendAllAccessedClients: (uid, accessedClients) => {\n                const dataOut_780 = new aether_client_1.DataInOut();\n                dataOut_780.writeByte(18);\n                const argsNames_782 = [\"uid\", \"accessedClients\"];\n                const argsValues_783 = [uid, accessedClients];\n                sCtx_694.invokeRemoteMethodAfter(\"sendAllAccessedClients\", null, argsNames_782, argsValues_783);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, uid, dataOut_780);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_780, accessedClients.length);\n                for (const el_784 of accessedClients) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_694, el_784, dataOut_780);\n                }\n                sCtx_694.sendToRemote(dataOut_780.toArray());\n            },\n            sendAccessCheckResults: (results) => {\n                const dataOut_786 = new aether_client_1.DataInOut();\n                dataOut_786.writeByte(19);\n                const argsNames_788 = [\"results\"];\n                const argsValues_789 = [results];\n                sCtx_694.invokeRemoteMethodAfter(\"sendAccessCheckResults\", null, argsNames_788, argsValues_789);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_786, results.length);\n                for (const el_790 of results) {\n                    aether_api_1.AccessCheckResult.META.serialize(sCtx_694, el_790, dataOut_786);\n                }\n                sCtx_694.sendToRemote(dataOut_786.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ClientApiSafeMetaImpl = ClientApiSafeMetaImpl;\nclass AuthorizedApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let id_792;\n                    id_792 = dataIn.readByte();\n                    const argsNames_793 = [\"id\"];\n                    const argsValues_794 = [id_792];\n                    ctx.invokeLocalMethodBefore(\"backId\", argsNames_793, argsValues_794);\n                    localApi.backId(id_792);\n                    ctx.invokeLocalMethodAfter(\"backId\", null, argsNames_793, argsValues_794);\n                    break;\n                }\n                case 4: {\n                    const reqId_795 = dataIn.readInt();\n                    let nextConnectMsDuration_796;\n                    nextConnectMsDuration_796 = dataIn.readLong();\n                    const argsNames_797 = [\"nextConnectMsDuration\"];\n                    const argsValues_798 = [nextConnectMsDuration_796];\n                    ctx.invokeLocalMethodBefore(\"ping\", argsNames_797, argsValues_798);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.ping(nextConnectMsDuration_796);\n                    ctx.invokeLocalMethodAfter(\"ping\", resultFuture, argsNames_797, argsValues_798);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_795);\n                    });\n                    break;\n                }\n                case 5: {\n                    let uid_800;\n                    let stream_801;\n                    uid_800 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    stream_801 = aether_api_1.ClientApiStream.META.deserialize(ctx, dataIn);\n                    const argsNames_802 = [\"uid\", \"stream\"];\n                    const argsValues_803 = [uid_800, stream_801];\n                    ctx.invokeLocalMethodBefore(\"client\", argsNames_802, argsValues_803);\n                    localApi.client(uid_800, stream_801);\n                    ctx.invokeLocalMethodAfter(\"client\", null, argsNames_802, argsValues_803);\n                    break;\n                }\n                case 6: {\n                    let msg_805;\n                    msg_805 = aether_api_1.Message.META.deserialize(ctx, dataIn);\n                    const argsNames_806 = [\"msg\"];\n                    const argsValues_807 = [msg_805];\n                    ctx.invokeLocalMethodBefore(\"sendMessage\", argsNames_806, argsValues_807);\n                    localApi.sendMessage(msg_805);\n                    ctx.invokeLocalMethodAfter(\"sendMessage\", null, argsNames_806, argsValues_807);\n                    break;\n                }\n                case 7: {\n                    let msg_809;\n                    const len_811 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    msg_809 = new Array(len_811);\n                    for (let idx_810 = 0; idx_810 < len_811; idx_810++) {\n                        msg_809[idx_810] = aether_api_1.Message.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_812 = [\"msg\"];\n                    const argsValues_813 = [msg_809];\n                    ctx.invokeLocalMethodBefore(\"sendMessages\", argsNames_812, argsValues_813);\n                    localApi.sendMessages(msg_809);\n                    ctx.invokeLocalMethodAfter(\"sendMessages\", null, argsNames_812, argsValues_813);\n                    break;\n                }\n                case 8: {\n                    const reqId_814 = dataIn.readInt();\n                    let owner_815;\n                    let uids_816;\n                    owner_815 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_818 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    uids_816 = new Array(len_818);\n                    for (let idx_817 = 0; idx_817 < len_818; idx_817++) {\n                        uids_816[idx_817] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_819 = [\"owner\", \"uids\"];\n                    const argsValues_820 = [owner_815, uids_816];\n                    ctx.invokeLocalMethodBefore(\"createAccessGroup\", argsNames_819, argsValues_820);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.createAccessGroup(owner_815, uids_816);\n                    ctx.invokeLocalMethodAfter(\"createAccessGroup\", resultFuture, argsNames_819, argsValues_820);\n                    resultFuture.to((v_822) => {\n                        const data_821 = new aether_client_1.DataInOut();\n                        data_821.writeLong(v_822);\n                        ctx.sendResultToRemote(reqId_814, data_821.toArray());\n                    });\n                    break;\n                }\n                case 9: {\n                    const reqId_823 = dataIn.readInt();\n                    let groupId_824;\n                    let uid_825;\n                    groupId_824 = dataIn.readLong();\n                    uid_825 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_826 = [\"groupId\", \"uid\"];\n                    const argsValues_827 = [groupId_824, uid_825];\n                    ctx.invokeLocalMethodBefore(\"addToAccessGroup\", argsNames_826, argsValues_827);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.addToAccessGroup(groupId_824, uid_825);\n                    ctx.invokeLocalMethodAfter(\"addToAccessGroup\", resultFuture, argsNames_826, argsValues_827);\n                    resultFuture.to((v_829) => {\n                        const data_828 = new aether_client_1.DataInOut();\n                        data_828.writeBoolean(v_829);\n                        ctx.sendResultToRemote(reqId_823, data_828.toArray());\n                    });\n                    break;\n                }\n                case 10: {\n                    const reqId_830 = dataIn.readInt();\n                    let groupId_831;\n                    let uid_832;\n                    groupId_831 = dataIn.readLong();\n                    uid_832 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_833 = [\"groupId\", \"uid\"];\n                    const argsValues_834 = [groupId_831, uid_832];\n                    ctx.invokeLocalMethodBefore(\"removeFromAccessGroup\", argsNames_833, argsValues_834);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.removeFromAccessGroup(groupId_831, uid_832);\n                    ctx.invokeLocalMethodAfter(\"removeFromAccessGroup\", resultFuture, argsNames_833, argsValues_834);\n                    resultFuture.to((v_836) => {\n                        const data_835 = new aether_client_1.DataInOut();\n                        data_835.writeBoolean(v_836);\n                        ctx.sendResultToRemote(reqId_830, data_835.toArray());\n                    });\n                    break;\n                }\n                case 11: {\n                    const reqId_837 = dataIn.readInt();\n                    let uid_838;\n                    uid_838 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_839 = [\"uid\"];\n                    const argsValues_840 = [uid_838];\n                    ctx.invokeLocalMethodBefore(\"checkAccessForSendMessage\", argsNames_839, argsValues_840);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.checkAccessForSendMessage(uid_838);\n                    ctx.invokeLocalMethodAfter(\"checkAccessForSendMessage\", resultFuture, argsNames_839, argsValues_840);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_837);\n                    });\n                    break;\n                }\n                case 12: {\n                    let sid_842;\n                    const len_844 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    sid_842 = new Array(len_844);\n                    for (let idx_843 = 0; idx_843 < len_844; idx_843++) {\n                        sid_842[idx_843] = dataIn.readShort();\n                    }\n                    const argsNames_845 = [\"sid\"];\n                    const argsValues_846 = [sid_842];\n                    ctx.invokeLocalMethodBefore(\"resolverServers\", argsNames_845, argsValues_846);\n                    localApi.resolverServers(sid_842);\n                    ctx.invokeLocalMethodAfter(\"resolverServers\", null, argsNames_845, argsValues_846);\n                    break;\n                }\n                case 13: {\n                    let uids_848;\n                    const len_850 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    uids_848 = new Array(len_850);\n                    for (let idx_849 = 0; idx_849 < len_850; idx_849++) {\n                        uids_848[idx_849] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_851 = [\"uids\"];\n                    const argsValues_852 = [uids_848];\n                    ctx.invokeLocalMethodBefore(\"resolverClouds\", argsNames_851, argsValues_852);\n                    localApi.resolverClouds(uids_848);\n                    ctx.invokeLocalMethodAfter(\"resolverClouds\", null, argsNames_851, argsValues_852);\n                    break;\n                }\n                case 14: {\n                    const reqId_853 = dataIn.readInt();\n                    let uid_854;\n                    uid_854 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_855 = [\"uid\"];\n                    const argsValues_856 = [uid_854];\n                    ctx.invokeLocalMethodBefore(\"getAccessGroups\", argsNames_855, argsValues_856);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getAccessGroups(uid_854);\n                    ctx.invokeLocalMethodAfter(\"getAccessGroups\", resultFuture, argsNames_855, argsValues_856);\n                    resultFuture.to((v_858) => {\n                        const data_857 = new aether_client_1.DataInOut();\n                        aether_client_1.SerializerPackNumber.INSTANCE.put(data_857, v_858.length);\n                        for (const el_859 of v_858) {\n                            data_857.writeLong(el_859);\n                        }\n                        ctx.sendResultToRemote(reqId_853, data_857.toArray());\n                    });\n                    break;\n                }\n                case 15: {\n                    const reqId_860 = dataIn.readInt();\n                    let groupId_861;\n                    groupId_861 = dataIn.readLong();\n                    const argsNames_862 = [\"groupId\"];\n                    const argsValues_863 = [groupId_861];\n                    ctx.invokeLocalMethodBefore(\"getAccessGroup\", argsNames_862, argsValues_863);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getAccessGroup(groupId_861);\n                    ctx.invokeLocalMethodAfter(\"getAccessGroup\", resultFuture, argsNames_862, argsValues_863);\n                    resultFuture.to((v_865) => {\n                        const data_864 = new aether_client_1.DataInOut();\n                        aether_api_1.AccessGroup.META.serialize(ctx, v_865, data_864);\n                        ctx.sendResultToRemote(reqId_860, data_864.toArray());\n                    });\n                    break;\n                }\n                case 16: {\n                    const reqId_866 = dataIn.readInt();\n                    let uid_867;\n                    uid_867 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_868 = [\"uid\"];\n                    const argsValues_869 = [uid_867];\n                    ctx.invokeLocalMethodBefore(\"getAllAccessedClients\", argsNames_868, argsValues_869);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getAllAccessedClients(uid_867);\n                    ctx.invokeLocalMethodAfter(\"getAllAccessedClients\", resultFuture, argsNames_868, argsValues_869);\n                    resultFuture.to((v_871) => {\n                        const data_870 = new aether_client_1.DataInOut();\n                        aether_client_1.SerializerPackNumber.INSTANCE.put(data_870, v_871.length);\n                        for (const el_872 of v_871) {\n                            aether_client_1.FastMeta.META_UUID.serialize(ctx, el_872, data_870);\n                        }\n                        ctx.sendResultToRemote(reqId_866, data_870.toArray());\n                    });\n                    break;\n                }\n                case 17: {\n                    const reqId_873 = dataIn.readInt();\n                    let uid1_874;\n                    let uid2_875;\n                    uid1_874 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    uid2_875 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_876 = [\"uid1\", \"uid2\"];\n                    const argsValues_877 = [uid1_874, uid2_875];\n                    ctx.invokeLocalMethodBefore(\"checkAccessForSendMessage2\", argsNames_876, argsValues_877);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.checkAccessForSendMessage2(uid1_874, uid2_875);\n                    ctx.invokeLocalMethodAfter(\"checkAccessForSendMessage2\", resultFuture, argsNames_876, argsValues_877);\n                    resultFuture.to((v_879) => {\n                        const data_878 = new aether_client_1.DataInOut();\n                        data_878.writeBoolean(v_879);\n                        ctx.sendResultToRemote(reqId_873, data_878.toArray());\n                    });\n                    break;\n                }\n                case 18: {\n                    let telemetry_881;\n                    telemetry_881 = aether_api_1.Telemetry.META.deserialize(ctx, dataIn);\n                    const argsNames_882 = [\"telemetry\"];\n                    const argsValues_883 = [telemetry_881];\n                    ctx.invokeLocalMethodBefore(\"sendTelemetry\", argsNames_882, argsValues_883);\n                    localApi.sendTelemetry(telemetry_881);\n                    ctx.invokeLocalMethodAfter(\"sendTelemetry\", null, argsNames_882, argsValues_883);\n                    break;\n                }\n                case 19: {\n                    let uids_885;\n                    const len_887 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    uids_885 = new Array(len_887);\n                    for (let idx_886 = 0; idx_886 < len_887; idx_886++) {\n                        uids_885[idx_886] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_888 = [\"uids\"];\n                    const argsValues_889 = [uids_885];\n                    ctx.invokeLocalMethodBefore(\"requestAccessGroupsForClients\", argsNames_888, argsValues_889);\n                    localApi.requestAccessGroupsForClients(uids_885);\n                    ctx.invokeLocalMethodAfter(\"requestAccessGroupsForClients\", null, argsNames_888, argsValues_889);\n                    break;\n                }\n                case 20: {\n                    let ids_891;\n                    const len_893 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    ids_891 = new Array(len_893);\n                    for (let idx_892 = 0; idx_892 < len_893; idx_892++) {\n                        ids_891[idx_892] = dataIn.readLong();\n                    }\n                    const argsNames_894 = [\"ids\"];\n                    const argsValues_895 = [ids_891];\n                    ctx.invokeLocalMethodBefore(\"requestAccessGroupsItems\", argsNames_894, argsValues_895);\n                    localApi.requestAccessGroupsItems(ids_891);\n                    ctx.invokeLocalMethodAfter(\"requestAccessGroupsItems\", null, argsNames_894, argsValues_895);\n                    break;\n                }\n                case 22: {\n                    let uid_897;\n                    let groups_898;\n                    uid_897 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_900 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_898 = new Array(len_900);\n                    for (let idx_899 = 0; idx_899 < len_900; idx_899++) {\n                        groups_898[idx_899] = dataIn.readLong();\n                    }\n                    const argsNames_901 = [\"uid\", \"groups\"];\n                    const argsValues_902 = [uid_897, groups_898];\n                    ctx.invokeLocalMethodBefore(\"sendAccessGroupForClient\", argsNames_901, argsValues_902);\n                    localApi.sendAccessGroupForClient(uid_897, groups_898);\n                    ctx.invokeLocalMethodAfter(\"sendAccessGroupForClient\", null, argsNames_901, argsValues_902);\n                    break;\n                }\n                case 23: {\n                    let id_904;\n                    let groups_905;\n                    id_904 = dataIn.readLong();\n                    const len_907 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_905 = new Array(len_907);\n                    for (let idx_906 = 0; idx_906 < len_907; idx_906++) {\n                        groups_905[idx_906] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_908 = [\"id\", \"groups\"];\n                    const argsValues_909 = [id_904, groups_905];\n                    ctx.invokeLocalMethodBefore(\"addItemsToAccessGroup\", argsNames_908, argsValues_909);\n                    localApi.addItemsToAccessGroup(id_904, groups_905);\n                    ctx.invokeLocalMethodAfter(\"addItemsToAccessGroup\", null, argsNames_908, argsValues_909);\n                    break;\n                }\n                case 24: {\n                    let id_911;\n                    let groups_912;\n                    id_911 = dataIn.readLong();\n                    const len_914 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_912 = new Array(len_914);\n                    for (let idx_913 = 0; idx_913 < len_914; idx_913++) {\n                        groups_912[idx_913] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_915 = [\"id\", \"groups\"];\n                    const argsValues_916 = [id_911, groups_912];\n                    ctx.invokeLocalMethodBefore(\"removeItemsFromAccessGroup\", argsNames_915, argsValues_916);\n                    localApi.removeItemsFromAccessGroup(id_911, groups_912);\n                    ctx.invokeLocalMethodAfter(\"removeItemsFromAccessGroup\", null, argsNames_915, argsValues_916);\n                    break;\n                }\n                case 25: {\n                    let uid_918;\n                    let groups_919;\n                    uid_918 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_921 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_919 = new Array(len_921);\n                    for (let idx_920 = 0; idx_920 < len_921; idx_920++) {\n                        groups_919[idx_920] = dataIn.readLong();\n                    }\n                    const argsNames_922 = [\"uid\", \"groups\"];\n                    const argsValues_923 = [uid_918, groups_919];\n                    ctx.invokeLocalMethodBefore(\"addAccessGroupsToClient\", argsNames_922, argsValues_923);\n                    localApi.addAccessGroupsToClient(uid_918, groups_919);\n                    ctx.invokeLocalMethodAfter(\"addAccessGroupsToClient\", null, argsNames_922, argsValues_923);\n                    break;\n                }\n                case 26: {\n                    let uid_925;\n                    let groups_926;\n                    uid_925 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const len_928 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    groups_926 = new Array(len_928);\n                    for (let idx_927 = 0; idx_927 < len_928; idx_927++) {\n                        groups_926[idx_927] = dataIn.readLong();\n                    }\n                    const argsNames_929 = [\"uid\", \"groups\"];\n                    const argsValues_930 = [uid_925, groups_926];\n                    ctx.invokeLocalMethodBefore(\"removeAccessGroupsFromClient\", argsNames_929, argsValues_930);\n                    localApi.removeAccessGroupsFromClient(uid_925, groups_926);\n                    ctx.invokeLocalMethodAfter(\"removeAccessGroupsFromClient\", null, argsNames_929, argsValues_930);\n                    break;\n                }\n                case 27: {\n                    let uids_932;\n                    const len_934 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    uids_932 = new Array(len_934);\n                    for (let idx_933 = 0; idx_933 < len_934; idx_933++) {\n                        uids_932[idx_933] = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_935 = [\"uids\"];\n                    const argsValues_936 = [uids_932];\n                    ctx.invokeLocalMethodBefore(\"requestAllAccessedClients\", argsNames_935, argsValues_936);\n                    localApi.requestAllAccessedClients(uids_932);\n                    ctx.invokeLocalMethodAfter(\"requestAllAccessedClients\", null, argsNames_935, argsValues_936);\n                    break;\n                }\n                case 28: {\n                    let requests_938;\n                    const len_940 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    requests_938 = new Array(len_940);\n                    for (let idx_939 = 0; idx_939 < len_940; idx_939++) {\n                        requests_938[idx_939] = aether_api_1.AccessCheckPair.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_941 = [\"requests\"];\n                    const argsValues_942 = [requests_938];\n                    ctx.invokeLocalMethodBefore(\"requestAccessCheck\", argsNames_941, argsValues_942);\n                    localApi.requestAccessCheck(requests_938);\n                    ctx.invokeLocalMethodAfter(\"requestAccessCheck\", null, argsNames_941, argsValues_942);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_943) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_943.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_943, backId: (id) => {\n                const dataOut_945 = new aether_client_1.DataInOut();\n                dataOut_945.writeByte(3);\n                const argsNames_947 = [\"id\"];\n                const argsValues_948 = [id];\n                sCtx_943.invokeRemoteMethodAfter(\"backId\", null, argsNames_947, argsValues_948);\n                dataOut_945.writeByte(id);\n                sCtx_943.sendToRemote(dataOut_945.toArray());\n            },\n            ping: (nextConnectMsDuration) => {\n                const dataOut_950 = new aether_client_1.DataInOut();\n                dataOut_950.writeByte(4);\n                const argsNames_952 = [\"nextConnectMsDuration\"];\n                const argsValues_953 = [nextConnectMsDuration];\n                const result_951 = aether_client_1.AFuture.make();\n                sCtx_943.invokeRemoteMethodAfter(\"ping\", result_951, argsNames_952, argsValues_953);\n                const reqId_949 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_951.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_951.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_950.writeInt(reqId_949);\n                dataOut_950.writeLong(nextConnectMsDuration);\n                sCtx_943.sendToRemote(dataOut_950.toArray());\n                return result_951;\n            },\n            client: (uid, stream) => {\n                const dataOut_955 = new aether_client_1.DataInOut();\n                dataOut_955.writeByte(5);\n                const argsNames_957 = [\"uid\", \"stream\"];\n                const argsValues_958 = [uid, stream];\n                sCtx_943.invokeRemoteMethodAfter(\"client\", null, argsNames_957, argsValues_958);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_955);\n                aether_api_1.ClientApiStream.META.serialize(sCtx_943, stream, dataOut_955);\n                sCtx_943.sendToRemote(dataOut_955.toArray());\n            },\n            sendMessage: (msg) => {\n                const dataOut_960 = new aether_client_1.DataInOut();\n                dataOut_960.writeByte(6);\n                const argsNames_962 = [\"msg\"];\n                const argsValues_963 = [msg];\n                sCtx_943.invokeRemoteMethodAfter(\"sendMessage\", null, argsNames_962, argsValues_963);\n                aether_api_1.Message.META.serialize(sCtx_943, msg, dataOut_960);\n                sCtx_943.sendToRemote(dataOut_960.toArray());\n            },\n            sendMessages: (msg) => {\n                const dataOut_965 = new aether_client_1.DataInOut();\n                dataOut_965.writeByte(7);\n                const argsNames_967 = [\"msg\"];\n                const argsValues_968 = [msg];\n                sCtx_943.invokeRemoteMethodAfter(\"sendMessages\", null, argsNames_967, argsValues_968);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_965, msg.length);\n                for (const el_969 of msg) {\n                    aether_api_1.Message.META.serialize(sCtx_943, el_969, dataOut_965);\n                }\n                sCtx_943.sendToRemote(dataOut_965.toArray());\n            },\n            createAccessGroup: (owner, uids) => {\n                const dataOut_971 = new aether_client_1.DataInOut();\n                dataOut_971.writeByte(8);\n                const argsNames_973 = [\"owner\", \"uids\"];\n                const argsValues_974 = [owner, uids];\n                const result_972 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"createAccessGroup\", result_972, argsNames_973, argsValues_974);\n                const reqId_970 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_972.tryDone(aether_client_1.FastMeta.META_LONG.deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_972.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_971.writeInt(reqId_970);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, owner, dataOut_971);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_971, uids.length);\n                for (const el_975 of uids) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_975, dataOut_971);\n                }\n                sCtx_943.sendToRemote(dataOut_971.toArray());\n                return result_972;\n            },\n            addToAccessGroup: (groupId, uid) => {\n                const dataOut_977 = new aether_client_1.DataInOut();\n                dataOut_977.writeByte(9);\n                const argsNames_979 = [\"groupId\", \"uid\"];\n                const argsValues_980 = [groupId, uid];\n                const result_978 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"addToAccessGroup\", result_978, argsNames_979, argsValues_980);\n                const reqId_976 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_978.tryDone(aether_client_1.FastMeta.META_BOOLEAN.deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_978.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_977.writeInt(reqId_976);\n                dataOut_977.writeLong(groupId);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_977);\n                sCtx_943.sendToRemote(dataOut_977.toArray());\n                return result_978;\n            },\n            removeFromAccessGroup: (groupId, uid) => {\n                const dataOut_982 = new aether_client_1.DataInOut();\n                dataOut_982.writeByte(10);\n                const argsNames_984 = [\"groupId\", \"uid\"];\n                const argsValues_985 = [groupId, uid];\n                const result_983 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"removeFromAccessGroup\", result_983, argsNames_984, argsValues_985);\n                const reqId_981 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_983.tryDone(aether_client_1.FastMeta.META_BOOLEAN.deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_983.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_982.writeInt(reqId_981);\n                dataOut_982.writeLong(groupId);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_982);\n                sCtx_943.sendToRemote(dataOut_982.toArray());\n                return result_983;\n            },\n            checkAccessForSendMessage: (uid) => {\n                const dataOut_987 = new aether_client_1.DataInOut();\n                dataOut_987.writeByte(11);\n                const argsNames_989 = [\"uid\"];\n                const argsValues_990 = [uid];\n                const result_988 = aether_client_1.AFuture.make();\n                sCtx_943.invokeRemoteMethodAfter(\"checkAccessForSendMessage\", result_988, argsNames_989, argsValues_990);\n                const reqId_986 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_988.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_988.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_987.writeInt(reqId_986);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_987);\n                sCtx_943.sendToRemote(dataOut_987.toArray());\n                return result_988;\n            },\n            resolverServers: (sid) => {\n                const dataOut_992 = new aether_client_1.DataInOut();\n                dataOut_992.writeByte(12);\n                const argsNames_994 = [\"sid\"];\n                const argsValues_995 = [sid];\n                sCtx_943.invokeRemoteMethodAfter(\"resolverServers\", null, argsNames_994, argsValues_995);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_992, sid.length);\n                for (const el_996 of sid) {\n                    dataOut_992.writeShort(el_996);\n                }\n                sCtx_943.sendToRemote(dataOut_992.toArray());\n            },\n            resolverClouds: (uids) => {\n                const dataOut_998 = new aether_client_1.DataInOut();\n                dataOut_998.writeByte(13);\n                const argsNames_1000 = [\"uids\"];\n                const argsValues_1001 = [uids];\n                sCtx_943.invokeRemoteMethodAfter(\"resolverClouds\", null, argsNames_1000, argsValues_1001);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_998, uids.length);\n                for (const el_1002 of uids) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_1002, dataOut_998);\n                }\n                sCtx_943.sendToRemote(dataOut_998.toArray());\n            },\n            getAccessGroups: (uid) => {\n                const dataOut_1004 = new aether_client_1.DataInOut();\n                dataOut_1004.writeByte(14);\n                const argsNames_1006 = [\"uid\"];\n                const argsValues_1007 = [uid];\n                const result_1005 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"getAccessGroups\", result_1005, argsNames_1006, argsValues_1007);\n                const reqId_1003 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_1005.tryDone(aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_LONG).deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1005.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1004.writeInt(reqId_1003);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_1004);\n                sCtx_943.sendToRemote(dataOut_1004.toArray());\n                return result_1005;\n            },\n            getAccessGroup: (groupId) => {\n                const dataOut_1009 = new aether_client_1.DataInOut();\n                dataOut_1009.writeByte(15);\n                const argsNames_1011 = [\"groupId\"];\n                const argsValues_1012 = [groupId];\n                const result_1010 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"getAccessGroup\", result_1010, argsNames_1011, argsValues_1012);\n                const reqId_1008 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_1010.tryDone(aether_api_1.AccessGroup.META.deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1010.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1009.writeInt(reqId_1008);\n                dataOut_1009.writeLong(groupId);\n                sCtx_943.sendToRemote(dataOut_1009.toArray());\n                return result_1010;\n            },\n            getAllAccessedClients: (uid) => {\n                const dataOut_1014 = new aether_client_1.DataInOut();\n                dataOut_1014.writeByte(16);\n                const argsNames_1016 = [\"uid\"];\n                const argsValues_1017 = [uid];\n                const result_1015 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"getAllAccessedClients\", result_1015, argsNames_1016, argsValues_1017);\n                const reqId_1013 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_1015.tryDone(aether_client_1.FastMeta.getMetaArray(aether_client_1.FastMeta.META_UUID).deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1015.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1014.writeInt(reqId_1013);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_1014);\n                sCtx_943.sendToRemote(dataOut_1014.toArray());\n                return result_1015;\n            },\n            checkAccessForSendMessage2: (uid1, uid2) => {\n                const dataOut_1019 = new aether_client_1.DataInOut();\n                dataOut_1019.writeByte(17);\n                const argsNames_1021 = [\"uid1\", \"uid2\"];\n                const argsValues_1022 = [uid1, uid2];\n                const result_1020 = aether_client_1.ARFuture.of();\n                sCtx_943.invokeRemoteMethodAfter(\"checkAccessForSendMessage2\", result_1020, argsNames_1021, argsValues_1022);\n                const reqId_1018 = sCtx_943.regFuture({\n                    onDone: (in_) => {\n                        result_1020.tryDone(aether_client_1.FastMeta.META_BOOLEAN.deserialize(sCtx_943, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1020.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1019.writeInt(reqId_1018);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid1, dataOut_1019);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid2, dataOut_1019);\n                sCtx_943.sendToRemote(dataOut_1019.toArray());\n                return result_1020;\n            },\n            sendTelemetry: (telemetry) => {\n                const dataOut_1024 = new aether_client_1.DataInOut();\n                dataOut_1024.writeByte(18);\n                const argsNames_1026 = [\"telemetry\"];\n                const argsValues_1027 = [telemetry];\n                sCtx_943.invokeRemoteMethodAfter(\"sendTelemetry\", null, argsNames_1026, argsValues_1027);\n                aether_api_1.Telemetry.META.serialize(sCtx_943, telemetry, dataOut_1024);\n                sCtx_943.sendToRemote(dataOut_1024.toArray());\n            },\n            requestAccessGroupsForClients: (uids) => {\n                const dataOut_1029 = new aether_client_1.DataInOut();\n                dataOut_1029.writeByte(19);\n                const argsNames_1031 = [\"uids\"];\n                const argsValues_1032 = [uids];\n                sCtx_943.invokeRemoteMethodAfter(\"requestAccessGroupsForClients\", null, argsNames_1031, argsValues_1032);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1029, uids.length);\n                for (const el_1033 of uids) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_1033, dataOut_1029);\n                }\n                sCtx_943.sendToRemote(dataOut_1029.toArray());\n            },\n            requestAccessGroupsItems: (ids) => {\n                const dataOut_1035 = new aether_client_1.DataInOut();\n                dataOut_1035.writeByte(20);\n                const argsNames_1037 = [\"ids\"];\n                const argsValues_1038 = [ids];\n                sCtx_943.invokeRemoteMethodAfter(\"requestAccessGroupsItems\", null, argsNames_1037, argsValues_1038);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1035, ids.length);\n                for (const el_1039 of ids) {\n                    dataOut_1035.writeLong(el_1039);\n                }\n                sCtx_943.sendToRemote(dataOut_1035.toArray());\n            },\n            sendAccessGroupForClient: (uid, groups) => {\n                const dataOut_1041 = new aether_client_1.DataInOut();\n                dataOut_1041.writeByte(22);\n                const argsNames_1043 = [\"uid\", \"groups\"];\n                const argsValues_1044 = [uid, groups];\n                sCtx_943.invokeRemoteMethodAfter(\"sendAccessGroupForClient\", null, argsNames_1043, argsValues_1044);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_1041);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1041, groups.length);\n                for (const el_1045 of groups) {\n                    dataOut_1041.writeLong(el_1045);\n                }\n                sCtx_943.sendToRemote(dataOut_1041.toArray());\n            },\n            addItemsToAccessGroup: (id, groups) => {\n                const dataOut_1047 = new aether_client_1.DataInOut();\n                dataOut_1047.writeByte(23);\n                const argsNames_1049 = [\"id\", \"groups\"];\n                const argsValues_1050 = [id, groups];\n                sCtx_943.invokeRemoteMethodAfter(\"addItemsToAccessGroup\", null, argsNames_1049, argsValues_1050);\n                dataOut_1047.writeLong(id);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1047, groups.length);\n                for (const el_1051 of groups) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_1051, dataOut_1047);\n                }\n                sCtx_943.sendToRemote(dataOut_1047.toArray());\n            },\n            removeItemsFromAccessGroup: (id, groups) => {\n                const dataOut_1053 = new aether_client_1.DataInOut();\n                dataOut_1053.writeByte(24);\n                const argsNames_1055 = [\"id\", \"groups\"];\n                const argsValues_1056 = [id, groups];\n                sCtx_943.invokeRemoteMethodAfter(\"removeItemsFromAccessGroup\", null, argsNames_1055, argsValues_1056);\n                dataOut_1053.writeLong(id);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1053, groups.length);\n                for (const el_1057 of groups) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_1057, dataOut_1053);\n                }\n                sCtx_943.sendToRemote(dataOut_1053.toArray());\n            },\n            addAccessGroupsToClient: (uid, groups) => {\n                const dataOut_1059 = new aether_client_1.DataInOut();\n                dataOut_1059.writeByte(25);\n                const argsNames_1061 = [\"uid\", \"groups\"];\n                const argsValues_1062 = [uid, groups];\n                sCtx_943.invokeRemoteMethodAfter(\"addAccessGroupsToClient\", null, argsNames_1061, argsValues_1062);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_1059);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1059, groups.length);\n                for (const el_1063 of groups) {\n                    dataOut_1059.writeLong(el_1063);\n                }\n                sCtx_943.sendToRemote(dataOut_1059.toArray());\n            },\n            removeAccessGroupsFromClient: (uid, groups) => {\n                const dataOut_1065 = new aether_client_1.DataInOut();\n                dataOut_1065.writeByte(26);\n                const argsNames_1067 = [\"uid\", \"groups\"];\n                const argsValues_1068 = [uid, groups];\n                sCtx_943.invokeRemoteMethodAfter(\"removeAccessGroupsFromClient\", null, argsNames_1067, argsValues_1068);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, uid, dataOut_1065);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1065, groups.length);\n                for (const el_1069 of groups) {\n                    dataOut_1065.writeLong(el_1069);\n                }\n                sCtx_943.sendToRemote(dataOut_1065.toArray());\n            },\n            requestAllAccessedClients: (uids) => {\n                const dataOut_1071 = new aether_client_1.DataInOut();\n                dataOut_1071.writeByte(27);\n                const argsNames_1073 = [\"uids\"];\n                const argsValues_1074 = [uids];\n                sCtx_943.invokeRemoteMethodAfter(\"requestAllAccessedClients\", null, argsNames_1073, argsValues_1074);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1071, uids.length);\n                for (const el_1075 of uids) {\n                    aether_client_1.FastMeta.META_UUID.serialize(sCtx_943, el_1075, dataOut_1071);\n                }\n                sCtx_943.sendToRemote(dataOut_1071.toArray());\n            },\n            requestAccessCheck: (requests) => {\n                const dataOut_1077 = new aether_client_1.DataInOut();\n                dataOut_1077.writeByte(28);\n                const argsNames_1079 = [\"requests\"];\n                const argsValues_1080 = [requests];\n                sCtx_943.invokeRemoteMethodAfter(\"requestAccessCheck\", null, argsNames_1079, argsValues_1080);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1077, requests.length);\n                for (const el_1081 of requests) {\n                    aether_api_1.AccessCheckPair.META.serialize(sCtx_943, el_1081, dataOut_1077);\n                }\n                sCtx_943.sendToRemote(dataOut_1077.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.AuthorizedApiMetaImpl = AuthorizedApiMetaImpl;\nclass LoginApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    const reqId_1082 = dataIn.readInt();\n                    const argsNames_1083 = [];\n                    const argsValues_1084 = [];\n                    ctx.invokeLocalMethodBefore(\"getTimeUTC\", argsNames_1083, argsValues_1084);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getTimeUTC();\n                    ctx.invokeLocalMethodAfter(\"getTimeUTC\", resultFuture, argsNames_1083, argsValues_1084);\n                    resultFuture.to((v_1086) => {\n                        const data_1085 = new aether_client_1.DataInOut();\n                        data_1085.writeLong(v_1086);\n                        ctx.sendResultToRemote(reqId_1082, data_1085.toArray());\n                    });\n                    break;\n                }\n                case 4: {\n                    let uid_1088;\n                    let data_1089;\n                    uid_1088 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    data_1089 = aether_api_1.LoginStream.META.deserialize(ctx, dataIn);\n                    const argsNames_1090 = [\"uid\", \"data\"];\n                    const argsValues_1091 = [uid_1088, data_1089];\n                    ctx.invokeLocalMethodBefore(\"loginByUID\", argsNames_1090, argsValues_1091);\n                    localApi.loginByUID(uid_1088, data_1089);\n                    ctx.invokeLocalMethodAfter(\"loginByUID\", null, argsNames_1090, argsValues_1091);\n                    break;\n                }\n                case 5: {\n                    let alias_1093;\n                    let data_1094;\n                    alias_1093 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    data_1094 = aether_api_1.LoginStream.META.deserialize(ctx, dataIn);\n                    const argsNames_1095 = [\"alias\", \"data\"];\n                    const argsValues_1096 = [alias_1093, data_1094];\n                    ctx.invokeLocalMethodBefore(\"loginByAlias\", argsNames_1095, argsValues_1096);\n                    localApi.loginByAlias(alias_1093, data_1094);\n                    ctx.invokeLocalMethodAfter(\"loginByAlias\", null, argsNames_1095, argsValues_1096);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1097) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1097.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1097, getTimeUTC: () => {\n                const dataOut_1099 = new aether_client_1.DataInOut();\n                dataOut_1099.writeByte(3);\n                const argsNames_1101 = [];\n                const argsValues_1102 = [];\n                const result_1100 = aether_client_1.ARFuture.of();\n                sCtx_1097.invokeRemoteMethodAfter(\"getTimeUTC\", result_1100, argsNames_1101, argsValues_1102);\n                const reqId_1098 = sCtx_1097.regFuture({\n                    onDone: (in_) => {\n                        result_1100.tryDone(aether_client_1.FastMeta.META_LONG.deserialize(sCtx_1097, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1100.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1099.writeInt(reqId_1098);\n                sCtx_1097.sendToRemote(dataOut_1099.toArray());\n                return result_1100;\n            },\n            loginByUID: (uid, data) => {\n                const dataOut_1104 = new aether_client_1.DataInOut();\n                dataOut_1104.writeByte(4);\n                const argsNames_1106 = [\"uid\", \"data\"];\n                const argsValues_1107 = [uid, data];\n                sCtx_1097.invokeRemoteMethodAfter(\"loginByUID\", null, argsNames_1106, argsValues_1107);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1097, uid, dataOut_1104);\n                aether_api_1.LoginStream.META.serialize(sCtx_1097, data, dataOut_1104);\n                sCtx_1097.sendToRemote(dataOut_1104.toArray());\n            },\n            loginByAlias: (alias, data) => {\n                const dataOut_1109 = new aether_client_1.DataInOut();\n                dataOut_1109.writeByte(5);\n                const argsNames_1111 = [\"alias\", \"data\"];\n                const argsValues_1112 = [alias, data];\n                sCtx_1097.invokeRemoteMethodAfter(\"loginByAlias\", null, argsNames_1111, argsValues_1112);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1097, alias, dataOut_1109);\n                aether_api_1.LoginStream.META.serialize(sCtx_1097, data, dataOut_1109);\n                sCtx_1097.sendToRemote(dataOut_1109.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.LoginApiMetaImpl = LoginApiMetaImpl;\nclass ServerApiByUidClientMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, _localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1113) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1113.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1113,\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ServerApiByUidClientMetaImpl = ServerApiByUidClientMetaImpl;\nclass ServerApiByUidMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    const reqId_1114 = dataIn.readInt();\n                    const argsNames_1115 = [];\n                    const argsValues_1116 = [];\n                    ctx.invokeLocalMethodBefore(\"getBalance\", argsNames_1115, argsValues_1116);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getBalance();\n                    ctx.invokeLocalMethodAfter(\"getBalance\", resultFuture, argsNames_1115, argsValues_1116);\n                    resultFuture.to((v_1118) => {\n                        const data_1117 = new aether_client_1.DataInOut();\n                        data_1117.writeLong(v_1118);\n                        ctx.sendResultToRemote(reqId_1114, data_1117.toArray());\n                    });\n                    break;\n                }\n                case 4: {\n                    const reqId_1119 = dataIn.readInt();\n                    let uid_1120;\n                    uid_1120 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_1121 = [\"uid\"];\n                    const argsValues_1122 = [uid_1120];\n                    ctx.invokeLocalMethodBefore(\"setParent\", argsNames_1121, argsValues_1122);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.setParent(uid_1120);\n                    ctx.invokeLocalMethodAfter(\"setParent\", resultFuture, argsNames_1121, argsValues_1122);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_1119);\n                    });\n                    break;\n                }\n                case 5: {\n                    const reqId_1123 = dataIn.readInt();\n                    const argsNames_1124 = [];\n                    const argsValues_1125 = [];\n                    ctx.invokeLocalMethodBefore(\"block\", argsNames_1124, argsValues_1125);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.block();\n                    ctx.invokeLocalMethodAfter(\"block\", resultFuture, argsNames_1124, argsValues_1125);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_1123);\n                    });\n                    break;\n                }\n                case 6: {\n                    const reqId_1126 = dataIn.readInt();\n                    const argsNames_1127 = [];\n                    const argsValues_1128 = [];\n                    ctx.invokeLocalMethodBefore(\"getPosition\", argsNames_1127, argsValues_1128);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getPosition();\n                    ctx.invokeLocalMethodAfter(\"getPosition\", resultFuture, argsNames_1127, argsValues_1128);\n                    resultFuture.to((v_1130) => {\n                        const data_1129 = new aether_client_1.DataInOut();\n                        aether_api_1.Cloud.META.serialize(ctx, v_1130, data_1129);\n                        ctx.sendResultToRemote(reqId_1126, data_1129.toArray());\n                    });\n                    break;\n                }\n                case 7: {\n                    const reqId_1131 = dataIn.readInt();\n                    const argsNames_1132 = [];\n                    const argsValues_1133 = [];\n                    ctx.invokeLocalMethodBefore(\"getParent\", argsNames_1132, argsValues_1133);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getParent();\n                    ctx.invokeLocalMethodAfter(\"getParent\", resultFuture, argsNames_1132, argsValues_1133);\n                    resultFuture.to((v_1135) => {\n                        const data_1134 = new aether_client_1.DataInOut();\n                        aether_client_1.FastMeta.META_UUID.serialize(ctx, v_1135, data_1134);\n                        ctx.sendResultToRemote(reqId_1131, data_1134.toArray());\n                    });\n                    break;\n                }\n                case 8: {\n                    const reqId_1136 = dataIn.readInt();\n                    const argsNames_1137 = [];\n                    const argsValues_1138 = [];\n                    ctx.invokeLocalMethodBefore(\"getBeneficiary\", argsNames_1137, argsValues_1138);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getBeneficiary();\n                    ctx.invokeLocalMethodAfter(\"getBeneficiary\", resultFuture, argsNames_1137, argsValues_1138);\n                    resultFuture.to((v_1140) => {\n                        const data_1139 = new aether_client_1.DataInOut();\n                        aether_client_1.FastMeta.META_UUID.serialize(ctx, v_1140, data_1139);\n                        ctx.sendResultToRemote(reqId_1136, data_1139.toArray());\n                    });\n                    break;\n                }\n                case 9: {\n                    const reqId_1141 = dataIn.readInt();\n                    let uid_1142;\n                    uid_1142 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_1143 = [\"uid\"];\n                    const argsValues_1144 = [uid_1142];\n                    ctx.invokeLocalMethodBefore(\"setBeneficiary\", argsNames_1143, argsValues_1144);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.setBeneficiary(uid_1142);\n                    ctx.invokeLocalMethodAfter(\"setBeneficiary\", resultFuture, argsNames_1143, argsValues_1144);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_1141);\n                    });\n                    break;\n                }\n                case 10: {\n                    const reqId_1145 = dataIn.readInt();\n                    const argsNames_1146 = [];\n                    const argsValues_1147 = [];\n                    ctx.invokeLocalMethodBefore(\"getBlockTime\", argsNames_1146, argsValues_1147);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getBlockTime();\n                    ctx.invokeLocalMethodAfter(\"getBlockTime\", resultFuture, argsNames_1146, argsValues_1147);\n                    resultFuture.to((v_1149) => {\n                        const data_1148 = new aether_client_1.DataInOut();\n                        data_1148.writeLong(v_1149.getTime());\n                        ctx.sendResultToRemote(reqId_1145, data_1148.toArray());\n                    });\n                    break;\n                }\n                case 11: {\n                    const reqId_1150 = dataIn.readInt();\n                    const argsNames_1151 = [];\n                    const argsValues_1152 = [];\n                    ctx.invokeLocalMethodBefore(\"unblock\", argsNames_1151, argsValues_1152);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.unblock();\n                    ctx.invokeLocalMethodAfter(\"unblock\", resultFuture, argsNames_1151, argsValues_1152);\n                    resultFuture.to(() => {\n                        ctx.sendResultToRemoteNoData(reqId_1150);\n                    });\n                    break;\n                }\n                case 12: {\n                    const reqId_1153 = dataIn.readInt();\n                    const argsNames_1154 = [];\n                    const argsValues_1155 = [];\n                    ctx.invokeLocalMethodBefore(\"createTime\", argsNames_1154, argsValues_1155);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.createTime();\n                    ctx.invokeLocalMethodAfter(\"createTime\", resultFuture, argsNames_1154, argsValues_1155);\n                    resultFuture.to((v_1157) => {\n                        const data_1156 = new aether_client_1.DataInOut();\n                        data_1156.writeLong(v_1157.getTime());\n                        ctx.sendResultToRemote(reqId_1153, data_1156.toArray());\n                    });\n                    break;\n                }\n                case 13: {\n                    const reqId_1158 = dataIn.readInt();\n                    const argsNames_1159 = [];\n                    const argsValues_1160 = [];\n                    ctx.invokeLocalMethodBefore(\"onlineTime\", argsNames_1159, argsValues_1160);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.onlineTime();\n                    ctx.invokeLocalMethodAfter(\"onlineTime\", resultFuture, argsNames_1159, argsValues_1160);\n                    resultFuture.to((v_1162) => {\n                        const data_1161 = new aether_client_1.DataInOut();\n                        data_1161.writeLong(v_1162.getTime());\n                        ctx.sendResultToRemote(reqId_1158, data_1161.toArray());\n                    });\n                    break;\n                }\n                case 14: {\n                    const reqId_1163 = dataIn.readInt();\n                    let groupId_1164;\n                    groupId_1164 = dataIn.readLong();\n                    const argsNames_1165 = [\"groupId\"];\n                    const argsValues_1166 = [groupId_1164];\n                    ctx.invokeLocalMethodBefore(\"addAccessGroup\", argsNames_1165, argsValues_1166);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.addAccessGroup(groupId_1164);\n                    ctx.invokeLocalMethodAfter(\"addAccessGroup\", resultFuture, argsNames_1165, argsValues_1166);\n                    resultFuture.to((v_1168) => {\n                        const data_1167 = new aether_client_1.DataInOut();\n                        data_1167.writeBoolean(v_1168);\n                        ctx.sendResultToRemote(reqId_1163, data_1167.toArray());\n                    });\n                    break;\n                }\n                case 15: {\n                    const reqId_1169 = dataIn.readInt();\n                    let groupId_1170;\n                    groupId_1170 = dataIn.readLong();\n                    const argsNames_1171 = [\"groupId\"];\n                    const argsValues_1172 = [groupId_1170];\n                    ctx.invokeLocalMethodBefore(\"removeAccessGroup\", argsNames_1171, argsValues_1172);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.removeAccessGroup(groupId_1170);\n                    ctx.invokeLocalMethodAfter(\"removeAccessGroup\", resultFuture, argsNames_1171, argsValues_1172);\n                    resultFuture.to((v_1174) => {\n                        const data_1173 = new aether_client_1.DataInOut();\n                        data_1173.writeBoolean(v_1174);\n                        ctx.sendResultToRemote(reqId_1169, data_1173.toArray());\n                    });\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1175) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1175.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1175, getBalance: () => {\n                const dataOut_1177 = new aether_client_1.DataInOut();\n                dataOut_1177.writeByte(3);\n                const argsNames_1179 = [];\n                const argsValues_1180 = [];\n                const result_1178 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"getBalance\", result_1178, argsNames_1179, argsValues_1180);\n                const reqId_1176 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1178.tryDone(aether_client_1.FastMeta.META_LONG.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1178.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1177.writeInt(reqId_1176);\n                sCtx_1175.sendToRemote(dataOut_1177.toArray());\n                return result_1178;\n            },\n            setParent: (uid) => {\n                const dataOut_1182 = new aether_client_1.DataInOut();\n                dataOut_1182.writeByte(4);\n                const argsNames_1184 = [\"uid\"];\n                const argsValues_1185 = [uid];\n                const result_1183 = aether_client_1.AFuture.make();\n                sCtx_1175.invokeRemoteMethodAfter(\"setParent\", result_1183, argsNames_1184, argsValues_1185);\n                const reqId_1181 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1183.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_1183.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1182.writeInt(reqId_1181);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1175, uid, dataOut_1182);\n                sCtx_1175.sendToRemote(dataOut_1182.toArray());\n                return result_1183;\n            },\n            block: () => {\n                const dataOut_1187 = new aether_client_1.DataInOut();\n                dataOut_1187.writeByte(5);\n                const argsNames_1189 = [];\n                const argsValues_1190 = [];\n                const result_1188 = aether_client_1.AFuture.make();\n                sCtx_1175.invokeRemoteMethodAfter(\"block\", result_1188, argsNames_1189, argsValues_1190);\n                const reqId_1186 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1188.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_1188.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1187.writeInt(reqId_1186);\n                sCtx_1175.sendToRemote(dataOut_1187.toArray());\n                return result_1188;\n            },\n            getPosition: () => {\n                const dataOut_1192 = new aether_client_1.DataInOut();\n                dataOut_1192.writeByte(6);\n                const argsNames_1194 = [];\n                const argsValues_1195 = [];\n                const result_1193 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"getPosition\", result_1193, argsNames_1194, argsValues_1195);\n                const reqId_1191 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1193.tryDone(aether_api_1.Cloud.META.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1193.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1192.writeInt(reqId_1191);\n                sCtx_1175.sendToRemote(dataOut_1192.toArray());\n                return result_1193;\n            },\n            getParent: () => {\n                const dataOut_1197 = new aether_client_1.DataInOut();\n                dataOut_1197.writeByte(7);\n                const argsNames_1199 = [];\n                const argsValues_1200 = [];\n                const result_1198 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"getParent\", result_1198, argsNames_1199, argsValues_1200);\n                const reqId_1196 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1198.tryDone(aether_client_1.FastMeta.META_UUID.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1198.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1197.writeInt(reqId_1196);\n                sCtx_1175.sendToRemote(dataOut_1197.toArray());\n                return result_1198;\n            },\n            getBeneficiary: () => {\n                const dataOut_1202 = new aether_client_1.DataInOut();\n                dataOut_1202.writeByte(8);\n                const argsNames_1204 = [];\n                const argsValues_1205 = [];\n                const result_1203 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"getBeneficiary\", result_1203, argsNames_1204, argsValues_1205);\n                const reqId_1201 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1203.tryDone(aether_client_1.FastMeta.META_UUID.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1203.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1202.writeInt(reqId_1201);\n                sCtx_1175.sendToRemote(dataOut_1202.toArray());\n                return result_1203;\n            },\n            setBeneficiary: (uid) => {\n                const dataOut_1207 = new aether_client_1.DataInOut();\n                dataOut_1207.writeByte(9);\n                const argsNames_1209 = [\"uid\"];\n                const argsValues_1210 = [uid];\n                const result_1208 = aether_client_1.AFuture.make();\n                sCtx_1175.invokeRemoteMethodAfter(\"setBeneficiary\", result_1208, argsNames_1209, argsValues_1210);\n                const reqId_1206 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1208.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_1208.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1207.writeInt(reqId_1206);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1175, uid, dataOut_1207);\n                sCtx_1175.sendToRemote(dataOut_1207.toArray());\n                return result_1208;\n            },\n            getBlockTime: () => {\n                const dataOut_1212 = new aether_client_1.DataInOut();\n                dataOut_1212.writeByte(10);\n                const argsNames_1214 = [];\n                const argsValues_1215 = [];\n                const result_1213 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"getBlockTime\", result_1213, argsNames_1214, argsValues_1215);\n                const reqId_1211 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1213.tryDone(aether_client_1.FastMeta.META_DATE.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1213.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1212.writeInt(reqId_1211);\n                sCtx_1175.sendToRemote(dataOut_1212.toArray());\n                return result_1213;\n            },\n            unblock: () => {\n                const dataOut_1217 = new aether_client_1.DataInOut();\n                dataOut_1217.writeByte(11);\n                const argsNames_1219 = [];\n                const argsValues_1220 = [];\n                const result_1218 = aether_client_1.AFuture.make();\n                sCtx_1175.invokeRemoteMethodAfter(\"unblock\", result_1218, argsNames_1219, argsValues_1220);\n                const reqId_1216 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1218.tryDone();\n                    },\n                    onError: (_in_) => {\n                        result_1218.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1217.writeInt(reqId_1216);\n                sCtx_1175.sendToRemote(dataOut_1217.toArray());\n                return result_1218;\n            },\n            createTime: () => {\n                const dataOut_1222 = new aether_client_1.DataInOut();\n                dataOut_1222.writeByte(12);\n                const argsNames_1224 = [];\n                const argsValues_1225 = [];\n                const result_1223 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"createTime\", result_1223, argsNames_1224, argsValues_1225);\n                const reqId_1221 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1223.tryDone(aether_client_1.FastMeta.META_DATE.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1223.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1222.writeInt(reqId_1221);\n                sCtx_1175.sendToRemote(dataOut_1222.toArray());\n                return result_1223;\n            },\n            onlineTime: () => {\n                const dataOut_1227 = new aether_client_1.DataInOut();\n                dataOut_1227.writeByte(13);\n                const argsNames_1229 = [];\n                const argsValues_1230 = [];\n                const result_1228 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"onlineTime\", result_1228, argsNames_1229, argsValues_1230);\n                const reqId_1226 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1228.tryDone(aether_client_1.FastMeta.META_DATE.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1228.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1227.writeInt(reqId_1226);\n                sCtx_1175.sendToRemote(dataOut_1227.toArray());\n                return result_1228;\n            },\n            addAccessGroup: (groupId) => {\n                const dataOut_1232 = new aether_client_1.DataInOut();\n                dataOut_1232.writeByte(14);\n                const argsNames_1234 = [\"groupId\"];\n                const argsValues_1235 = [groupId];\n                const result_1233 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"addAccessGroup\", result_1233, argsNames_1234, argsValues_1235);\n                const reqId_1231 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1233.tryDone(aether_client_1.FastMeta.META_BOOLEAN.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1233.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1232.writeInt(reqId_1231);\n                dataOut_1232.writeLong(groupId);\n                sCtx_1175.sendToRemote(dataOut_1232.toArray());\n                return result_1233;\n            },\n            removeAccessGroup: (groupId) => {\n                const dataOut_1237 = new aether_client_1.DataInOut();\n                dataOut_1237.writeByte(15);\n                const argsNames_1239 = [\"groupId\"];\n                const argsValues_1240 = [groupId];\n                const result_1238 = aether_client_1.ARFuture.of();\n                sCtx_1175.invokeRemoteMethodAfter(\"removeAccessGroup\", result_1238, argsNames_1239, argsValues_1240);\n                const reqId_1236 = sCtx_1175.regFuture({\n                    onDone: (in_) => {\n                        result_1238.tryDone(aether_client_1.FastMeta.META_BOOLEAN.deserialize(sCtx_1175, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1238.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1237.writeInt(reqId_1236);\n                dataOut_1237.writeLong(groupId);\n                sCtx_1175.sendToRemote(dataOut_1237.toArray());\n                return result_1238;\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ServerApiByUidMetaImpl = ServerApiByUidMetaImpl;\nclass ClientApiRegSafeMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, _localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1241) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1241.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1241,\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ClientApiRegSafeMetaImpl = ClientApiRegSafeMetaImpl;\nclass GlobalRegClientApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, _localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1242) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1242.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1242,\n        };\n        return remoteApiImpl;\n    }\n}\nexports.GlobalRegClientApiMetaImpl = GlobalRegClientApiMetaImpl;\nclass ClientApiRegUnsafeMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let stream_1244;\n                    stream_1244 = aether_api_1.ClientApiRegSafeStream.META.deserialize(ctx, dataIn);\n                    const argsNames_1245 = [\"stream\"];\n                    const argsValues_1246 = [stream_1244];\n                    ctx.invokeLocalMethodBefore(\"enter\", argsNames_1245, argsValues_1246);\n                    localApi.enter(stream_1244);\n                    ctx.invokeLocalMethodAfter(\"enter\", null, argsNames_1245, argsValues_1246);\n                    break;\n                }\n                case 4: {\n                    let stream_1248;\n                    stream_1248 = aether_api_1.GlobalRegClientApiStream.META.deserialize(ctx, dataIn);\n                    const argsNames_1249 = [\"stream\"];\n                    const argsValues_1250 = [stream_1248];\n                    ctx.invokeLocalMethodBefore(\"enterGlobal\", argsNames_1249, argsValues_1250);\n                    localApi.enterGlobal(stream_1248);\n                    ctx.invokeLocalMethodAfter(\"enterGlobal\", null, argsNames_1249, argsValues_1250);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1251) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1251.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1251, enter: (stream) => {\n                const dataOut_1253 = new aether_client_1.DataInOut();\n                dataOut_1253.writeByte(3);\n                const argsNames_1255 = [\"stream\"];\n                const argsValues_1256 = [stream];\n                sCtx_1251.invokeRemoteMethodAfter(\"enter\", null, argsNames_1255, argsValues_1256);\n                aether_api_1.ClientApiRegSafeStream.META.serialize(sCtx_1251, stream, dataOut_1253);\n                sCtx_1251.sendToRemote(dataOut_1253.toArray());\n            },\n            enterGlobal: (stream) => {\n                const dataOut_1258 = new aether_client_1.DataInOut();\n                dataOut_1258.writeByte(4);\n                const argsNames_1260 = [\"stream\"];\n                const argsValues_1261 = [stream];\n                sCtx_1251.invokeRemoteMethodAfter(\"enterGlobal\", null, argsNames_1260, argsValues_1261);\n                aether_api_1.GlobalRegClientApiStream.META.serialize(sCtx_1251, stream, dataOut_1258);\n                sCtx_1251.sendToRemote(dataOut_1258.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ClientApiRegUnsafeMetaImpl = ClientApiRegUnsafeMetaImpl;\nclass GlobalRegServerApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let _key_1263;\n                    _key_1263 = aether_api_1.Key.META.deserialize(ctx, dataIn);\n                    const argsNames_1264 = [\"key\"];\n                    const argsValues_1265 = [_key_1263];\n                    ctx.invokeLocalMethodBefore(\"setMasterKey\", argsNames_1264, argsValues_1265);\n                    localApi.setMasterKey(_key_1263);\n                    ctx.invokeLocalMethodAfter(\"setMasterKey\", null, argsNames_1264, argsValues_1265);\n                    break;\n                }\n                case 4: {\n                    const reqId_1266 = dataIn.readInt();\n                    const argsNames_1267 = [];\n                    const argsValues_1268 = [];\n                    ctx.invokeLocalMethodBefore(\"finish\", argsNames_1267, argsValues_1268);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.finish();\n                    ctx.invokeLocalMethodAfter(\"finish\", resultFuture, argsNames_1267, argsValues_1268);\n                    resultFuture.to((v_1270) => {\n                        const data_1269 = new aether_client_1.DataInOut();\n                        aether_api_1.FinishResult.META.serialize(ctx, v_1270, data_1269);\n                        ctx.sendResultToRemote(reqId_1266, data_1269.toArray());\n                    });\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1271) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1271.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1271, setMasterKey: (key) => {\n                const dataOut_1273 = new aether_client_1.DataInOut();\n                dataOut_1273.writeByte(3);\n                const argsNames_1275 = [\"key\"];\n                const argsValues_1276 = [key];\n                sCtx_1271.invokeRemoteMethodAfter(\"setMasterKey\", null, argsNames_1275, argsValues_1276);\n                aether_api_1.Key.META.serialize(sCtx_1271, key, dataOut_1273);\n                sCtx_1271.sendToRemote(dataOut_1273.toArray());\n            },\n            finish: () => {\n                const dataOut_1278 = new aether_client_1.DataInOut();\n                dataOut_1278.writeByte(4);\n                const argsNames_1280 = [];\n                const argsValues_1281 = [];\n                const result_1279 = aether_client_1.ARFuture.of();\n                sCtx_1271.invokeRemoteMethodAfter(\"finish\", result_1279, argsNames_1280, argsValues_1281);\n                const reqId_1277 = sCtx_1271.regFuture({\n                    onDone: (in_) => {\n                        result_1279.tryDone(aether_api_1.FinishResult.META.deserialize(sCtx_1271, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1279.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1278.writeInt(reqId_1277);\n                sCtx_1271.sendToRemote(dataOut_1278.toArray());\n                return result_1279;\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.GlobalRegServerApiMetaImpl = GlobalRegServerApiMetaImpl;\nclass ServerRegistrationApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let salt_1283;\n                    let suffix_1284;\n                    let passwords_1285;\n                    let parent_1286;\n                    let globalApi_1287;\n                    let stringBytes_1288;\n                    const len_1290 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    const bytes_1291 = dataIn.readBytes(len_1290);\n                    stringBytes_1288 = bytes_1291;\n                    salt_1283 = new TextDecoder('utf-8').decode(stringBytes_1288);\n                    let stringBytes_1292;\n                    const len_1294 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    const bytes_1295 = dataIn.readBytes(len_1294);\n                    stringBytes_1292 = bytes_1295;\n                    suffix_1284 = new TextDecoder('utf-8').decode(stringBytes_1292);\n                    const len_1297 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn));\n                    passwords_1285 = new Array(len_1297);\n                    for (let idx_1296 = 0; idx_1296 < len_1297; idx_1296++) {\n                        passwords_1285[idx_1296] = dataIn.readInt();\n                    }\n                    parent_1286 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    globalApi_1287 = aether_api_1.GlobalApi.META.deserialize(ctx, dataIn);\n                    const argsNames_1298 = [\"salt\", \"suffix\", \"passwords\", \"parent\", \"globalApi\"];\n                    const argsValues_1299 = [salt_1283, suffix_1284, passwords_1285, parent_1286, globalApi_1287];\n                    ctx.invokeLocalMethodBefore(\"registration\", argsNames_1298, argsValues_1299);\n                    localApi.registration(salt_1283, suffix_1284, passwords_1285, parent_1286, globalApi_1287);\n                    ctx.invokeLocalMethodAfter(\"registration\", null, argsNames_1298, argsValues_1299);\n                    break;\n                }\n                case 4: {\n                    const reqId_1300 = dataIn.readInt();\n                    let parent_1301;\n                    let powMethods_1302;\n                    parent_1301 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    powMethods_1302 = aether_api_1.PowMethod.META.deserialize(ctx, dataIn);\n                    const argsNames_1303 = [\"parent\", \"powMethods\"];\n                    const argsValues_1304 = [parent_1301, powMethods_1302];\n                    ctx.invokeLocalMethodBefore(\"requestWorkProofData\", argsNames_1303, argsValues_1304);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.requestWorkProofData(parent_1301, powMethods_1302);\n                    ctx.invokeLocalMethodAfter(\"requestWorkProofData\", resultFuture, argsNames_1303, argsValues_1304);\n                    resultFuture.to((v_1306) => {\n                        const data_1305 = new aether_client_1.DataInOut();\n                        aether_api_1.WorkProofDTO.META.serialize(ctx, v_1306, data_1305);\n                        ctx.sendResultToRemote(reqId_1300, data_1305.toArray());\n                    });\n                    break;\n                }\n                case 5: {\n                    const reqId_1307 = dataIn.readInt();\n                    let serverIds_1308;\n                    serverIds_1308 = aether_api_1.Cloud.META.deserialize(ctx, dataIn);\n                    const argsNames_1309 = [\"serverIds\"];\n                    const argsValues_1310 = [serverIds_1308];\n                    ctx.invokeLocalMethodBefore(\"resolveServers\", argsNames_1309, argsValues_1310);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.resolveServers(serverIds_1308);\n                    ctx.invokeLocalMethodAfter(\"resolveServers\", resultFuture, argsNames_1309, argsValues_1310);\n                    resultFuture.to((v_1312) => {\n                        const data_1311 = new aether_client_1.DataInOut();\n                        aether_client_1.SerializerPackNumber.INSTANCE.put(data_1311, v_1312.length);\n                        for (const el_1313 of v_1312) {\n                            aether_api_1.ServerDescriptor.META.serialize(ctx, el_1313, data_1311);\n                        }\n                        ctx.sendResultToRemote(reqId_1307, data_1311.toArray());\n                    });\n                    break;\n                }\n                case 6: {\n                    let _key_1315;\n                    _key_1315 = aether_api_1.Key.META.deserialize(ctx, dataIn);\n                    const argsNames_1316 = [\"key\"];\n                    const argsValues_1317 = [_key_1315];\n                    ctx.invokeLocalMethodBefore(\"setReturnKey\", argsNames_1316, argsValues_1317);\n                    localApi.setReturnKey(_key_1315);\n                    ctx.invokeLocalMethodAfter(\"setReturnKey\", null, argsNames_1316, argsValues_1317);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1318) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1318.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1318, registration: (salt, suffix, passwords, parent, globalApi) => {\n                const dataOut_1320 = new aether_client_1.DataInOut();\n                dataOut_1320.writeByte(3);\n                const argsNames_1322 = [\"salt\", \"suffix\", \"passwords\", \"parent\", \"globalApi\"];\n                const argsValues_1323 = [salt, suffix, passwords, parent, globalApi];\n                sCtx_1318.invokeRemoteMethodAfter(\"registration\", null, argsNames_1322, argsValues_1323);\n                const stringBytes_1324 = new TextEncoder().encode(salt);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1320, stringBytes_1324.length);\n                dataOut_1320.write(stringBytes_1324);\n                const stringBytes_1326 = new TextEncoder().encode(suffix);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1320, stringBytes_1326.length);\n                dataOut_1320.write(stringBytes_1326);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_1320, passwords.length);\n                for (const el_1328 of passwords) {\n                    dataOut_1320.writeInt(el_1328);\n                }\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1318, parent, dataOut_1320);\n                aether_api_1.GlobalApi.META.serialize(sCtx_1318, globalApi, dataOut_1320);\n                sCtx_1318.sendToRemote(dataOut_1320.toArray());\n            },\n            requestWorkProofData: (parent, powMethods) => {\n                const dataOut_1330 = new aether_client_1.DataInOut();\n                dataOut_1330.writeByte(4);\n                const argsNames_1332 = [\"parent\", \"powMethods\"];\n                const argsValues_1333 = [parent, powMethods];\n                const result_1331 = aether_client_1.ARFuture.of();\n                sCtx_1318.invokeRemoteMethodAfter(\"requestWorkProofData\", result_1331, argsNames_1332, argsValues_1333);\n                const reqId_1329 = sCtx_1318.regFuture({\n                    onDone: (in_) => {\n                        result_1331.tryDone(aether_api_1.WorkProofDTO.META.deserialize(sCtx_1318, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1331.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1330.writeInt(reqId_1329);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_1318, parent, dataOut_1330);\n                aether_api_1.PowMethod.META.serialize(sCtx_1318, powMethods, dataOut_1330);\n                sCtx_1318.sendToRemote(dataOut_1330.toArray());\n                return result_1331;\n            },\n            resolveServers: (serverIds) => {\n                const dataOut_1335 = new aether_client_1.DataInOut();\n                dataOut_1335.writeByte(5);\n                const argsNames_1337 = [\"serverIds\"];\n                const argsValues_1338 = [serverIds];\n                const result_1336 = aether_client_1.ARFuture.of();\n                sCtx_1318.invokeRemoteMethodAfter(\"resolveServers\", result_1336, argsNames_1337, argsValues_1338);\n                const reqId_1334 = sCtx_1318.regFuture({\n                    onDone: (in_) => {\n                        result_1336.tryDone(aether_client_1.FastMeta.getMetaArray(aether_api_1.ServerDescriptor.META).deserialize(sCtx_1318, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1336.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1335.writeInt(reqId_1334);\n                aether_api_1.Cloud.META.serialize(sCtx_1318, serverIds, dataOut_1335);\n                sCtx_1318.sendToRemote(dataOut_1335.toArray());\n                return result_1336;\n            },\n            setReturnKey: (key) => {\n                const dataOut_1340 = new aether_client_1.DataInOut();\n                dataOut_1340.writeByte(6);\n                const argsNames_1342 = [\"key\"];\n                const argsValues_1343 = [key];\n                sCtx_1318.invokeRemoteMethodAfter(\"setReturnKey\", null, argsNames_1342, argsValues_1343);\n                aether_api_1.Key.META.serialize(sCtx_1318, key, dataOut_1340);\n                sCtx_1318.sendToRemote(dataOut_1340.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.ServerRegistrationApiMetaImpl = ServerRegistrationApiMetaImpl;\nclass RegistrationRootApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    const reqId_1344 = dataIn.readInt();\n                    let cryptoLib_1345;\n                    cryptoLib_1345 = aether_api_1.CryptoLib.META.deserialize(ctx, dataIn);\n                    const argsNames_1346 = [\"cryptoLib\"];\n                    const argsValues_1347 = [cryptoLib_1345];\n                    ctx.invokeLocalMethodBefore(\"getAsymmetricPublicKey\", argsNames_1346, argsValues_1347);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getAsymmetricPublicKey(cryptoLib_1345);\n                    ctx.invokeLocalMethodAfter(\"getAsymmetricPublicKey\", resultFuture, argsNames_1346, argsValues_1347);\n                    resultFuture.to((v_1349) => {\n                        const data_1348 = new aether_client_1.DataInOut();\n                        aether_api_1.SignedKey.META.serialize(ctx, v_1349, data_1348);\n                        ctx.sendResultToRemote(reqId_1344, data_1348.toArray());\n                    });\n                    break;\n                }\n                case 4: {\n                    let cryptoLib_1351;\n                    let stream_1352;\n                    cryptoLib_1351 = aether_api_1.CryptoLib.META.deserialize(ctx, dataIn);\n                    stream_1352 = aether_api_1.ServerRegistrationApiStream.META.deserialize(ctx, dataIn);\n                    const argsNames_1353 = [\"cryptoLib\", \"stream\"];\n                    const argsValues_1354 = [cryptoLib_1351, stream_1352];\n                    ctx.invokeLocalMethodBefore(\"enter\", argsNames_1353, argsValues_1354);\n                    localApi.enter(cryptoLib_1351, stream_1352);\n                    ctx.invokeLocalMethodAfter(\"enter\", null, argsNames_1353, argsValues_1354);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_1355) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_1355.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_1355, getAsymmetricPublicKey: (cryptoLib) => {\n                const dataOut_1357 = new aether_client_1.DataInOut();\n                dataOut_1357.writeByte(3);\n                const argsNames_1359 = [\"cryptoLib\"];\n                const argsValues_1360 = [cryptoLib];\n                const result_1358 = aether_client_1.ARFuture.of();\n                sCtx_1355.invokeRemoteMethodAfter(\"getAsymmetricPublicKey\", result_1358, argsNames_1359, argsValues_1360);\n                const reqId_1356 = sCtx_1355.regFuture({\n                    onDone: (in_) => {\n                        result_1358.tryDone(aether_api_1.SignedKey.META.deserialize(sCtx_1355, in_));\n                    },\n                    onError: (_in_) => {\n                        result_1358.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_1357.writeInt(reqId_1356);\n                aether_api_1.CryptoLib.META.serialize(sCtx_1355, cryptoLib, dataOut_1357);\n                sCtx_1355.sendToRemote(dataOut_1357.toArray());\n                return result_1358;\n            },\n            enter: (cryptoLib, stream) => {\n                const dataOut_1362 = new aether_client_1.DataInOut();\n                dataOut_1362.writeByte(4);\n                const argsNames_1364 = [\"cryptoLib\", \"stream\"];\n                const argsValues_1365 = [cryptoLib, stream];\n                sCtx_1355.invokeRemoteMethodAfter(\"enter\", null, argsNames_1364, argsValues_1365);\n                aether_api_1.CryptoLib.META.serialize(sCtx_1355, cryptoLib, dataOut_1362);\n                aether_api_1.ServerRegistrationApiStream.META.serialize(sCtx_1355, stream, dataOut_1362);\n                sCtx_1355.sendToRemote(dataOut_1362.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.RegistrationRootApiMetaImpl = RegistrationRootApiMetaImpl;\n//# sourceMappingURL=aether_api_impl.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_api_impl.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_astring.js":
/*!************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_astring.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_astring.ts\n// PURPOSE: A powerful string builder implementation supporting type-specific renderers,\n// ported from the AString.java implementation. (FIXED: Corrected TS overloads)\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AString = exports.Style2 = exports.BackgroundColor = exports.Color = exports.Style = void 0;\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\n/**\n * @file JSDoc mock for Java's java.text.DateFormat.\n */\nconst DATE_FORMAT = {\n    /**\n     * Formats a Date object.\n     * @param {Date} v The date.\n     * @returns {string} The formatted string.\n     */\n    format: (v) => {\n        // \"MM:dd:HH:mm:ss.SSSS\"\n        const p = (n, l = 2) => String(n).padStart(l, '0');\n        return `${p(v.getMonth() + 1)}:${p(v.getDate())}:${p(v.getHours())}:${p(v.getMinutes())}:${p(v.getSeconds())}.${p(v.getMilliseconds(), 4)}`;\n    }\n};\n/**\n * @file JSDoc mock for Java's java.io.Writer.\n */\nclass Writer {\n    /**\n     * Writes a portion of an array of characters.\n     * @param {string} str The string buffer.\n     * @param {number} off Offset from which to start writing characters.\n     * @param {number} len Number of characters to write.\n     */\n    write(str, off, len) {\n        // Mock implementation, subclasses should override\n    }\n    /** Flushes the stream. */\n    flush() { }\n    /** Closes the stream. */\n    close() { }\n}\n/**\n * @file JSDoc mock for Java's java.io.PrintWriter.\n */\nclass PrintWriter {\n    writer;\n    /**\n     * @param {Writer} writer The writer to delegate to.\n     */\n    constructor(writer) {\n        this.writer = writer;\n    }\n    /**\n     * Prints the stack trace of an error.\n     * @param {Error} e The error.\n     */\n    printStackTrace(e) {\n        const stack = e.stack ?? `${e.name}: ${e.message}`;\n        this.writer.write(stack, 0, stack.length);\n    }\n}\n/**\n * @file JSDoc mock for Java's HexUtils.\n */\nconst HexUtils = {\n    /**\n     * Converts bytes to a hex string and appends to an AString.\n     * @param {Uint8Array | number} val The value to convert.\n     * @param {number | AString} offsetOrSb Start offset or the AString builder.\n     * @param {number} [len] The length to read.\n     * @param {AString} [sb] The AString builder.\n     */\n    toHexString: (val, offsetOrSb, len, sb) => {\n        let aString;\n        let str;\n        if (typeof val === 'number') {\n            // This is the overload used by UUID: toHexString(long val, AString sb)\n            aString = offsetOrSb;\n            // Simulate extracting the last byte\n            str = (val & 0xFF).toString(16).padStart(2, '0');\n        }\n        else {\n            // This is the overload for byte[]\n            aString = (sb ?? offsetOrSb);\n            const offset = (sb ? offsetOrSb : 0);\n            const end = offset + (len ?? val.length);\n            const slice = val.slice(offset, end);\n            str = Array.from(slice).map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        if (aString) {\n            aString.add(str);\n        }\n    }\n};\n/**\n * @file JSDoc mock for Java's RU utility class.\n */\nconst RU = {\n    /**\n     * Casts a value to a given type. (Mock implementation)\n     * @template T\n     * @param {any} v The value to cast.\n     * @returns {T} The casted value.\n     */\n    cast: (v) => v,\n};\n/**\n * @file JSDoc mock for Java's Objects.equals.\n */\nconst Objects = {\n    /**\n     * Checks if two values are equal.\n     * @param {any} a The first value.\n     * @param {any} b The second value.\n     * @returns {boolean} True if equal.\n     */\n    equals: (a, b) => a === b,\n};\n/**\n * @file JSDoc utility for checking Java identifier parts.\n */\nconst Character = {\n    /**\n     * Checks if a character is a valid part of a Java identifier.\n     * @param {string} char The character to check.\n     * @returns {boolean} True if it is.\n     */\n    isJavaIdentifierPart: (char) => {\n        return char.length === 1 && /[a-zA-Z0-9_$]/.test(char);\n    }\n};\n// --- Enums Ported from AString.java ---\n/**\n * ANSI SGR (Select Graphic Rendition) style codes.\n */\nvar Style;\n(function (Style) {\n    Style[Style[\"CLEAR\"] = 0] = \"CLEAR\";\n    Style[Style[\"BRIGHT\"] = 1] = \"BRIGHT\";\n    Style[Style[\"DIM\"] = 2] = \"DIM\";\n    Style[Style[\"ITALIC\"] = 3] = \"ITALIC\";\n    Style[Style[\"UNDERSCORE\"] = 4] = \"UNDERSCORE\";\n    Style[Style[\"BLINK\"] = 5] = \"BLINK\";\n    Style[Style[\"UNKNOWN1\"] = 6] = \"UNKNOWN1\";\n    Style[Style[\"REVERSE\"] = 7] = \"REVERSE\";\n    Style[Style[\"HIDDEN\"] = 8] = \"HIDDEN\";\n    Style[Style[\"UNKNOWN2\"] = 9] = \"UNKNOWN2\";\n    Style[Style[\"CROSSED\"] = 10] = \"CROSSED\";\n})(Style || (exports.Style = Style = {}));\n/**\n * Basic 8-bit ANSI foreground colors.\n */\nvar Color;\n(function (Color) {\n    Color[\"BLACK\"] = \"30\";\n    Color[\"RED\"] = \"31\";\n    Color[\"GREEN\"] = \"32\";\n    Color[\"ORANGE\"] = \"33\";\n    Color[\"BLUE\"] = \"34\";\n    Color[\"PURPLE\"] = \"35\";\n    Color[\"CYAN\"] = \"36\";\n    Color[\"WHITE\"] = \"37\";\n})(Color || (exports.Color = Color = {}));\n/**\n * Basic 8-bit ANSI background colors.\n */\nvar BackgroundColor;\n(function (BackgroundColor) {\n    BackgroundColor[\"BLACK\"] = \"40\";\n    BackgroundColor[\"RED\"] = \"41\";\n    BackgroundColor[\"GREEN\"] = \"42\";\n    BackgroundColor[\"ORANGE\"] = \"43\";\n    BackgroundColor[\"BLUE\"] = \"44\";\n    BackgroundColor[\"PURPLE\"] = \"45\";\n    BackgroundColor[\"CYAN\"] = \"46\";\n    BackgroundColor[\"WHITE\"] = \"47\";\n})(BackgroundColor || (exports.BackgroundColor = BackgroundColor = {}));\n/**\n * Additional ANSI style codes.\n */\nvar Style2;\n(function (Style2) {\n    Style2[\"UNDERSCORE_DOUBLE\"] = \"21\";\n    Style2[\"BORDER\"] = \"51\";\n    Style2[\"BORDER2\"] = \"52\";\n    Style2[\"UNDERSCORE2\"] = \"53\";\n})(Style2 || (exports.Style2 = Style2 = {}));\n// --- AString Class ---\n/**\n * A mutable sequence of characters, providing a powerful and fluent API\n * for string manipulation, formatting, and ANSI styling.\n *\n * This class merges the AString interface and the Simple implementation from Java.\n */\nclass AString {\n    /**\n     * The internal parts of the string.\n     * @private\n     */\n    parts = [];\n    /**\n     * A cache for the .toString() result.\n     * @private\n     */\n    _stringCache = null;\n    /**\n     * Private constructor. Use AString.of() to create instances.\n     */\n    constructor() {\n        // private\n    }\n    /**\n     * Creates a new, empty AString instance.\n     * @returns {AString} A new AString.\n     */\n    static of() {\n        return new AString();\n    }\n    // --- CharSequence Implementation ---\n    /**\n     * Gets the current length of the string.\n     * @returns {number} The length.\n     */\n    get length() {\n        return this.toString().length;\n    }\n    /**\n     * Gets the character at the specified index.\n     * @param {number} index The index.\n     * @returns {string} The character (as a string).\n     */\n    charAt(index) {\n        return this.toString().charAt(index);\n    }\n    /**\n     * Returns a new string that is a subsequence of this sequence.\n     * @param {number} start The start index, inclusive.\n     * @param {number} end The end index, exclusive.\n     * @returns {string} The subsequence.\n     */\n    subSequence(start, end) {\n        return this.toString().substring(start, end);\n    }\n    /**\n     * Returns the full string value.\n     * @returns {string} The concatenated string.\n     */\n    toString() {\n        if (this._stringCache === null) {\n            this._stringCache = this.parts.join('');\n        }\n        return this._stringCache;\n    }\n    /**\n     * Appends a value to the string.\n     * This is the single implementation for all 'add' overloads.\n     * @param {unknown} val The value to add.\n     * @param {number} [offset] Optional start index (for string/array).\n     * @param {number} [len] Optional length (for string/array).\n     * @returns {AString} This AString instance for chaining.\n     */\n    add(val, offset, len) {\n        // Handle add(val, offset, len) cases first\n        if (offset !== undefined && len !== undefined) {\n            if (typeof val === 'string') {\n                // add(CharSequence val, int offset, int len)\n                const sub = val.substring(offset, offset + len);\n                if (sub) {\n                    this.parts.push(sub);\n                    this._stringCache = null;\n                }\n                return this;\n            }\n            if (Array.isArray(val) && val.every(item => typeof item === 'string')) {\n                // add(char[] val, int offset, int len)\n                const sub = val.slice(offset, offset + len).join('');\n                if (sub) {\n                    this.parts.push(sub);\n                    this._stringCache = null;\n                }\n                return this;\n            }\n            // If offset/len are passed with an invalid type, ignore them and fall through\n        }\n        // --- Handle add(val) cases ---\n        if (val == null) {\n            return this.addNull();\n        }\n        const type = typeof val;\n        // add(CharSequence val) / add(String val) / add(char val)\n        if (type === 'string') {\n            if (val) {\n                this.parts.push(val);\n                this._stringCache = null;\n            }\n            return this;\n        }\n        // add(int val), add(boolean val), add(bigint val)\n        if (type === 'number' || type === 'boolean' || type === 'bigint') {\n            const str = String(val);\n            this.parts.push(str);\n            this._stringCache = null;\n            return this;\n        }\n        // --- Handle Objects ---\n        // add(ToString val)\n        // Check for our specific ToString interface (1 arg) vs. JS default (0 args)\n        if (typeof val.toString === 'function' && val.toString.length === 1) {\n            if (val.constructor !== String) {\n                try {\n                    val.toString(this);\n                    return this;\n                }\n                catch (e) {\n                    // Fallback to default renderer\n                }\n            }\n        }\n        // add(byte[] val)\n        if (val instanceof Uint8Array) {\n            HexUtils.toHexString(val, 0, val.length, this);\n            return this;\n        }\n        // add(Object[] val) / add(int[] val) / add(char[] val)\n        if (Array.isArray(val)) {\n            let first = true;\n            let joiner = \", \"; // Default for Object[]\n            // Check for primitive arrays\n            if (val.every(item => typeof item === 'number')) {\n                joiner = \",\"; // For int[], float[], etc.\n            }\n            else if (val.every(item => typeof item === 'string' && item.length === 1)) {\n                // This is add(char[] val)\n                const str = val.join('');\n                if (str) {\n                    this.parts.push(str);\n                    this._stringCache = null;\n                }\n                return this;\n            }\n            if (val.length === 0)\n                return this;\n            for (const j of val) {\n                if (first)\n                    first = false;\n                else\n                    this.add(joiner); // Note: This is a recursive call to add(string)\n                this.add(j); // Recursive call to handle each item\n            }\n            return this;\n        }\n        // add(Iterable<?> val)\n        if (typeof val[Symbol.iterator] === 'function') {\n            let first = true;\n            for (const e of val) {\n                if (first)\n                    first = false;\n                else\n                    this.add(\",\"); // Note: recursive call\n                this.add(e); // Recursive call\n            }\n            return this;\n        }\n        // add(Object val) - Fallback to renderer system\n        const ctor = val.constructor;\n        this.getLocalRenderer(ctor)(RU.cast(val), this);\n        return this;\n    }\n    // --- Other Methods (from AString interface) ---\n    /**\n     * Returns a wrapper around this AString that limits output to a specific length.\n     * @param {number} count The maximum number of characters to add.\n     * @returns {AString} A new, limiting AString wrapper.\n     */\n    limit(count) {\n        return new AStringLimiter(this, count);\n    }\n    /**\n     * Appends a number of space characters.\n     * @param {number} count The number of spaces.\n     * @returns {AString} This AString instance for chaining.\n     */\n    addSpace(count) {\n        if (count <= 0)\n            return this;\n        this.add(\" \".repeat(count));\n        return this;\n    }\n    /**\n     * Repeats and appends a value multiple times.\n     * @param {number} count The number of times to repeat.\n     * @param {unknown} val The value to append (char, string, or object).\n     * @returns {AString} This AString instance for chaining.\n     */\n    repeat(count, val) {\n        for (let i = 0; i < count; i++) {\n            this.add(val);\n        }\n        return this;\n    }\n    /**\n     * Calculates the number of visible symbols (ignoring ANSI codes).\n     * @param {number} begin The start index.\n     * @param {number} [end] The end index (defaults to current length).\n     * @returns {number} The count of visible symbols.\n     */\n    calcVisibleSymbols(begin, end) {\n        const e = end ?? this.length;\n        if (e > this.length) {\n            throw new Error(\"End index out of bounds\");\n        }\n        let i = 0;\n        const s = this.toString(); // Work on the full string\n        while (begin < e) {\n            if (s.charAt(begin) === '\\u001B') {\n                while (begin < e && s.charAt(begin) !== 'm')\n                    begin++;\n            }\n            else {\n                i++;\n            }\n            begin++;\n        }\n        return i;\n    }\n    /**\n     * Appends the ANSI code to clear all styles.\n     * @returns {AString} This AString instance for chaining.\n     */\n    styleClear() {\n        return this.add(\"\\u001B[0m\");\n    }\n    /**\n     * Appends ANSI codes for 24-bit RGB foreground color.\n     * @param {Style | null} mode A style (e.g., BRIGHT) or null.\n     * @param {number} red Red component (0-255).\n     * @param {number} green Green component (0-255).\n     * @param {number} blue Blue component (0-255).\n     * @returns {AString} This AString instance for chaining.\n     */\n    styleForeground(mode, red, green, blue) {\n        this.add(\"\\u001B[\");\n        if (mode != null) {\n            this.add(String(mode)).add(\";\");\n        }\n        this.add(\"38;2;\").add(String(red)).add(\";\").add(String(green)).add(\";\").add(String(blue)).add(\"m\");\n        return this;\n    }\n    /**\n     * Appends ANSI codes for 24-bit RGB background color.\n     * @param {Style | null} mode A style (e.g., BRIGHT) or null.\n     * @param {number} red Red component (0-255).\n     * @param {number} green Green component (0-255).\n     * @param {number} blue Blue component (0-255).\n     * @returns {AString} This AString instance for chaining.\n     */\n    styleBackground(mode, red, green, blue) {\n        this.add(\"\\u001B[\");\n        if (mode != null) {\n            this.add(String(mode)).add(\";\");\n        }\n        this.add(\"48;2;\").add(String(red)).add(\";\").add(String(green)).add(\";\").add(String(blue)).add(\"m\");\n        return this;\n    }\n    /**\n     * Appends an ANSI code for a basic color.\n     * @param {Color} color The color enum.\n     * @returns {AString} This AString instance for chaining.\n     */\n    color(color) {\n        this.add(\"\\u001B[\").add(color).add(\"m\");\n        return this;\n    }\n    /**\n     * Appends ANSI codes for style and basic color.\n     * @param {Style | null} mode A style or null.\n     * @param {Color} [color] An optional color.\n     * @returns {AString} This AString instance for chaining.\n     */\n    style(mode, color) {\n        if (color == null && mode != null) {\n            return this.add(\"\\u001B[\").add(String(mode)).add(\"m\");\n        }\n        this.add(\"\\u001B[\");\n        if (mode != null) {\n            this.add(String(mode)).add(\";\");\n        }\n        if (color) {\n            this.add(color);\n        }\n        this.add(\"m\");\n        return this;\n    }\n    /**\n     * Gets the renderer for a given class.\n     * @template T\n     * @param {any} cl The class constructor.\n     * @returns {ABiConsumer<T, AString>} The renderer.\n     */\n    getLocalRenderer(cl) {\n        return AString.getRenderer(cl);\n    }\n    /**\n     * Appends \"null\".\n     * @returns {AString} This AString instance for chaining.\n     */\n    addNull() {\n        this.add(\"null\");\n        return this;\n    }\n    /**\n     * Appends the stack trace of an error.\n     * @param {Error} e The error.\n     * @returns {AString} This AString instance for chaining.\n     */\n    addStackTrace(e) {\n        this.toPrintWriter().printStackTrace(e);\n        return this;\n    }\n    /**\n     * Finds the first index of a character sequence.\n     * @param {string} c The sequence to find.\n     * @param {number} [offset] The index to start searching from.\n     * @returns {number} The index, or -1 if not found.\n     */\n    indexOf(c, offset = 0) {\n        if (c == null)\n            return -1;\n        // Use native toString() and indexOf()\n        return this.toString().indexOf(c, offset);\n    }\n    /**\n     * Creates a PrintWriter that writes to this AString.\n     * @returns {PrintWriter} The PrintWriter instance.\n     */\n    toPrintWriter() {\n        const self = this;\n        class AStringWriter extends Writer {\n            write(str, off, len) {\n                self.add(str.substring(off, off + len));\n            }\n        }\n        return new PrintWriter(new AStringWriter());\n    }\n    /**\n     * Implementation for addVars.\n     */\n    addVars(msg, fOrVars, ...restVars) {\n        let f;\n        if (typeof fOrVars === 'function' && restVars.length === 0) {\n            f = fOrVars;\n        }\n        else {\n            const vars = [fOrVars, ...restVars];\n            f = (v) => {\n                for (let i = 0; i < vars.length; i += 2) {\n                    if (Objects.equals(vars[i], v)) {\n                        return vars[i + 1];\n                    }\n                }\n                return null;\n            };\n        }\n        let vi = msg.indexOf('$');\n        if (vi === -1) {\n            this.add(msg);\n            return this;\n        }\n        let start = 0;\n        while (true) {\n            let vEnd = vi + 1;\n            this.add(msg.substring(start, vi)); // Add text before '$'\n            while (vEnd < msg.length && Character.isJavaIdentifierPart(msg.charAt(vEnd))) {\n                vEnd++;\n            }\n            const key = msg.substring(vi + 1, vEnd);\n            const v = f(key);\n            if (v != null) {\n                try {\n                    this.add(v);\n                }\n                catch (e) {\n                    try {\n                        this.add(\"[[error]]: \").add(String(v));\n                    }\n                    catch (e2) {\n                        this.add(\"[[error]]\");\n                    }\n                }\n            }\n            start = vEnd;\n            let nextVi = msg.indexOf('$', start);\n            if (nextVi === -1) {\n                break;\n            }\n            vi = nextVi;\n        }\n        const l = msg.length - start;\n        if (l > 0)\n            this.add(msg.substring(start, start + l));\n        return this;\n    }\n    /**\n     * Replaces all occurrences of a character in a source string and appends the result.\n     * @param {string} src The source string.\n     * @param {string} sample The character to replace (must be length 1).\n     * @param {string} s The replacement string.\n     * @returns {AString} This AString instance for chaining.\n     */\n    replaceAll(src, sample, s) {\n        if (sample.length !== 1) {\n            throw new Error(\"Sample must be a single character\");\n        }\n        // Use native replaceAll\n        this.add(src.replaceAll(sample, s));\n        return this;\n    }\n    /**\n     * Returns a wrapper that limits the size of byte arrays when printed.\n     * @param {number} max The maximum number of bytes to print.\n     * @returns {AString} A new, limiting AString wrapper.\n     */\n    limitByteArrays(max) {\n        return new LimitByteArrays(this, max);\n    }\n    /**\n     * Gets the full string content as a UTF-8 byte array.\n     * @returns {Uint8Array} The byte array.\n     */\n    getBytes() {\n        return new TextEncoder().encode(this.toString());\n    }\n    /**\n     * Appends text with alignment and indentation.\n     * @param {number} width The total line width.\n     * @param {number} firstIndent Indentation for the first line.\n     * @param {number} indent Indentation for subsequent lines.\n     * @param {string} txt The text to add.\n     * @returns {AString} This AString instance for chaining.\n     */\n    addWithAlign(width, firstIndent, indent, txt) {\n        const text = txt.split(\" \");\n        let i = 0;\n        let line = 0;\n        // Corrected logic for first line indent\n        this.addSpace(firstIndent);\n        line += firstIndent;\n        while (i < text.length) {\n            const word = text[i];\n            const wordLen = word.length;\n            // Check if word fits on the current line\n            // We need a space if we are not at the very beginning of a line\n            const needsSpace = (line > indent) || (line > firstIndent && i > 0);\n            const space = needsSpace ? 1 : 0;\n            if (line === indent || (line === firstIndent && i === 0) || (line + space + wordLen <= width)) {\n                if (needsSpace) {\n                    this.add(\" \");\n                    line += 1;\n                }\n                this.add(word);\n                line += wordLen;\n            }\n            else {\n                // New line\n                line = 0;\n                this.add(\"\\n\");\n                this.addSpace(indent);\n                line += indent;\n                this.add(word); // Add the word that didn't fit\n                line += wordLen;\n            }\n            i++;\n        }\n        this.add(\"\\n\");\n        return this;\n    }\n    // --- Static Renderer System ---\n    /**\n     * The default renderer, converts any value to a string.\n     * @type {ABiConsumer<any, AString>}\n     */\n    static DEFAULT_RENDERER = (v, s) => s.add(String(v));\n    /**\n     * The central map of type constructors to their rendering functions.\n     * @type {Map<any, ABiConsumer<any, AString>>}\n     * @private\n     */\n    static renderers = new Map();\n    /**\n     * Registers a renderer for a specific class/constructor.\n     * @template T\n     * @param {any} cl The class constructor (e.g., Date, MyClass).\n     * @param {ABiConsumer<T, AString>} f The rendering function.\n     */\n    static putRenderer(cl, f) {\n        AString.renderers.set(cl, f);\n    }\n    /**\n     * Alias for putRenderer.\n     * @template T\n     * @param {any} type The class constructor.\n     * @param {ABiConsumer<T, AString>} renderer The rendering function.\n     */\n    static addRenderer(type, renderer) {\n        AString.renderers.set(type, renderer);\n    }\n    /**\n     * Retrieves the renderer for a given type, traversing prototypes.\n     * @template T\n     * @param {any} type The class constructor.\n     * @returns {ABiConsumer<T, AString>} The found renderer or the default renderer.\n     */\n    static getRenderer(type) {\n        if (type == null) {\n            return RU.cast(AString.DEFAULT_RENDERER);\n        }\n        let renderer = AString.renderers.get(type);\n        if (renderer != null) {\n            return RU.cast(renderer);\n        }\n        // In JS, arrays don't have a distinct class like `Object[]`\n        if (type === Array) {\n            renderer = (v, s) => s.add(v);\n        }\n        else {\n            // Traverse prototype chain\n            let currentProto = Object.getPrototypeOf(type.prototype);\n            while (currentProto && currentProto.constructor !== Object) {\n                renderer = AString.renderers.get(currentProto.constructor);\n                if (renderer)\n                    break;\n                currentProto = Object.getPrototypeOf(currentProto);\n            }\n            if (!renderer) {\n                renderer = AString.DEFAULT_RENDERER;\n            }\n        }\n        AString.renderers.set(type, renderer);\n        return RU.cast(renderer);\n    }\n    /**\n     * Static initializer block to register default renderers.\n     */\n    static {\n        const put = AString.putRenderer;\n        // Primitives and basic types\n        put(String, (v, s) => s.add(v));\n        put(Number, (v, s) => s.add(String(v)));\n        put(Boolean, (v, s) => s.add(String(v)));\n        put(BigInt, (v, s) => s.add(String(v)));\n        put(Date, (v, s) => s.add(DATE_FORMAT.format(v)));\n        // Arrays\n        put(Uint8Array, (v, s) => s.add(v));\n        put(Array, (v, s) => s.add(v)); // Handles Object[]\n        // Special classes\n        put(Error, (v, s) => {\n            s.add(v.name).add(\"(\");\n            if (v.message) {\n                s.add(v.message);\n            }\n            s.add(\")\");\n        });\n        // Mock for SoftReference -> WeakRef\n        if (typeof WeakRef !== 'undefined') {\n            put(WeakRef, (v, s) => {\n                const vv = v.deref();\n                s.add(vv);\n            });\n        }\n        // Handle AtomicReference\n        put(aether_types_1.AtomicReference, (v, s) => {\n            const vv = v.get();\n            s.add(vv);\n        });\n    }\n}\nexports.AString = AString;\n// --- Internal Wrapper Classes ---\n/**\n * An AString wrapper that limits the total number of characters that can be added.\n * Ported from `AString.limit()` inner class.\n * @extends AString\n */\nclass AStringLimiter extends AString {\n    self;\n    limit0;\n    end = false;\n    /**\n     * @param {AString} self The AString to wrap.\n     * @param {number} count The character limit.\n     */\n    constructor(self, count) {\n        super();\n        this.self = self;\n        this.limit0 = count - 3; // Reserve space for \"...\"\n    }\n    /**\n     * Appends \"...\" if the limit has been reached.\n     * @private\n     */\n    checkEnd() {\n        if (this.end)\n            return;\n        this.self.add(\"...\");\n        this.end = true;\n    }\n    /** {@inheritDoc} */\n    toString() {\n        return this.self.toString();\n    }\n    /** {@inheritDoc} */\n    get length() {\n        return this.self.length;\n    }\n    /** {@inheritDoc} */\n    charAt(index) {\n        return this.self.charAt(index);\n    }\n    /** {@inheritDoc} */\n    subSequence(start, end) {\n        return this.self.subSequence(start, end);\n    }\n    // --- Overridden add ---\n    /**\n     * Overridden 'add' implementation that respects the limit.\n     */\n    add(val, offset, len) {\n        if (this.limit0 <= 0) {\n            this.checkEnd();\n            return this;\n        }\n        // We need to capture the string representation to measure its length.\n        // Create a temporary AString to render the value.\n        const tempAString = AString.of();\n        // Handle the original call in the temp string\n        if (offset !== undefined && len !== undefined) {\n            // @ts-ignore\n            tempAString.add(val, offset, len);\n        }\n        else {\n            // @ts-ignore\n            tempAString.add(val);\n        }\n        const strVal = tempAString.toString();\n        const valLen = strVal.length;\n        if (valLen === 0)\n            return this;\n        if (valLen <= this.limit0) {\n            this.limit0 -= valLen;\n            this.self.add(strVal); // Add the rendered string\n        }\n        else {\n            this.self.add(strVal.substring(0, this.limit0));\n            this.limit0 = 0;\n            this.checkEnd();\n        }\n        return this;\n    }\n}\n/**\n * An AString wrapper that intercepts `add(Uint8Array)` calls to limit their output.\n * Ported from `LimitByteArrays` inner class.\n * @extends AString\n */\nclass LimitByteArrays extends AString {\n    self;\n    max;\n    cycleCounter = 0;\n    /**\n     * @param {AString} self The AString to wrap.\n     * @param {number} max The max bytes to print from a byte array.\n     */\n    constructor(self, max) {\n        super();\n        this.self = self;\n        this.max = max;\n    }\n    // --- Pass-through methods ---\n    /** {@inheritDoc} */\n    toString() { return this.self.toString(); }\n    /** {@inheritDoc} */\n    get length() { return this.self.length; }\n    /** {@inheritDoc} */\n    charAt(index) { return this.self.charAt(index); }\n    /** {@inheritDoc} */\n    subSequence(start, end) { return this.self.subSequence(start, end); }\n    // --- Overridden add ---\n    /**\n     * Overridden 'add' implementation that intercepts byte arrays.\n     */\n    add(val, offset, len) {\n        this.cycleCounter++;\n        if (this.cycleCounter > 10) {\n            throw new Error(\"AString cycle detected\");\n        }\n        try {\n            // Handle offset/len calls\n            if (offset !== undefined && len !== undefined) {\n                // @ts-ignore\n                this.self.add(val, offset, len);\n                return this;\n            }\n            if (val instanceof Uint8Array) {\n                // This is the intercepted call\n                if (val == null)\n                    return this;\n                const l = Math.min(val.length, this.max);\n                HexUtils.toHexString(val, 0, l, this.self); // Add to underlying string\n                if (l !== val.length) {\n                    this.self.add(\"...\");\n                }\n                return this;\n            }\n            // Delegate all other types to the wrapped instance's add(Object)\n            this.self.add(val);\n            return this;\n        }\n        finally {\n            this.cycleCounter--;\n        }\n    }\n}\n//# sourceMappingURL=aether_astring.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_astring.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client.js":
/*!***********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_client.ts ( )\n// =============================================================================================\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.aCrypto = exports.aetherApi = exports.AetherCloudClient = exports.ClientTask = exports.RegStatus = void 0;\nconst aether_crypto_1 = __webpack_require__(/*! ./aether_crypto */ \"./node_modules/aether-client/build/aether_crypto.js\");\nconst aether_client_connection_work_1 = __webpack_require__(/*! ./aether_client_connection_work */ \"./node_modules/aether-client/build/aether_client_connection_work.js\");\nconst aether_client_connection_reg_1 = __webpack_require__(/*! ./aether_client_connection_reg */ \"./node_modules/aether-client/build/aether_client_connection_reg.js\");\nconst aether_client_message_1 = __webpack_require__(/*! ./aether_client_message */ \"./node_modules/aether-client/build/aether_client_message.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_rcollection_1 = __webpack_require__(/*! ./aether_rcollection */ \"./node_modules/aether-client/build/aether_rcollection.js\");\nvar RegStatus;\n(function (RegStatus) {\n    RegStatus[RegStatus[\"NO\"] = 0] = \"NO\";\n    RegStatus[RegStatus[\"BEGIN\"] = 1] = \"BEGIN\";\n    RegStatus[RegStatus[\"CONFIRM\"] = 2] = \"CONFIRM\";\n})(RegStatus || (exports.RegStatus = RegStatus = {}));\n/**\n * @class AccessGroupImpl\n * @description Internal implementation of the mutable access group interface.\n * @implements {AccessGroupI}\n */\nclass AccessGroupImpl {\n    client;\n    id;\n    owner;\n    data; //   (  )\n    constructor(client, group) {\n        this.client = client;\n        this.id = group.getId();\n        this.owner = group.getOwner();\n        this.data = new Set(group.getData()); //  \n    }\n    add(uuid) {\n        if (this.data.has(uuid)) {\n            aether_logging_1.Log.trace(\"AccessGroupImpl.add: UUID already in local cache.\", { uuid: uuid.toString(), group: this.id });\n            return aether_future_1.ARFuture.of(false);\n        }\n        //    \n        const groupMap = this.client.accessOperationsAdd.get(this.id) ?? new Map();\n        if (!this.client.accessOperationsAdd.has(this.id)) {\n            this.client.accessOperationsAdd.set(this.id, groupMap);\n        }\n        const uuidStr = uuid.toString().toString();\n        let future = groupMap.get(uuidStr);\n        if (!future) {\n            future = aether_future_1.ARFuture.make();\n            groupMap.set(uuidStr, future);\n        }\n        //    \n        this.client.flush();\n        return future;\n    }\n    remove(uuid) {\n        if (!this.data.has(uuid)) {\n            aether_logging_1.Log.trace(\"AccessGroupImpl.remove: UUID not in local cache.\", { uuid: uuid.toString(), group: this.id });\n            return aether_future_1.ARFuture.of(false);\n        }\n        //    \n        const groupMap = this.client.accessOperationsRemove.get(this.id) ?? new Map();\n        if (!this.client.accessOperationsRemove.has(this.id)) {\n            this.client.accessOperationsRemove.set(this.id, groupMap);\n        }\n        const uuidStr = uuid.toString().toString();\n        let future = groupMap.get(uuidStr);\n        if (!future) {\n            future = aether_future_1.ARFuture.make();\n            groupMap.set(uuidStr, future);\n        }\n        //    \n        this.client.flush();\n        return future;\n    }\n}\n/**\n * @class ClientTask\n * @description Internal class to hold tasks for getClientApi.\n * (Based on static class AetherCloudClient.ClientTask)\n */\nclass ClientTask {\n    uid;\n    task;\n    constructor(uid, task) {\n        this.uid = uid;\n        this.task = task;\n    }\n}\nexports.ClientTask = ClientTask;\n/**\n* @class AetherCloudClient\n* @implements {Destroyable}\n* @description Main client class managing connections, state, and communication logic.\n*/\nclass AetherCloudClient {\n    destroyer;\n    state;\n    name;\n    logClientContext;\n    regConnection = null;\n    workConnections = new Map();\n    registrationUrl;\n    startFuture = aether_future_1.AFuture.make();\n    startFuture0 = aether_future_1.AFuture.make();\n    messageNodeMap = new Map();\n    onMessage = new aether_future_1.EventBiConsumer();\n    onNewChild = new aether_future_1.EventConsumer();\n    onClientStreamCreated = new aether_future_1.EventConsumer();\n    servers;\n    clouds;\n    beginConnect = false;\n    /**\n         * @private\n         * @description (Port from Java)\n         * Fetches the client's own Cloud and ServerDescriptors,\n         * ensures they are saved to state, and then completes.\n         * This is critical for preventing race conditions on restart.\n         */\n    forceUpdateStateFromCache() {\n        const resultFuture = aether_future_1.AFuture.make();\n        const uid = this.getUid(); //\n        if (!uid) {\n            const err = new Error(\"Client UID is null. Cannot update state from cache.\");\n            aether_logging_1.Log.error(err.message);\n            return aether_future_1.AFuture.ofThrow(err); //\n        }\n        aether_logging_1.Log.debug(\"forceUpdateStateFromCache: Forcing fetch and save for own UID...\", { uid: uid.toString() });\n        // 1.  Cloud ( state  )\n        this.getCloud(uid).to((cloud) => {\n            if (!cloud) {\n                const err = new Error(\"Fetched cloud was null for UID: \" + uid);\n                aether_logging_1.Log.error(err.message);\n                return resultFuture.error(err);\n            }\n            // 2.   Cloud  state ( ,     BMap)\n            this.state.setCloud(uid, cloud); //\n            aether_logging_1.Log.trace(\"forceUpdateStateFromCache: Own cloud saved to state.\", { uid: uid.toString() });\n            const sids = cloud.data;\n            if (!sids || sids.length === 0) {\n                aether_logging_1.Log.warn(\"forceUpdateStateFromCache: Client's own cloud is empty. State updated.\");\n                return resultFuture.tryDone(); //\n            }\n            // 3.  futures   ServerDescriptors\n            const serverFutures = sids.map(sid => this.getServer(sid)); //\n            // 4. ,     (  BMap/state)\n            aether_future_1.ARFuture.all(serverFutures).to(() => {\n                aether_logging_1.Log.trace(\"forceUpdateStateFromCache: All server descriptors fetched. Saving to state...\");\n                // 5.      BMap  state\n                for (const future of serverFutures) {\n                    const desc = future.getNow(); //\n                    if (desc) {\n                        this.state.setServerDescriptor(desc); //\n                    }\n                    else {\n                        aether_logging_1.Log.warn(\"forceUpdateStateFromCache: ServerDescriptor was null after ARFuture.all, this is unexpected.\");\n                    }\n                }\n                aether_logging_1.Log.debug(\"forceUpdateStateFromCache: Force update for own UID complete.\", { uid: uid.toString() });\n                resultFuture.tryDone(); //\n            }).onError(e => {\n                aether_logging_1.Log.error(\"forceUpdateStateFromCache: Failed to fetch server descriptors.\", e, { uid: uid.toString() });\n                resultFuture.error(e);\n            });\n        }).onError(e => {\n            aether_logging_1.Log.error(\"forceUpdateStateFromCache: Failed to fetch own cloud.\", e, { uid: uid.toString() });\n            resultFuture.error(e);\n        });\n        return resultFuture;\n    }\n    connect() {\n        if (this.beginConnect)\n            return this.startFuture0;\n        this.beginConnect = true;\n        aether_future_1.AFuture.ofPromise(() => this.initRegistration())\n            .onError(e => {\n            aether_logging_1.Log.error(\"Client failed to start during initRegistration.\", e);\n            this.startFuture.tryError(e);\n        });\n        this.startFuture.to(() => {\n            this.forceUpdateStateFromCache().to(() => {\n                this.startFuture0.done();\n            });\n        });\n        return this.startFuture0;\n    }\n    /**\n     * Batched cache for client access groups.\n     * Key: Client UUID, Value: Set of Group IDs\n     */\n    clientGroups;\n    /**\n     * Batched cache for AccessGroup definitions.\n     * Key: Group ID, Value: AccessGroup object\n     */\n    accessGroups; // Java-  null\n    /**\n     * Batched cache for all clients accessible by a given client.\n     * Key: Client UUID, Value: Set of accessible Client UUIDs\n     */\n    allAccessedClients;\n    /**\n     * Batched cache for access check results.\n     * Key: AccessCheckPair (source, target), Value: Boolean (hasAccess)\n     */\n    accessCheckCache;\n    accessOperationsAdd = new Map();\n    accessOperationsRemove = new Map();\n    /**\n     * Queue for tasks requiring an AuthorizedApi instance.\n     * Processed in ConnectionWork.flushBackgroundRequests.\n     */\n    authTasks = new aether_utils_1.Queue();\n    /**\n     * Queue for tasks requiring a ServerApiByUid instance.\n     * Processed in ConnectionWork.flushBackgroundRequests.\n     */\n    clientTasks = new aether_utils_1.Queue();\n    onNewChildApi = new aether_future_1.EventBiConsumer();\n    /**\n    * @constructor\n    * @param {ClientState} state The client state implementation.\n    * @param {string} name A descriptive name for the client.\n    */\n    constructor(state, name) {\n        this.state = state;\n        this.name = name;\n        this.destroyer = new aether_utils_1.Destroyer(name + '-client');\n        this.logClientContext = aether_logging_1.Log.of({\n            component: name\n        });\n        aether_logging_1.Log.info(\"AetherCloudClient: Initializing...\");\n        this.registrationUrl = state.getRegistrationUri();\n        const timeout = state.getTimeoutForConnectToRegistrationServer(); //  \n        this.servers = aether_rcollection_1.RCol.bMap(timeout, `${name}-servers`);\n        this.clouds = aether_rcollection_1.RCol.bMap(timeout, `${name}-clouds`);\n        this.clientGroups = aether_rcollection_1.RCol.bMap(timeout, `${name}-clientGroups`);\n        this.accessGroups = aether_rcollection_1.RCol.bMap(timeout, `${name}-accessGroups`);\n        this.allAccessedClients = aether_rcollection_1.RCol.bMap(timeout, `${name}-allAccessedClients`);\n        this.accessCheckCache = aether_rcollection_1.RCol.bMap(timeout, `${name}-accessCheckCache`);\n        this.onMessage.add((senderUid, msg) => {\n            this.getMessageNode(senderUid, aether_client_message_1.MessageEventListenerDefault).sendMessageFromServerToClient(msg);\n        });\n        this.populateCachesFromState();\n        this.clouds.forValueUpdate().add(uu => state.setCloud(uu.key, uu.newValue));\n        this.servers.forValueUpdate().add(s => {\n            state.setServerDescriptor(s.newValue);\n        });\n        this.onNewChild.add(u => {\n            if (this.onNewChildApi.hasListener()) {\n                this.getClientApi(u, (api) => {\n                    this.onNewChildApi.fire(u, api);\n                });\n            }\n        });\n        const pingTime = this.getPingTime();\n        this.destroyer.add(aether_utils_1.RU.scheduleAtFixedRate(this.destroyer, pingTime, \"MILLISECONDS\", this.scheduledWork.bind(this)));\n        aether_logging_1.Log.debug(`AetherCloudClient: Scheduled work at fixed rate: ${pingTime}ms`);\n    }\n    /**\n     * @private\n     * @description (Port from Java) Populates internal BMap caches from clientState.\n     */\n    populateCachesFromState() {\n        aether_logging_1.Log.trace(\"populateCachesFromState: Populating caches from state...\");\n        // TODO:    ClientState\n        // (Java-    /   ClientInfo/ServerInfo)\n        //   (  ClientState  ):\n        // if (this.state.getUid() == null) {\n        //     return; // Nothing to populate if not registered\n        // }\n        // const allClouds = this.state.getAllClouds(); // <--   \n        // for (const [uid, cloud] of allClouds) {\n        //     this.clouds.putResolved(uid, cloud);\n        // }\n        // const allServers = this.state.getAllServerDescriptors(); // <--   \n        // for (const [id, descriptor] of allServers) {\n        //     this.servers.putResolved(id, descriptor);\n        // }\n        // TODO:     accessGroups, clientGroups  ..\n        aether_logging_1.Log.trace(\"populateCachesFromState: Stub complete.\");\n    }\n    /**\n    * @private\n    * @async\n    * @description Initiates the client registration or login process.\n    * @returns {Promise<void>}\n    */\n    async initRegistration() {\n        aether_logging_1.Log.info(\"initRegistration: Starting registration or login process.\");\n        // --- [FIX] Wrap getMasterKey() in a helper that can catch the null pointer\n        const getMasterKeySafe = () => {\n            try {\n                return this.state.getMasterKey();\n            }\n            catch (e) {\n                // This catches the 'Cannot read properties of null' error\n                if (e.message.includes(\"Cannot read properties of null\")) {\n                    return null;\n                }\n                // Re-throw other errors\n                throw e;\n            }\n        };\n        const existingMasterKey = getMasterKeySafe(); // <--- Use safe getter\n        if (this.state.getUid() && existingMasterKey) { // <--- Check against the safe-fetched key\n            aether_logging_1.Log.info(\"Client is already registered. Attempting to login directly...\");\n            // =================================================================\n            //    (  Java)\n            // 1.   startFuture\n            this.startFuture.tryDone();\n            // 2.   \n            this.makeFirstConnection();\n            // =================================================================\n            return;\n        }\n        if (!existingMasterKey) { // <--- Check against the safe-fetched key\n            aether_logging_1.Log.debug(\"initRegistration: MasterKey not found, generating new one.\");\n            const cryptoLib = this.state.getCryptoLib();\n            const provider = aether_crypto_1.CryptoProviderFactory.getProvider(cryptoLib);\n            const newMasterKey = provider.createSymmetricKey();\n            this.state.setMasterKey(newMasterKey);\n        }\n        const regUri = this.registrationUrl[0];\n        if (!regUri) {\n            const error = new aether_types_1.ClientStartException(\"No registration URI provided in state.\");\n            aether_logging_1.Log.error(\"initRegistration: No registration URI provided in state.\", error);\n            throw error;\n        }\n        aether_logging_1.Log.debug(`initRegistration: Attempting connection to registration server: ${regUri}`);\n        // --- :    ConnectionRegistration ---\n        const regConn = new aether_client_connection_reg_1.ConnectionRegistration(this, regUri);\n        this.regConnection = regConn;\n        this.destroyer.add(regConn);\n        //  `connect`  ConnectionRegistration  .\n        //   ,  `startFuture`    ( ).\n        //    ,  **  (getRootApiFuture)\n        // ,  `startFuture`   .\n        regConn.getRootApiFuture().onError((e) => {\n            if (!this.startFuture.isFinalStatus()) {\n                aether_logging_1.Log.error(\"initRegistration: Failed to establish initial registration connection.\", e);\n                this.startFuture.tryError(e); //   \n            }\n        });\n        // --- [NEW] Start the registration process now that connection is initiated\n        regConn.registration(); // <--- [FIX]    \n    }\n    confirmRegistration(regResp) {\n        aether_logging_1.Log.info(\"confirmRegistration: Registration confirmed by server.\", { uid: regResp.getUid().toString() });\n        //  UID,     \n        if (!this.state.getUid()) {\n            this.state.setUid(regResp.getUid());\n            this.state.setAlias(regResp.getAlias());\n            //  Cloud,   \n            this.setCloud(regResp.getUid(), regResp.getCloud());\n            aether_logging_1.Log.debug(\"confirmRegistration: Client UID, Alias, and Cloud set in state.\");\n            // =================================================================\n            //  v2:   (  Java)\n            // 1.  startFuture .\n            this.startFuture.tryDone();\n            // 2.      (fire and forget).\n            this.makeFirstConnection();\n            // =================================================================\n        }\n        else {\n            aether_logging_1.Log.warn(\"confirmRegistration: Received confirmation, but client UID was already set.\", { uid: this.state.getUid()?.toString() });\n        }\n    }\n    /**\n    * @description Retrieves the client's UUID.\n    * @returns {UUID | null} The client's UUID.\n    */\n    getUid() {\n        return this.state.getUid();\n    }\n    /**\n    * @description Retrieves the client's Alias UUID.\n    * @returns {UUID | null} The client's alias UUID.\n    */\n    getAlias() {\n        return this.state.getAlias();\n    }\n    getMasterKeyAKey() {\n        let key = null;\n        try {\n            key = this.state.getMasterKey();\n        }\n        catch (e) {\n            if (e.message.includes(\"Cannot read properties of null\")) {\n                key = null; // Treat \"cannot read null\" as \"key is null\"\n            }\n            else {\n                throw e; // Re-throw other errors\n            }\n        }\n        if (!key) {\n            const err = new aether_types_1.ClientStartException(\"Master key is missing in state.\");\n            aether_logging_1.Log.error(err.message);\n            throw err;\n        }\n        const keyImpl = key;\n        if (keyImpl.getKeyType() !== aether_crypto_1.KeyType.SYMMETRIC) {\n            const err = new aether_types_1.ClientStartException(\"Master key in state is not symmetric.\");\n            aether_logging_1.Log.error(err.message);\n            throw err;\n        }\n        return keyImpl.asSymmetric();\n    }\n    getMasterKeyDto() {\n        const key = this.state.getMasterKey();\n        if (!key) {\n            const err = new aether_types_1.ClientStartException(\"Master key is missing in state.\");\n            aether_logging_1.Log.error(err.message);\n            throw err;\n        }\n        return key;\n    }\n    getParent() {\n        const parent = this.state.getParentUid();\n        if (!parent) {\n            //    ,  state \n            aether_logging_1.Log.warn(\"Client state getParentUid() returned null, falling back to TEST_UID\");\n            return aether_utils_1.StandardUUIDs.TEST_UID;\n        }\n        return parent;\n    }\n    /**\n    * @description Gets a CryptoEngine suitable for the connection to the specified server,\n    * deriving symmetric keys from the master key and server ID.\n    * @param {number} serverId The ID of the target server.\n    * @returns {CryptoEngine} A CryptoEngine instance for encryption/decryption.\n    * @throws {Error} If the master key is missing or invalid.\n    */\n    getCryptoEngineForServer(serverId) {\n        aether_logging_1.Log.trace(\"getCryptoEngineForServer: Requesting crypto engine.\", { sid: serverId });\n        const keyImpl = this.getMasterKeyAKey();\n        const provider = aether_crypto_1.CryptoProviderFactory.getProviderByKey(keyImpl);\n        const derivedKeys = provider.createKeyForServer(keyImpl, serverId);\n        const encryptKey = derivedKeys.clientKey;\n        const decryptKey = derivedKeys.serverKey;\n        // ---------------------------------------------------------------------------------\n        const encryptEngine = provider.createSymmetricEngine(encryptKey);\n        const decryptEngine = provider.createSymmetricEngine(decryptKey);\n        aether_logging_1.Log.trace(\"getCryptoEngineForServer: Successfully created derived keys and engines.\");\n        return aether_crypto_1.CryptoEngine.of(encryptEngine, decryptEngine);\n    }\n    /**\n    * @description Gets the configured ping duration from the client state.\n    * @returns {number} The ping interval in milliseconds.\n    */\n    getPingTime() {\n        return this.state.getPingDuration().getNow() ?? 1000;\n    }\n    /**\n        * @description Requests the ServerDescriptor for a given server ID, querying the BMap cache.\n        * @param {number} serverId The ID of the server.\n        * @returns {ARFuture<ServerDescriptor |\n        null>} An ARFuture that resolves to the ServerDescriptor or null.\n        */\n    getServer(serverId) {\n        const r = this.state.getServerDescriptor ? this.state.getServerDescriptor(serverId) : null;\n        if (r != null) {\n            return aether_future_1.ARFuture.of(r);\n        }\n        // (  , BMap   )\n        if (this.servers.has(serverId)) {\n            aether_logging_1.Log.trace(`getServer: Cache hit for serverId: ${serverId}`);\n            return this.servers.get(serverId);\n        }\n        aether_logging_1.Log.trace(`getServer: Cache miss for serverId: ${serverId}. Fetching.`);\n        const future = this.servers.getFuture(serverId);\n        return future;\n    }\n    /**\n    * @description Requests the Cloud location for a given UUID, querying the BMap cache.\n    * @param {UUID} uid The target UUID.\n    * @returns {ARFuture<Cloud |\n    null>} An ARFuture that resolves to the Cloud object or null.\n    */\n    getCloud(uid) {\n        // =================================================================\n        // : (  Java)   state,  BMap\n        const r = this.state.getCloud(uid);\n        if (r != null)\n            return aether_future_1.ARFuture.of(r);\n        // =================================================================\n        if (this.clouds.has(uid)) {\n            aether_logging_1.Log.trace(`getCloud: Cache hit for uid: ${uid}`);\n            return this.clouds.get(uid);\n        }\n        aether_logging_1.Log.trace(`getCloud: Cache miss for uid: $uid. Fetching.`, { uid: uid });\n        const future = this.clouds.getFuture(uid);\n        return future;\n    }\n    /**\n    * @description Stores the Cloud information locally in state and resolves any pending futures in the BMap.\n    * @param {UUID} uid The target UUID.\n    * @param {Cloud} cloud The Cloud object.\n    */\n    setCloud(uid, cloud) {\n        aether_logging_1.Log.debug(`setCloud: Storing cloud for uid: $uid`, { uid: uid });\n        this.state.setCloud(uid, cloud);\n        this.clouds.putResolved(uid, cloud);\n    }\n    /**\n     * @description Retrieves the access groups for a given client UUID using batched requests.\n     * @param {UUID} uid The client UUID.\n     * @returns {ARFuture<Set<bigint>>} A future containing the set of group IDs.\n     */\n    getClientGroups(uid) {\n        aether_logging_1.Log.trace(\"getClientGroups: Requesting groups for client.\", { uid: uid.toString() });\n        //     BMap\n        return this.clientGroups.getFuture(uid);\n    }\n    /**\n     * @description Retrieves all client UUIDs this client can access using batched requests.\n     * @param {UUID} uid The client UUID.\n     * @returns {ARFuture<Set<UUID>>} A future containing the set of accessed client UUIDs.\n     */\n    getAllAccessedClients(uid) {\n        aether_logging_1.Log.trace(\"getAllAccessedClients: Requesting all accessed clients for.\", { uid: uid.toString() });\n        //     BMap\n        return this.allAccessedClients.getFuture(uid);\n    }\n    /**\n     * @description Checks if this client has permission to send messages to another client using batched requests.\n     * @param {UUID} uid1 The source client UUID.\n     * @param {UUID} uid2 The target client UUID.\n     * @returns {ARFuture<boolean>} A future containing true if access is granted, false otherwise.\n     */\n    checkAccess(uid1, uid2) {\n        aether_logging_1.Log.trace(\"checkAccess: Requesting access check.\", { from: uid1.toString(), to: uid2.toString() });\n        //  DTO     BMap\n        return this.accessCheckCache.getFuture(new aether_api_1.AccessCheckPair(uid1, uid2));\n    }\n    /**\n     * @description Retrieves the AccessGroup details by its ID using batched requests.\n     * @param {bigint} groupId The ID of the access group.\n     * @returns {ARFuture<AccessGroup>} A future containing the AccessGroup.\n     */\n    getGroup(groupId) {\n        aether_logging_1.Log.trace(\"getGroup: Requesting access group details.\", { gid: groupId });\n        //     BMap\n        return this.accessGroups.getFuture(groupId);\n    }\n    /**\n    * @description Gets or creates a MessageNode for persistent point-to-point communication with a peer.\n    * @param {UUID} consumerUid The peer's UUID.\n    * @param {MessageEventListener} [strategy=MessageEventListenerDefault] The connection resolution strategy.\n    * @returns {MessageNode} The MessageNode instance.\n    */\n    getMessageNode(consumerUid, strategy = aether_client_message_1.MessageEventListenerDefault) {\n        const key = consumerUid.toString().toString();\n        if (!this.messageNodeMap.has(key)) {\n            aether_logging_1.Log.debug(`getMessageNode: Creating new MessageNode for: ${key}`);\n            const newNode = new aether_client_message_1.MessageNode(this, consumerUid, strategy);\n            this.messageNodeMap.set(key, newNode);\n            this.onClientStreamCreated.fire(newNode);\n            return newNode;\n        }\n        aether_logging_1.Log.trace(`getMessageNode: Reusing existing MessageNode for: ${key}`);\n        return this.messageNodeMap.get(key);\n    }\n    /**\n    * @description Sends a raw byte array message to a specified client.\n    * @param {UUID} consumerUid The target client UUID.\n    * @param {Uint8Array} data The raw message content.\n    * @returns {AFuture} An AFuture that completes when the message is accepted for sending.\n    */\n    sendMessage(consumerUid, data) {\n        aether_logging_1.Log.trace(`sendMessage: Sending $dlen bytes to $consumerUid`, { dlen: data.length, consumerUid: consumerUid.toString(), size: data.length });\n        const future = aether_future_1.AFuture.make();\n        const node = this.getMessageNode(consumerUid);\n        node.send(data, future);\n        return future;\n    }\n    getConnectionBySid(sid) {\n        aether_logging_1.Log.trace(`getConnectionBySid: Requesting connection for sid: $sid`, { sid: sid });\n        let res = aether_future_1.ARFuture.of();\n        this.getServer(sid).to((sd) => {\n            //    null, .. getServer   null\n            if (sd) {\n                aether_logging_1.Log.trace(`getConnectionBySid: ServerDescriptor resolved for sid: $sid`, { sid: sid, descriptor: sd });\n                res.done(this.getConnection(sd));\n            }\n            else {\n                aether_logging_1.Log.warn(`getConnectionBySid: ServerDescriptor resolved to null for sid: ${sid}`);\n                res.error(new aether_types_1.ClientApiException(`ServerDescriptor resolved to null for sid: ${sid}`));\n            }\n        }, (err) => {\n            //  ,  getServer  \n            res.error(err);\n        });\n        return res;\n    }\n    /**\n     * @description Retrieves or creates a connection to a work server.\n     * @param {ServerDescriptor} serverDescriptor The descriptor of the server to connect to.\n     * @returns {ConnectionWork} The existing or newly created ConnectionWork instance.\n     * @throws {ClientApiException} if the provided ServerDescriptor is null.\n     */\n    getConnection(serverDescriptor) {\n        if (!serverDescriptor) {\n            const error = new aether_types_1.ClientApiException(\"Cannot get connection for null ServerDescriptor.\");\n            aether_logging_1.Log.error(\"getConnection: Cannot get connection for null ServerDescriptor.\", error);\n            throw error;\n        }\n        // const logData = { serverId: serverDescriptor.id };\n        this.servers.putResolved(serverDescriptor.id, serverDescriptor);\n        let conn = this.workConnections.get(serverDescriptor.id);\n        if (conn) {\n            aether_logging_1.Log.trace(`getConnection: Reusing existing ConnectionWork for serverId: $sid`, { sid: serverDescriptor.id });\n            return conn;\n        }\n        aether_logging_1.Log.debug(`getConnection: Creating new ConnectionWork for serverId: $sid`, { sid: serverDescriptor.id });\n        conn = new aether_client_connection_work_1.ConnectionWork(this, serverDescriptor);\n        this.workConnections.set(serverDescriptor.id, conn);\n        this.destroyer.add(conn);\n        return conn;\n    }\n    /**\n    * @private\n    * @description Initiates work connections based on the client's own cloud.\n    */\n    makeFirstConnection() {\n        aether_logging_1.Log.debug(\"makeFirstConnection: Attempting to establish first work connection.\");\n        if (this.destroyer.isDestroyed()) {\n            aether_logging_1.Log.warn(\"makeFirstConnection: Aborted, client is already destroyed.\");\n            return;\n        }\n        const uid = this.getUid();\n        if (!uid) {\n            aether_logging_1.Log.warn(\"makeFirstConnection called but client UID is null.\");\n            // --- :  UID ,      ---\n            if (!this.startFuture.isFinalStatus()) {\n                aether_logging_1.Log.debug(\"makeFirstConnection: UID is null, likely awaiting registration. Aborting connection attempt.\");\n                //   ,  \n            }\n            return;\n        }\n        // =================================================================\n        // : (  Java)  BMap- (getCloud),   this.state.getCloud\n        const cloudFuture = this.getCloud(uid); //\n        // =================================================================\n        cloudFuture.to((cloud) => {\n            if (!cloud || !cloud.data || cloud.data.length === 0) {\n                aether_logging_1.Log.warn(\"makeFirstConnection: Client cloud data is empty. Cannot connect to work servers.\", { uid: uid.toString() });\n                // TODO:   triggerRecovery,   Java\n                return;\n            }\n            aether_logging_1.Log.trace(\"makeFirstConnection: Found cloud, attempting to connect.\", { serverIds: cloud.data });\n            const connectFutures = [];\n            for (const serverId of cloud.data) {\n                if (serverId <= 0)\n                    continue;\n                // =================================================================\n                //  v1: DEADLOCK\n                //  `conn.connectFuture` ( ),   `conn.ready` ( ).\n                //,\n                // =================================================================\n                const connConnectFuture = this.getConnectionBySid(serverId)\n                    .mapRFuture((conn) => {\n                    if (!conn) {\n                        throw new aether_types_1.ClientApiException(`getConnectionBySid returned null for ${serverId}`);\n                    }\n                    //    'connectFuture' ( )\n                    return conn.connectFuture;\n                })\n                    .toFuture(); //  ARFuture<RT>  AFuture\n                connectFutures.push(connConnectFuture);\n            }\n            aether_logging_1.Log.debug(`makeFirstConnection: Attempting connections to ${connectFutures.length} servers.`);\n            if (connectFutures.length > 0) {\n                //     startFuture .\n                //   ,   .\n                aether_future_1.AFuture.any(...connectFutures)\n                    .to(() => {\n                    aether_logging_1.Log.info(\"makeFirstConnection: At least one work connection is established (socket ready).\");\n                    // startFuture      confirmRegistration\n                }).onError((err) => {\n                    aether_logging_1.Log.error(\"makeFirstConnection: All connection attempts failed.\", err);\n                });\n            }\n            else {\n                aether_logging_1.Log.warn(\"makeFirstConnection: No valid server IDs in cloud.\");\n            }\n        }).onError(e => {\n            aether_logging_1.Log.error(\"makeFirstConnection: Recovery fetch failed.\", e);\n        });\n    }\n    /**\n     * @description Flushes pending requests and messages to the network connections.\n     * (Port from Java)\n     */\n    flush() {\n        if (this.destroyer.isDestroyed())\n            return;\n        //  BMap   pending \n        if (this.workConnections.size === 0) {\n            if (this.getUid() == null)\n                return; //   \n            //   makeFirstConnection,   \n            this.makeFirstConnection();\n            //  makeFirstConnection    (,  recovery),\n            //  , .. flush()    .\n            if (this.workConnections.size === 0) {\n                aether_logging_1.Log.trace(\"flush: No connections available to flush.\");\n                return;\n            }\n        }\n        aether_logging_1.Log.trace(\"flush: Triggering flush on all connections.\");\n        for (const c of this.workConnections.values()) {\n            c.flush();\n        }\n    }\n    /**\n     * @description Helper to get an authorized API future and map a function over it.\n     * (Port from Java)\n     * @param {AFunction<AuthorizedApiRemote, ARFuture<T>>} t The function to execute on the AuthorizedApi.\n     * @returns {ARFuture<T>} A future with the result of the function.\n     */\n    getAuthApi1(t) {\n        if (this.destroyer.isDestroyed())\n            return aether_future_1.ARFuture.canceled();\n        const res = aether_future_1.ARFuture.make();\n        this.getAuthApiFuture().mapRFuture(t).to(res);\n        return res;\n    }\n    /**\n     * @description Returns a future that completes with the AuthorizedApi instance.\n     * (Port from Java)\n     * @returns {ARFuture<AuthorizedApiRemote>} A future containing the AuthorizedApi instance.\n     */\n    getAuthApiFuture() {\n        const res = aether_future_1.ARFuture.make();\n        if (this.destroyer.isDestroyed()) {\n            res.cancel();\n            return res;\n        }\n        // Enqueue the consumer, which will call res.done(api) later.\n        this.getAuthApi((api) => res.tryDone(api));\n        // Ensures the future doesn't hang indefinitely.\n        res.timeoutError(8000, \"Timeout waiting for AuthorizedApi to become available.\");\n        return res;\n    }\n    /**\n     * @description Enqueues a task to be executed on an active AuthorizedApi.\n     * (Port from Java)\n     * @param {AConsumer<AuthorizedApiRemote>} t The consumer to execute with the AuthorizedApi.\n     */\n    getAuthApi(t) {\n        if (this.destroyer.isDestroyed())\n            return;\n        this.authTasks.add(t);\n        this.flush(); //   \n    }\n    /**\n     * @description Enqueues a task to be executed on a ServerApiByUid stream.\n     * (Port from Java)\n     * @param {UUID} uid The target UID for the API stream.\n     * @param {AConsumer<ServerApiByUid>} c The consumer to execute.\n     */\n    getClientApi(uid, c) {\n        //    , ConnectionWork  \n        this.clientTasks.add(new ClientTask(uid, c));\n        //  flush,   \n        this.flush();\n    }\n    /**\n     * @description Creates an access group with the client's UID as the owner.\n     * @param {...UUID[]} uids Initial members of the group.\n     * @returns {ARFuture<AccessGroupI>} A future for the mutable AccessGroup interface.\n     */\n    createAccessGroup(...uids) {\n        const owner = this.getUid();\n        if (!owner) {\n            return aether_future_1.ARFuture.ofThrow(new aether_types_1.ClientApiException(\"Client UID is null, cannot create access group.\"));\n        }\n        return this.createAccessGroupWithOwner(owner, ...uids);\n    }\n    /**\n     * @description Creates an access group with a specified owner.\n     * (Port from Java)\n     * @param {UUID} owner The owner of the group.\n     * @param {...UUID[]} uids Initial members of the group.\n     * @returns {ARFuture<AccessGroupI>} A future for the mutable AccessGroup interface.\n     */\n    createAccessGroupWithOwner(owner, ...uids) {\n        //  getAuthApi1  \"\",   \n        return this.getAuthApi1((c) => c.createAccessGroup(owner, uids))\n            .map((id) => {\n            if (id === null) {\n                throw new aether_types_1.ClientApiException(\"createAccessGroup returned null ID.\");\n            }\n            //    AccessGroupImpl\n            const newGroupDTO = new aether_api_1.AccessGroup(owner, id, uids);\n            //    \n            this.accessGroups.putResolved(id, newGroupDTO);\n            return new AccessGroupImpl(this, newGroupDTO);\n        });\n    }\n    logTime = 0;\n    /**\n    * @private\n    * @description Periodic task executor.\n    */\n    scheduledWork() {\n        if (aether_utils_1.RU.time() - this.logTime > 1000) {\n            this.logTime = aether_utils_1.RU.time();\n            aether_logging_1.Log.trace(\"scheduledWork: Executing periodic work.\");\n        }\n        this.workConnections.forEach(conn => conn.flush());\n    }\n    /**\n    * @description Destroys the client and all associated resources.\n    * @param {boolean} force - Forceful destruction (not always used in TS).\n    * @returns {AFuture} An AFuture that completes when destruction is finished.\n    */\n    destroy(force) {\n        aether_logging_1.Log.info(`destroy: Destroying client (force=${force}).`);\n        return this.destroyer.destroy(force);\n    }\n    /**\n    * @description Implementation of the Disposable interface for `using` statements.\n    */\n    [Symbol.dispose]() {\n        aether_logging_1.Log.info(\"[Symbol.dispose]: Disposing client.\");\n        this.destroy(true);\n    }\n    /**\n     * @description  ,     state.\n     */\n    verifySign(signedKey) {\n        // TODO:    (  Java CryptoUtils.verifySign)\n        aether_logging_1.Log.warn(\"verifySign: STUB! Returning true.\");\n        return true;\n    }\n}\nexports.AetherCloudClient = AetherCloudClient;\nexports.aetherApi = __importStar(__webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\"));\n__exportStar(__webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_client_message */ \"./node_modules/aether-client/build/aether_client_message.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_client_state */ \"./node_modules/aether-client/build/aether_client_state.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_astring */ \"./node_modules/aether-client/build/aether_astring.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_fastmeta */ \"./node_modules/aether-client/build/aether_fastmeta.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_fastmeta_net */ \"./node_modules/aether-client/build/aether_fastmeta_net.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_datainout */ \"./node_modules/aether-client/build/aether_datainout.js\"), exports);\n__exportStar(__webpack_require__(/*! ./aether_rcollection */ \"./node_modules/aether-client/build/aether_rcollection.js\"), exports);\nexports.aCrypto = __importStar(__webpack_require__(/*! ./aether_crypto */ \"./node_modules/aether-client/build/aether_crypto.js\"));\n//# sourceMappingURL=aether_client.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client_connection_base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client_connection_base.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_client_connection_base.ts\n// PURPOSE: Contains the Connection base class and IP address utility functions.\n// DEPENDENCIES: aether_types.ts, aether_client.ts, aether_api.ts, aether_logging.ts,\n//               aether_fastmeta.ts\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = exports.getUriFromServerDescriptor = exports.ipAddressToString = void 0;\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_fastmeta_net_1 = __webpack_require__(/*! ./aether_fastmeta_net */ \"./node_modules/aether-client/build/aether_fastmeta_net.js\");\n// Removed: import { FastMetaClientWebSocket } from './aether_fastmeta_websocket';\n/**\n * @description Converts an IPAddress DTO to its string representation.\n * @param {IPAddress} ipAddr The IPAddress object from the API.\n * @returns {string | null} A string representation (e.g., \"1.2.3.4\" or \"[::1]\") or null if invalid.\n */\nfunction ipAddressToString(ipAddr) {\n    aether_logging_1.Log.trace(\"Formatting IPAddress\", { ipAddress: ipAddr });\n    try {\n        if (ipAddr instanceof aether_api_1.IPAddressV4) {\n            if (ipAddr.data && ipAddr.data.length === 4) {\n                return Array.from(ipAddr.data).join('.');\n            }\n        }\n        else if (ipAddr instanceof aether_api_1.IPAddressV6) {\n            if (ipAddr.data && ipAddr.data.length === 16) {\n                const parts = [];\n                for (let i = 0; i < 16; i += 2) {\n                    parts.push(((ipAddr.data[i] << 8) | ipAddr.data[i + 1]).toString(16));\n                }\n                let ipStr = parts.join(':');\n                // --- Start IPv6 compression logic ---\n                let longestSeq = \"\";\n                let currentSeq = \"\";\n                ipStr.split(':').forEach(part => {\n                    if (part === '0') {\n                        currentSeq += \":0\";\n                    }\n                    else {\n                        if (currentSeq.length > longestSeq.length) {\n                            longestSeq = currentSeq;\n                        }\n                        currentSeq = \"\";\n                    }\n                });\n                if (currentSeq.length > longestSeq.length) {\n                    longestSeq = currentSeq;\n                }\n                if (longestSeq.length > 2) {\n                    if (ipStr === longestSeq.substring(1)) {\n                        ipStr = \"::\";\n                    }\n                    else if (ipStr.startsWith(longestSeq.substring(1) + \":\")) {\n                        ipStr = ipStr.replace(longestSeq.substring(1) + \":\", \"::\");\n                    }\n                    else if (ipStr.endsWith(\":\" + longestSeq.substring(1))) {\n                        ipStr = ipStr.replace(\":\" + longestSeq.substring(1), \"::\");\n                    }\n                    else {\n                        ipStr = ipStr.replace(longestSeq, \":\");\n                    }\n                }\n                // --- End IPv6 compression logic ---\n                return ipStr;\n            }\n        }\n    }\n    catch (e) {\n        aether_logging_1.Log.error(\"Error formatting IPAddress\", e, { ipAddress: ipAddr });\n    }\n    aether_logging_1.Log.error(\"Unknown or invalid IPAddress format provided to ipAddressToString\", { ipAddress: ipAddr });\n    return null;\n}\nexports.ipAddressToString = ipAddressToString;\n/**\n * @description Gets a suitable URI (WebSocket preferred) from a ServerDescriptor.\n * @param {ServerDescriptor} sd The server descriptor.\n * @param {AetherCodec} preferredCodec The preferred codec (e.g., WSS).\n * @returns {URI | null} A full URI string (e.g., \"wss://[::1]:9010\") or null if none found.\n */\nfunction getUriFromServerDescriptor(sd, preferredCodec) {\n    aether_logging_1.Log.trace(\"Getting URI from ServerDescriptor\", { serverId: sd?.id, preferredCodec });\n    if (!sd || !sd.ipAddress || !sd.ipAddress.addresses || sd.ipAddress.addresses.length === 0) {\n        aether_logging_1.Log.warn(\"Cannot get URI from invalid ServerDescriptor\", { serverId: sd?.id });\n        return null;\n    }\n    let fallbackUri = null;\n    for (const addrInfo of sd.ipAddress.addresses) {\n        for (const cap of addrInfo.coderAndPorts) {\n            const ipString = ipAddressToString(addrInfo.address);\n            if (ipString) {\n                const hostString = addrInfo.address instanceof aether_api_1.IPAddressV6 ? `[${ipString}]` : ipString;\n                // TODO: This logic might need refinement based on actual protocol names\n                const scheme = cap.codec === aether_api_1.AetherCodec.WS ? 'ws' : 'tcp';\n                const uri = `${scheme}://${hostString}:${cap.port}`;\n                if (cap.codec === preferredCodec) {\n                    aether_logging_1.Log.trace(`Found preferred URI: ${uri}`, { serverId: sd.id });\n                    return uri;\n                }\n                if (!fallbackUri) {\n                    fallbackUri = uri;\n                }\n            }\n        }\n    }\n    if (!fallbackUri) {\n        aether_logging_1.Log.warn(\"No valid URI found in ServerDescriptor\", { serverId: sd.id });\n    }\n    else {\n        aether_logging_1.Log.trace(`Using fallback URI: ${fallbackUri}`, { serverId: sd.id });\n    }\n    return fallbackUri;\n}\nexports.getUriFromServerDescriptor = getUriFromServerDescriptor;\n/**\n * @class Connection\n * @template LT - The local API interface.\n * @template RT - The remote API interface.\n * @implements {Destroyable}\n * @description Base class for client connections (Registration and Work).\n */\nclass Connection {\n    /**\n     * @description Reference to the main client instance.\n     * @protected\n     * @type {AetherCloudClient}\n     */\n    client;\n    /** * @description The URI of the connected server.\n     * @type {URI}\n     */\n    uri;\n    /** * @description Future that completes when the connection is established and the root remote API is ready.\n     * @type {ARFuture<RT>}\n     */\n    connectFuture;\n    /** * @description The underlying FastMeta client implementation.\n     * @protected\n     * @type {FastMetaClient<LT, RT>}\n     */\n    fastMetaClient;\n    /** * @description The root remote API instance, available after connectFuture completes.\n     * @protected\n     * @type {(RT | null)}\n     */\n    rootApi = null;\n    /** * @description Base logging context for this connection instance.\n     * @protected\n     * @type {*}\n     */\n    logCtxData;\n    /**\n     * @constructor\n     * @param {AetherCloudClient} client The main client instance.\n     * @param {URI} uri The server URI to connect to.\n     * @param {FastMetaApi<LT, any>} localApiMeta The META object for the local API implementation.\n     * @param {FastMetaApi<unknown, RT>} remoteApiMeta The META object for the remote API.\n     */\n    constructor(client, uri, localApiMeta, remoteApiMeta) {\n        if (!uri)\n            throw new Error(\"Connection URI cannot be null\");\n        this.uri = uri;\n        this.client = client;\n        this.logCtxData = { component: \"Connection\", uri: this.uri };\n        this.connectFuture = aether_future_1.ARFuture.of();\n        aether_logging_1.Log.debug(\"Connection: Initializing...\", this.logCtxData);\n        if (client.destroyer.isDestroyed()) {\n            aether_logging_1.Log.warn(\"Attempting to create connection on destroyed client\", this.logCtxData);\n            this.connectFuture.cancel();\n            this.rootApi = null;\n            this.fastMetaClient = null;\n            return;\n        }\n        client.destroyer.add(this);\n        const localApi = this;\n        /**\n         * @description Provides the local API implementation to the network layer.\n         * @type {AFunction<RT, LT>}\n         */\n        const localApiProvider = (remoteApi) => {\n            this.rootApi = remoteApi;\n            return localApi;\n        };\n        /**\n         * @description Callback for the network layer to report connection status.\n         * @type {AConsumer<boolean>}\n         */\n        const writableConsumer = (isWritable) => {\n            if (isWritable) {\n                if (this.rootApi) {\n                    this.connectFuture.tryDone(this.rootApi);\n                }\n                else {\n                    aether_logging_1.Log.error(\"Connection is writable but rootApi was not set.\", this.logCtxData);\n                    this.connectFuture.tryError(new Error(\"Connection established but rootApi is null.\"));\n                }\n            }\n            else {\n                aether_logging_1.Log.warn(\"Connection lost.\", this.logCtxData);\n                // TODO: Implement connection loss handling if necessary\n            }\n        };\n        this.fastMetaClient = aether_fastmeta_net_1.FastMetaNet.INSTANCE.get().makeClient(uri, localApiMeta, remoteApiMeta, localApiProvider, writableConsumer);\n        client.destroyer.add(this.fastMetaClient);\n    }\n    /**\n     * @description Gets the root remote API instance.\n     * @returns {RT | null} The remote API instance or null if not connected.\n     */\n    getRootApi() {\n        if (!this.connectFuture.isDone()) {\n            aether_logging_1.Log.warn(\"Accessing rootApi before connection attempt is complete (may be null).\", this.logCtxData);\n        }\n        return this.rootApi;\n    }\n    /**\n     * @description Gets the future that completes when the root remote API is ready.\n     * @returns {ARFuture<RT>} The future for the remote API.\n     */\n    getRootApiFuture() {\n        return this.connectFuture;\n    }\n    /** * @description Destroys the connection and underlying network client.\n     * @param {boolean} _force - Not currently used in this implementation.\n     * @returns {AFuture} A future that completes when the connection is closed.\n     * @inheritdoc\n     */\n    destroy(_force) {\n        aether_logging_1.Log.info(\"Destroying Connection\", this.logCtxData);\n        if (!this.connectFuture.isFinalStatus()) {\n            aether_logging_1.Log.trace(\"Cancelling connectFuture during destroy.\", this.logCtxData);\n            this.connectFuture.cancel();\n        }\n        if (this.fastMetaClient) {\n            return this.fastMetaClient.destroy(_force);\n        }\n        else {\n            return aether_future_1.AFuture.completed();\n        }\n    }\n    /** * @description Implements the Symbol.dispose method for 'using' syntax.\n     * @inheritdoc\n     */\n    [Symbol.dispose]() {\n        aether_logging_1.Log.info(\"Disposing Connection\", this.logCtxData);\n        this.destroy(true).onError(e => aether_logging_1.Log.error(\"Error during Connection dispose/destroy\", e, this.logCtxData));\n    }\n    /** * @description Checks equality based on the connection URI.\n     * @param {unknown} other - The object to compare with.\n     * @returns {boolean} True if the URIs are identical.\n     */\n    equals(other) {\n        if (this === other)\n            return true;\n        if (other == null || !(other instanceof Connection))\n            return false;\n        return this.uri === other.uri;\n    }\n    /** * @description Calculates hash code based on the connection URI.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        let hash = 0;\n        for (let i = 0; i < this.uri.length; i++) {\n            const char = this.uri.charCodeAt(i);\n            hash = ((hash << 5) - hash) + char;\n            hash |= 0;\n        }\n        return hash;\n    }\n}\nexports.Connection = Connection;\n//# sourceMappingURL=aether_client_connection_base.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client_connection_base.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client_connection_reg.js":
/*!**************************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client_connection_reg.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_client_connection_reg.ts ( )\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionRegistration = void 0;\nconst aether_work_proof_1 = __webpack_require__(/*! ./aether_work_proof */ \"./node_modules/aether-client/build/aether_work_proof.js\");\nconst aether_crypto_utils_1 = __webpack_require__(/*! ./aether_crypto_utils */ \"./node_modules/aether-client/build/aether_crypto_utils.js\");\nconst aether_crypto_1 = __webpack_require__(/*! ./aether_crypto */ \"./node_modules/aether-client/build/aether_crypto.js\");\nconst aether_fastmeta_1 = __webpack_require__(/*! ./aether_fastmeta */ \"./node_modules/aether-client/build/aether_fastmeta.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_client_connection_base_1 = __webpack_require__(/*! ./aether_client_connection_base */ \"./node_modules/aether-client/build/aether_client_connection_base.js\");\n/**\n * @class ConnectionRegistration\n * @extends {Connection<ClientApiRegUnsafe, RegistrationRootApiRemote>}\n * @implements {ClientApiRegUnsafe}\n * @description Manages the initial connection and registration process with the Aether cloud.\n */\nclass ConnectionRegistration extends aether_client_connection_base_1.Connection {\n    /**\n     * @private\n     * @readonly\n     * @type {AKey.Symmetric}\n     */\n    tempKey;\n    /**\n     * @private\n     * @readonly\n     * @type {Key}\n     */\n    tempKeyNative;\n    /**\n     * @private\n     * @readonly\n     * @type {CryptoEngine}\n     */\n    tempKeyCp;\n    /**\n     * @private\n     * @readonly\n     * @type {FastApiContext}\n     */\n    ctxSafe;\n    /**\n     * @private\n     * @readonly\n     * @type {FastApiContext}\n     */\n    globalCtx;\n    /**\n     * @private\n     * @type {(CryptoEngine | null)}\n     */\n    gcp = null;\n    /**\n     * @constructor\n     * @param {AetherCloudClient} client The main client instance.\n     * @param {URI} uri The registration server URI.\n     */\n    constructor(client, uri) {\n        // 1. USE CORRECT META:\n        //    LT (Local)  = ClientApiRegUnsafe.META\n        //    RT (Remote) = RegistrationRootApi.META\n        super(client, uri, aether_api_1.ClientApiRegUnsafe.META, aether_api_1.RegistrationRootApi.META);\n        // 2. Initialize crypto fields\n        const cryptoLib = client.state.getCryptoLib();\n        const provider = aether_crypto_1.CryptoProviderFactory.getProvider(cryptoLib);\n        this.tempKey = provider.createSymmetricKey();\n        this.tempKeyNative = aether_crypto_utils_1.CryptoUtils.aKeyToDtoKey(this.tempKey);\n        this.tempKeyCp = this.tempKey.toCryptoEngine();\n        // 3. Initialize stub contexts\n        // =================================================================\n        // : (  Java)\n        //   .flush().    \n        //    fromRemoteConsumer,    .flush().\n        // =================================================================\n        this.ctxSafe = new aether_fastmeta_1.FastApiContext();\n        this.globalCtx = new aether_fastmeta_1.FastApiContext();\n        // 4. NOTE: Connection is *not* started here.\n        // The AetherCloudClient must call registration()\n    }\n    /**\n     * @private\n     * @description (Port from Java) Fetches, verifies, and returns the server's asymmetric public key engine.\n     * @returns {ARFuture<CryptoEngine>} A future that resolves with the CryptoEngine.\n     */\n    getAsymmetricPublicKey() {\n        const result = aether_future_1.ARFuture.of();\n        this.getRootApiFuture()\n            .to((api) => {\n            aether_logging_1.Log.debug(\"RegConn: WS connection successful, requesting asymmetric key.\", { uri: this.uri });\n            api.getAsymmetricPublicKey(this.client.state.getCryptoLib())\n                .to((signedKey) => {\n                try {\n                    if (!this.client.verifySign(aether_crypto_utils_1.CryptoUtils.dtoSignedKeyToInternal(signedKey))) {\n                        throw new Error(\"Key verification exception\");\n                    }\n                    const asymAKey = aether_crypto_utils_1.CryptoUtils.dtoKeyToAKey(signedKey.key);\n                    const asymCE = asymAKey.toCryptoEngine();\n                    result.tryDone(asymCE);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"RegConn: Failed to verify asymmetric public key.\", e, { uri: this.uri });\n                    result.tryError(e);\n                }\n            })\n                .onError((e) => {\n                aether_logging_1.Log.error(\"RegConn: Failed to get asymmetric public key.\", e, { uri: this.uri });\n                result.tryError(e);\n            });\n            api.flush();\n        })\n            .onError((e) => {\n            aether_logging_1.Log.error(\"RegConn: Initial connection failed.\", e, { uri: this.uri });\n            result.tryError(e);\n        });\n        return result;\n    }\n    /**\n     * @description (Port from Java) Starts the asynchronous registration process.\n     * @returns {AFuture} A future that completes when the connection is established (but not necessarily registered).\n     */\n    registration() {\n        aether_logging_1.Log.debug(\"RegConn: Starting async registration process.\", { uri: this.uri });\n        this.getAsymmetricPublicKey()\n            .to((asymCE) => {\n            this.regProcess(asymCE);\n        })\n            .onError((e) => {\n            this.connectFuture.tryError(e);\n        });\n        return this.connectFuture.toFuture();\n    }\n    /**\n     * @private\n     * @description (Port from Java) Main registration logic flow.\n     * @param {CryptoEngine} asymCE The verified asymmetric crypto engine from the server.\n     */\n    regProcess(asymCE) {\n        aether_logging_1.Log.info(\"RegConn: Asym public key was received.\");\n        this.getRootApiFuture()\n            .to((api) => {\n            if (!api) {\n                aether_logging_1.Log.error(\"RegConn: Root API is null after successful connection.\");\n                this.connectFuture.tryError(new Error(\"Root API is null\"));\n                return;\n            }\n            api.enter(this.client.state.getCryptoLib(), aether_api_1.ServerRegistrationApiStream.fromRemoteConsumer(this.ctxSafe, asymCE.encrypt.bind(asymCE), (apiInner) => {\n                apiInner.setReturnKey(this.tempKeyNative);\n                apiInner.requestWorkProofData(this.client.getParent(), aether_api_1.PowMethod.AE_BCRYPT_CRC32)\n                    .to((wpd) => {\n                    this.handlePoWAndRegister(api, asymCE, wpd);\n                })\n                    .onError((e) => {\n                    aether_logging_1.Log.error(\"RegConn: Failed to request work proof data.\", e, { uri: this.uri });\n                    this.connectFuture.error(e);\n                });\n            }));\n            api.flush();\n        })\n            .onError((e) => {\n            this.connectFuture.error(e);\n        });\n    }\n    /**\n     * @private\n     * @description (Port from Java) Handles PoW calculation and sends the registration request.\n     * @param {RegistrationRootApiRemote} api The root API.\n     * @param {CryptoEngine} asymCE The asymmetric crypto engine.\n     * @param {WorkProofDTO} workProofDTO The PoW challenge data.\n     */\n    handlePoWAndRegister(api, asymCE, workProofDTO) {\n        try {\n            aether_logging_1.Log.info(\"RegConn: WorkProofData has been received. Starting PoW calculation.\");\n            const passwords = aether_work_proof_1.WorkProofUtil.generateProofOfWorkPool(workProofDTO.getSalt(), workProofDTO.getSuffix(), workProofDTO.getMaxHashVal(), workProofDTO.getPoolSize(), 5000 // 5 seconds\n            );\n            if (!this.client.verifySign(aether_crypto_utils_1.CryptoUtils.dtoSignedKeyToInternal(workProofDTO.getGlobalKey()))) {\n                throw new Error(\"Global key verification failed.\");\n            }\n            const globalAKey = aether_crypto_utils_1.CryptoUtils.dtoKeyToAKey(workProofDTO.getGlobalKey().getKey());\n            const masterKeyAKey = this.client.getMasterKeyAKey();\n            this.gcp = aether_crypto_1.CryptoEngine.of(globalAKey.asAsymmetric().toCryptoEngine(), masterKeyAKey.asSymmetric().toCryptoEngine());\n            api.enter(this.client.state.getCryptoLib(), aether_api_1.ServerRegistrationApiStream.fromRemoteConsumer(this.ctxSafe, asymCE.encrypt.bind(asymCE), (a2) => {\n                a2.setReturnKey(this.tempKeyNative);\n                a2.registration(workProofDTO.getSalt(), workProofDTO.getSuffix(), passwords, this.client.getParent(), aether_api_1.GlobalApi.fromRemoteConsumer(this.globalCtx, this.gcp.encrypt.bind(this.gcp), (gapi) => {\n                    gapi.setMasterKey(aether_crypto_utils_1.CryptoUtils.aKeyToDtoKey(this.client.getMasterKeyAKey()));\n                    gapi.finish()\n                        .to((finishResult) => {\n                        this.handleRegistrationFinish(finishResult, asymCE);\n                    })\n                        .onError((e) => {\n                        aether_logging_1.Log.error(\"RegConn: Failed to finish registration.\", e, { uri: this.uri });\n                        this.connectFuture.error(e);\n                    });\n                }));\n            }));\n            api.flush();\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"RegConn: Registration step 2 (PoW) failed.\", e, { uri: this.uri });\n            this.connectFuture.error(e);\n        }\n    }\n    /**\n     * @private\n     * @description (Port from Java) Finalizes registration and triggers background server resolution.\n     * @param {FinishResultGlobalRegServerApi} finishResult The result from the server.\n     * @param {CryptoEngine} asymCE The asymmetric crypto engine.\n     */\n    handleRegistrationFinish(finishResult, asymCE) {\n        try {\n            aether_logging_1.Log.trace(\"RegConn: registration step finish.\");\n            this.client.confirmRegistration(finishResult);\n            aether_logging_1.Log.info(\"RegConn: Registration confirmed.\");\n            this.resolveCloud(finishResult.getCloud(), asymCE);\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"RegConn: Registration step 3 (Finalize) failed.\", e, { uri: this.uri });\n            this.connectFuture.error(e);\n        }\n    }\n    /**\n     * @private\n     * @description (Port from Java) Resolves server descriptors in the background.\n     * @param {Cloud} cloud The cloud data containing server IDs.\n     * @param {CryptoEngine} asymCE The asymmetric crypto engine.\n     * @returns {AFuture} A future that completes when resolution is attempted.\n     */\n    resolveCloud(cloud, asymCE) {\n        // TODO: The Java version has a client.isRecoveryInProgress check here.\n        // This is omitted as it's part of AetherCloudClient logic not fully ported.\n        const result = aether_future_1.AFuture.make();\n        this.getRootApiFuture().to((api) => {\n            api.enter(this.client.state.getCryptoLib(), aether_api_1.ServerRegistrationApiStream.fromRemoteConsumer(this.ctxSafe, asymCE.encrypt.bind(asymCE), (a3) => {\n                aether_logging_1.Log.trace(\"RegConn: registration step resolve servers:\", { cloud: cloud });\n                a3.resolveServers(cloud)\n                    .to((ss) => {\n                    for (const s of ss) {\n                        this.client.servers.putResolved(s.id, s);\n                    }\n                    aether_logging_1.Log.info(\"RegConn: Server descriptors resolved.\");\n                    result.tryDone();\n                })\n                    .onError((e) => {\n                    aether_logging_1.Log.error(\"RegConn: background resolveServers failed.\", e);\n                    result.tryError(e);\n                });\n            }));\n            api.flush();\n        }).onError((e) => {\n            aether_logging_1.Log.error(\"RegConn: Failed to get rootApi for resolveCloud.\", e);\n            result.tryError(e);\n        });\n        return result;\n    }\n    /**\n     * @description Called by the server to enter the GlobalApiStream.\n     * @param {GlobalRegClientApiStream} stream The incoming data stream.\n     * @returns {AFuture} A future that completes when the stream is accepted.\n     */\n    enterGlobal(stream) {\n        if (!this.gcp) {\n            const err = new Error(\"enterGlobal called before gcp engine was initialized.\");\n            aether_logging_1.Log.error(err.message);\n            return aether_future_1.AFuture.ofThrow(err);\n        }\n        try {\n            stream.accept(this.globalCtx, this.gcp.decrypt.bind(this.gcp), {});\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Failed to accept enterGlobal stream\", e);\n            return aether_future_1.AFuture.ofThrow(e);\n        }\n        return aether_future_1.AFuture.of();\n    }\n    /**\n     * @description Called by the server to enter the ClientApiRegSafeStream.\n     * @param {ClientApiRegSafeStream} stream The incoming data stream.\n     * @returns {AFuture} A future that completes when the stream is accepted.\n     */\n    enter(stream) {\n        try {\n            stream.accept(this.ctxSafe, this.tempKeyCp.decrypt.bind(this.tempKeyCp), {});\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Failed to accept enter stream\", e, { data: stream.data, tempKey_cp: this.tempKeyCp });\n            return aether_future_1.AFuture.ofThrow(e);\n        }\n        return aether_future_1.AFuture.of();\n    }\n}\nexports.ConnectionRegistration = ConnectionRegistration;\n//# sourceMappingURL=aether_client_connection_reg.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client_connection_reg.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client_connection_work.js":
/*!***************************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client_connection_work.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// ---   aether_client_connection_work.ts ---\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionWork = void 0;\nconst aether_client_connection_base_1 = __webpack_require__(/*! ./aether_client_connection_base */ \"./node_modules/aether-client/build/aether_client_connection_base.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_fastmeta_1 = __webpack_require__(/*! ./aether_fastmeta */ \"./node_modules/aether-client/build/aether_fastmeta.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n/**\n * Local implementation of the `ClientApiSafe` interface, handling messages received from the server.\n */\nclass MyClientApiSafe {\n    client;\n    constructor(client) {\n        this.client = client;\n    }\n    // ---  AccessGroup (  ) ---\n    sendAccessGroups(groups) {\n        aether_logging_1.Log.debug(`Received ${groups.length} AccessGroups`, { component: \"MyClientApiSafe\" });\n        for (const group of groups) {\n            if (group) {\n                this.client.accessGroups.putResolved(group.getId(), group);\n            }\n        }\n        return aether_future_1.AFuture.of();\n    }\n    sendAccessGroupForClient(uid, groups) {\n        aether_logging_1.Log.debug(\"Received AccessGroups for client\", { component: \"MyClientApiSafe\", uid: uid.toString().toString() });\n        this.client.clientGroups.putResolved(uid, new Set(groups));\n        return aether_future_1.AFuture.of();\n    }\n    addItemsToAccessGroup(id, groups) {\n        aether_logging_1.Log.debug(\"Server confirmed ADD items to group\", { component: \"MyClientApiSafe\", gid: id, count: groups.length });\n        const futures = this.client.accessOperationsAdd.get(id);\n        if (futures) {\n            for (const uid of groups) {\n                const uidStr = uid.toString().toString();\n                const future = futures.get(uidStr);\n                if (future) {\n                    futures.delete(uidStr);\n                    future.tryDone(true);\n                }\n            }\n            if (futures.size === 0) {\n                this.client.accessOperationsAdd.delete(id);\n            }\n        }\n        //  BMap-\n        // ***  (TS7006) ***\n        this.client.accessGroups.getFuture(id).to((group) => {\n            if (group) {\n                const newUuids = new Set(group.getData());\n                groups.forEach(uid => newUuids.add(uid));\n                // ***  (TS2345) ***\n                //  `newUuids`   Set<UUID>, `Array.from`  UUID[]\n                const newGroup = new aether_api_1.AccessGroup(group.getOwner(), group.getId(), Array.from(newUuids)); //\n                this.client.accessGroups.putResolved(id, newGroup);\n            }\n        });\n        return aether_future_1.AFuture.of();\n    }\n    removeItemsFromAccessGroup(id, groups) {\n        aether_logging_1.Log.debug(\"Server confirmed REMOVE items from group\", { component: \"MyClientApiSafe\", gid: id, count: groups.length });\n        const futures = this.client.accessOperationsRemove.get(id);\n        if (futures) {\n            for (const uid of groups) {\n                const uidStr = uid.toString().toString();\n                const future = futures.get(uidStr);\n                if (future) {\n                    futures.delete(uidStr);\n                    future.tryDone(true);\n                }\n            }\n            if (futures.size === 0) {\n                this.client.accessOperationsRemove.delete(id);\n            }\n        }\n        //  BMap-\n        // ***  (TS7006) ***\n        this.client.accessGroups.getFuture(id).to((group) => {\n            if (group) {\n                const groupsToRemoveSet = new Set(groups.map(u => u.toString().toString()));\n                // ***  (TS7006) ***\n                const filteredUuids = group.getData().filter((u) => !groupsToRemoveSet.has(u.toString().toString())); //\n                const newGroup = new aether_api_1.AccessGroup(group.getOwner(), group.getId(), filteredUuids);\n                this.client.accessGroups.putResolved(id, newGroup);\n            }\n        });\n        return aether_future_1.AFuture.of();\n    }\n    addAccessGroupsToClient(uid, groups) {\n        aether_logging_1.Log.debug(\"Server pushed ADD groups to client\", { component: \"MyClientApiSafe\", uid: uid.toString().toString() });\n        // ***  (TS7006) ***\n        this.client.clientGroups.getFuture(uid).to((existingGroups) => {\n            const newGroups = existingGroups ? new Set(existingGroups) : new Set();\n            for (const g of groups)\n                newGroups.add(g);\n            // ***  (TS2345) ***\n            // `newGroups`  Set<bigint>,  \n            this.client.clientGroups.putResolved(uid, newGroups); //\n        });\n        return aether_future_1.AFuture.of();\n    }\n    removeAccessGroupsFromClient(uid, groups) {\n        aether_logging_1.Log.debug(\"Server pushed REMOVE groups from client\", { component: \"MyClientApiSafe\", uid: uid.toString().toString() });\n        // ***  (TS7006) ***\n        this.client.clientGroups.getFuture(uid).to((existingGroups) => {\n            if (existingGroups) {\n                const newGroups = new Set(existingGroups);\n                for (const g of groups)\n                    newGroups.delete(g);\n                // ***  (TS2345) ***\n                // `newGroups`  Set<bigint>,  \n                this.client.clientGroups.putResolved(uid, newGroups); //\n            }\n        });\n        return aether_future_1.AFuture.of();\n    }\n    sendAllAccessedClients(uid, accessedClients) {\n        aether_logging_1.Log.debug(`Received ${accessedClients.length} AccessedClients for ${uid.toString().toString()}`, { component: \"MyClientApiSafe\" });\n        this.client.allAccessedClients.putResolved(uid, new Set(accessedClients));\n        return aether_future_1.AFuture.of();\n    }\n    sendAccessCheckResults(results) {\n        aether_logging_1.Log.debug(`Received ${results.length} AccessCheckResults`, { component: \"MyClientApiSafe\" });\n        for (const result of results) {\n            if (result) {\n                this.client.accessCheckCache.putResolved(new aether_api_1.AccessCheckPair(result.getSourceUid(), result.getTargetUid()), result.isHasAccess());\n            }\n        }\n        return aether_future_1.AFuture.of();\n    }\n    // ---   ---\n    changeParent(_uid) {\n        aether_logging_1.Log.warn(\"MyClientApiSafe.changeParent not implemented\");\n        return aether_future_1.AFuture.of();\n    }\n    changeAlias(_alias) {\n        aether_logging_1.Log.warn(\"MyClientApiSafe.changeAlias not implemented\");\n        return aether_future_1.AFuture.of();\n    }\n    newChild(uid) {\n        aether_logging_1.Log.trace(\"newChild received\", { component: \"MyClientApiSafe\", uid: uid.toString().toString() });\n        this.client.onNewChild.fire(uid);\n        return aether_future_1.AFuture.of();\n    }\n    sendMessages(msg) {\n        aether_logging_1.Log.trace(\"receive messages\", { component: \"MyClientApiSafe\", count: msg.length });\n        for (const m of msg) {\n            const senderUid = m.getUid();\n            aether_logging_1.Log.trace(\"receive message\", { targetUid: this.client.getUid()?.toString().toString(), sourceUid: senderUid?.toString().toString(), dataLen: m.getData().length });\n            if (senderUid) {\n                this.client.onMessage.fire(senderUid, m.getData());\n            }\n            else {\n                aether_logging_1.Log.warn(\"Received message with null sender UID\");\n            }\n        }\n        return aether_future_1.AFuture.of();\n    }\n    sendServerDescriptor(v) {\n        aether_logging_1.Log.trace(\"sendServerDescriptor received\", { component: \"MyClientApiSafe\", serverId: v.id });\n        this.client.servers.putResolved(v.id, v);\n        return aether_future_1.AFuture.of();\n    }\n    sendServerDescriptors(serverDescriptors) {\n        aether_logging_1.Log.trace(\"sendServerDescriptors received\", { component: \"MyClientApiSafe\", count: serverDescriptors.length });\n        serverDescriptors.forEach(c => this.sendServerDescriptor(c));\n        return aether_future_1.AFuture.of();\n    }\n    sendCloud(uid, cloud) {\n        aether_logging_1.Log.trace(\"sendCloud received\", { component: \"MyClientApiSafe\", uid: uid.toString().toString() });\n        this.client.setCloud(uid, cloud);\n        return aether_future_1.AFuture.of();\n    }\n    sendClouds(clouds) {\n        aether_logging_1.Log.trace(\"sendClouds received\", { component: \"MyClientApiSafe\", count: clouds.length });\n        clouds.forEach(c => this.sendCloud(c.getUid(), c.getCloud()));\n        return aether_future_1.AFuture.of();\n    }\n    requestTelemetry() {\n        aether_logging_1.Log.warn(\"MyClientApiSafe.requestTelemetry not implemented\");\n        return aether_future_1.AFuture.of();\n    }\n}\n/**\n * Represents a working connection to an Aether server after successful login/authentication.\n */\nclass ConnectionWork extends aether_client_connection_base_1.Connection {\n    lastBackPing = new aether_types_1.AtomicLong(Number.MAX_SAFE_INTEGER);\n    ready = aether_future_1.AFuture.make();\n    apiSafe;\n    apiSafeCtx;\n    cryptoEngine;\n    remoteApiFutureAuth = new aether_fastmeta_1.RemoteApiFuture(aether_api_1.AuthorizedApi.META);\n    serverDescriptor;\n    inProcess = new aether_types_1.AtomicReference(false);\n    basicStatus = false;\n    lastWorkTime = 0;\n    firstAuth = false;\n    hasPendingMessages() {\n        for (const m of this.client.messageNodeMap.values()) {\n            if (m.connectionsOut.has(this) && !m.bufferOut.isEmpty()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    constructor(client, s) {\n        const uri = (0, aether_client_connection_base_1.getUriFromServerDescriptor)(s, aether_api_1.AetherCodec.WS);\n        if (!uri) {\n            throw new aether_types_1.ClientStartException(`Could not determine a valid WebSocket URI for ServerDescriptor ID ${s.id}`);\n        }\n        super(client, uri, aether_api_1.ClientApiUnsafe.META, aether_api_1.LoginApi.META);\n        this.cryptoEngine = client.getCryptoEngineForServer(s.id);\n        this.serverDescriptor = s;\n        this.apiSafe = new MyClientApiSafe(client);\n        this.remoteApiFutureAuth.addPermanent((a, f) => {\n            try {\n                this.flushBackgroundRequests(a, f);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Error in permanent remoteApiFutureAuth task (flushBackgroundRequests)\", e);\n            }\n        });\n        this.apiSafeCtx = new aether_fastmeta_1.FastApiContext();\n        this.apiSafeCtx.flush = (sendFuture) => {\n            //             Log.trace(\"apiSafeCtx.flush initiated\", { component: \"ConnectionWorkFlush\", uri: this.uri });\n            const hasBMapRequests = this.client.clouds.isRequestsFor(this) ||\n                this.client.servers.isRequestsFor(this) ||\n                this.client.clientGroups.isRequestsFor(this) ||\n                this.client.accessGroups.isRequestsFor(this) ||\n                this.client.allAccessedClients.isRequestsFor(this) ||\n                this.client.accessCheckCache.isRequestsFor(this);\n            if (this.remoteApiFutureAuth.isEmpty() &&\n                !hasBMapRequests &&\n                !this.hasPendingMessages() &&\n                this.client.accessOperationsAdd.size === 0 &&\n                this.client.accessOperationsRemove.size === 0 &&\n                this.client.authTasks.isEmpty() &&\n                this.client.clientTasks.isEmpty()) {\n                //                 Log.trace(\"apiSafeCtx.flush: Nothing to send.\");\n                sendFuture.tryDone();\n                return;\n            }\n            if (!this.connectFuture.isDone()) {\n                sendFuture.error(new aether_types_1.ClientApiException(\"Cannot flush apiSafeCtx: Root connection not ready.\"));\n                return;\n            }\n            if (this.connectFuture.isError()) {\n                sendFuture.error(new aether_types_1.ClientApiException(\"Cannot flush apiSafeCtx: Root connection failed.\", this.connectFuture.getError() ?? undefined));\n                return;\n            }\n            const loginApi = this.getRootApi();\n            if (!loginApi) {\n                const errMsg = \"Root Login API is null even after connectFuture completed successfully during apiSafeCtx flush\";\n                aether_logging_1.Log.error(errMsg);\n                sendFuture.error(new Error(errMsg));\n                return;\n            }\n            this.remoteApiFutureAuth.executeAll(this.apiSafeCtx, sendFuture);\n            const dataToSend = this.apiSafeCtx.remoteDataToArrayAsArray();\n            if (dataToSend.length === 0) {\n                //                 Log.trace(\"apiSafeCtx.flush: No data generated by remoteApiFutureAuth.executeAll.\");\n                if (!sendFuture.isFinalStatus())\n                    sendFuture.tryDone();\n                return;\n            }\n            aether_logging_1.Log.trace(`apiSafeCtx.flush: Encrypting ${dataToSend.length} bytes for LoginStream`);\n            const loginStream = aether_api_1.LoginStream.fromRemoteBytes(this.cryptoEngine.encrypt.bind(this.cryptoEngine), dataToSend);\n            const alias = this.client.getAlias();\n            if (!alias) {\n                const errMsg = \"Client alias is not set, cannot login via apiSafeCtx flush.\";\n                aether_logging_1.Log.error(errMsg);\n                sendFuture.error(new Error(errMsg));\n                return;\n            }\n            aether_logging_1.Log.trace(\"apiSafeCtx.flush: Calling loginByAlias\");\n            loginApi.loginByAlias(alias, loginStream);\n            loginApi.flush(sendFuture);\n            aether_logging_1.Log.trace(\"apiSafeCtx.flush: Root API flushed\");\n        };\n        this.connectFuture.to(() => { }).onError((err) => { this.ready.error(err); }).onCancel(() => { this.ready.cancel(); });\n    }\n    flushCloudRequests(a) {\n        const requestCloud = this.client.clouds.getRequestsFor(this);\n        if (requestCloud.length > 0) {\n            aether_logging_1.Log.trace(\"Flushing cloud requests\", { component: \"ConnectionWork\", server: this.uri, count: requestCloud.length, uids: requestCloud.map((u) => u.toString().toString()) });\n            a.resolverClouds(requestCloud);\n        }\n    }\n    flushServerRequests(a) {\n        const requestServersObjects = this.client.servers.getRequestsFor(this);\n        if (requestServersObjects.length > 0) {\n            const serverIds = requestServersObjects.map(id => Number(id));\n            aether_logging_1.Log.trace(\"Flushing server requests\", { component: \"ConnectionWork\", server: this.uri, count: serverIds.length, sids: serverIds });\n            a.resolverServers(serverIds);\n        }\n    }\n    flushMessageQueue(a, sendFuture) {\n        let messagesToSend = null;\n        const futuresToComplete = [];\n        // ***  (TS2304) ***\n        // `MessageNode`  ,  Map \n        const messagesToRequeue = new Map(); //\n        for (const m of this.client.messageNodeMap.values()) {\n            if (m.connectionsOut.has(this)) {\n                const messagesFromNode = [];\n                let msgEntry;\n                while ((msgEntry = m.bufferOut.poll())) {\n                    aether_logging_1.Log.trace(\"read message from bufferOut\", { data: msgEntry.data, uid: m.consumerUUID });\n                    messagesFromNode.push(msgEntry);\n                }\n                if (messagesFromNode.length > 0) {\n                    const consumerUuidString = m.consumerUUID.toString().toString();\n                    aether_logging_1.Log.debug(\"Preparing messages client to server\", {\n                        component: \"ConnectionWork\",\n                        server: this.uri,\n                        uidFrom: this.client.getUid()?.toString().toString(),\n                        uidTo: consumerUuidString,\n                        count: messagesFromNode.length\n                    });\n                    if (messagesToSend === null)\n                        messagesToSend = [];\n                    messagesFromNode.forEach(val => {\n                        messagesToSend.push(new aether_api_1.Message(m.consumerUUID, val.data));\n                        futuresToComplete.push(val.future);\n                    });\n                    messagesToRequeue.set(m, messagesFromNode);\n                }\n            }\n        }\n        if (messagesToSend !== null && messagesToSend.length > 0) {\n            aether_logging_1.Log.trace(`Flushing ${messagesToSend.length} messages`, { component: \"ConnectionWork\", server: this.uri });\n            sendFuture.to(() => {\n                aether_logging_1.Log.trace(\"Message batch send successful (sendFuture success)\", { component: \"ConnectionWork\", server: this.uri });\n                futuresToComplete.forEach(f => f.tryDone());\n            }).onError((err) => {\n                aether_logging_1.Log.error(\"Failed to send message batch (sendFuture error), requeuing\", err, { component: \"ConnectionWork\", server: this.uri });\n                messagesToRequeue.forEach((msgs, node) => {\n                    msgs.reverse().forEach(msg => node.bufferOut.add(msg));\n                    msgs.forEach(msg => msg.future.error(err));\n                });\n            }).onCancel(() => {\n                aether_logging_1.Log.warn(\"Message batch sending cancelled (sendFuture cancel), requeuing\", { component: \"ConnectionWork\", server: this.uri });\n                messagesToRequeue.forEach((msgs, node) => {\n                    msgs.reverse().forEach(msg => node.bufferOut.add(msg));\n                    msgs.forEach(msg => msg.future.cancel());\n                });\n            });\n            a.sendMessages(messagesToSend);\n            return true;\n        }\n        return false;\n    }\n    flushPing(a) {\n        if (!this.firstAuth) {\n            aether_logging_1.Log.trace(\"Sending initial ping\", { component: \"ConnectionWork\", server: this.uri });\n            a.ping(0n).to(() => {\n                aether_logging_1.Log.trace(\"Initial ping successful\", { component: \"ConnectionWork\", server: this.uri });\n                this.firstAuth = true;\n                this.lastBackPing.set(aether_utils_1.RU.time());\n                if (!this.ready.isDone())\n                    this.ready.tryDone();\n            }).onError((err) => {\n                aether_logging_1.Log.warn(\"Initial ping failed\", { component: \"ConnectionWork\", server: this.uri, error: err.message });\n                if (!this.ready.isDone())\n                    this.ready.tryError(err);\n                this.firstAuth = false;\n            });\n        }\n    }\n    flushBackgroundRequests(a, sendFuture) {\n        try {\n            // === 1. BMap Resolution Requests ===\n            this.flushCloudRequests(a);\n            this.flushServerRequests(a);\n            const requestClientGroups = this.client.clientGroups.getRequestsFor(this);\n            if (requestClientGroups.length > 0) {\n                a.requestAccessGroupsForClients(requestClientGroups);\n            }\n            const requestAccessGroups = this.client.accessGroups.getRequestsFor(this);\n            if (requestAccessGroups.length > 0) {\n                a.requestAccessGroupsItems(requestAccessGroups);\n            }\n            const requestAllAccessed = this.client.allAccessedClients.getRequestsFor(this);\n            if (requestAllAccessed.length > 0) {\n                a.requestAllAccessedClients(requestAllAccessed);\n            }\n            const requestAccessCheck = this.client.accessCheckCache.getRequestsFor(this);\n            if (requestAccessCheck.length > 0) {\n                a.requestAccessCheck(requestAccessCheck);\n            }\n            // === 2. Mutation Requests (Access Group Add/Remove) ===\n            for (const [groupId, groupMap] of this.client.accessOperationsAdd.entries()) {\n                const uidsToAdd = Array.from(groupMap.keys()).map(s => aether_types_1.UUID.fromString(s));\n                if (uidsToAdd.length > 0) {\n                    aether_logging_1.Log.debug(\"Flushing ADD request\", { gid: groupId, uids: uidsToAdd.map(u => u.toString().toString()) });\n                    a.addItemsToAccessGroup(groupId, uidsToAdd);\n                }\n            }\n            for (const [groupId, groupMap] of this.client.accessOperationsRemove.entries()) {\n                const uidsToRemove = Array.from(groupMap.keys()).map(s => aether_types_1.UUID.fromString(s));\n                if (uidsToRemove.length > 0) {\n                    aether_logging_1.Log.debug(\"Flushing REMOVE request\", { gid: groupId, uids: uidsToRemove.map(u => u.toString().toString()) });\n                    a.removeItemsFromAccessGroup(groupId, uidsToRemove);\n                }\n            }\n            // === 3. Task Queues (Auth & Client) ===\n            let authTask;\n            while ((authTask = this.client.authTasks.poll())) {\n                authTask(a);\n            }\n            let clientTask;\n            while ((clientTask = this.client.clientTasks.poll())) {\n                const task = clientTask;\n                a.client(task.uid, aether_api_1.ClientApiStream.fromRemoteConsumer(this.apiSafeCtx, (api) => {\n                    task.task(api);\n                }));\n            }\n            // === 4. Message Stream Logic ===\n            const messagesSent = this.flushMessageQueue(a, sendFuture);\n            // === 5. Ping Logic ===\n            this.flushPing(a);\n            if (!messagesSent && !sendFuture.isFinalStatus()) {\n                sendFuture.tryDone();\n            }\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Error during flushBackgroundRequests\", e, { component: \"ConnectionWork\", server: this.uri });\n            if (!sendFuture.isFinalStatus())\n                sendFuture.error(e);\n        }\n    }\n    sendSafeApiDataMulti(_backId, _data) {\n        const err = new Error(\"UnsupportedOperationException: sendSafeApiDataMulti is not supported in TS client\");\n        aether_logging_1.Log.error(\"UnsupportedOperationException\", err);\n        return aether_future_1.AFuture.ofThrow(err);\n    }\n    sendSafeApiData(data) {\n        const future = aether_future_1.AFuture.make();\n        try {\n            aether_logging_1.Log.trace(\"Received sendSafeApiData stream\", { component: \"ConnectionWork\", server: this.uri, dataLen: data.data.length });\n            data.accept(this.apiSafeCtx, this.cryptoEngine.decrypt.bind(this.cryptoEngine), this.apiSafe);\n            aether_logging_1.Log.trace(\"sendSafeApiData stream processed successfully\", { component: \"ConnectionWork\", server: this.uri });\n            future.tryDone();\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Error processing incoming sendSafeApiData stream\", e, { component: \"ConnectionWork\", server: this.uri });\n            future.error(e);\n        }\n        return future;\n    }\n    getServerDescriptor() {\n        return this.serverDescriptor;\n    }\n    toString() {\n        const uri = (0, aether_client_connection_base_1.getUriFromServerDescriptor)(this.serverDescriptor, aether_api_1.AetherCodec.WS) ?? `serverID=${this.serverDescriptor.id}`;\n        return `work(${uri})`;\n    }\n    setBasic(basic) {\n        this.basicStatus = basic;\n    }\n    lifeTime() {\n        return aether_utils_1.RU.time() - this.lastBackPing.get();\n    }\n    logTime = 0;\n    scheduledWork() {\n        const t = aether_utils_1.RU.time();\n        const timeSinceLastPing = t - this.lastBackPing.get();\n        const pingInterval = this.client.getPingTime();\n        if ((t - this.lastWorkTime < pingInterval && timeSinceLastPing < pingInterval * 3) || !this.inProcess.compareAndSet(false, true)) {\n            return;\n        }\n        if (aether_utils_1.RU.time() - this.logTime > 1000) {\n            this.logTime = aether_utils_1.RU.time();\n            aether_logging_1.Log.trace(\"Executing scheduledWork (flush)\", { component: \"ConnectionWork\", server: this.uri });\n        }\n        this.lastWorkTime = t;\n        const f = aether_future_1.AFuture.make();\n        f.addListener(() => this.inProcess.set(false));\n        f.timeoutError(Math.max(5, pingInterval / 1000 * 2), `scheduledWork flush timeout on ${this.uri}`);\n        this.apiSafeCtx.flush(f);\n    }\n    flush() {\n        if (!this.inProcess.compareAndSet(false, true)) {\n            //             Log.trace(\"Flush skipped: Already in process\", { component: \"ConnectionWork\" });\n            return;\n        }\n        const rootFuture = this.getRootApiFuture();\n        const isReady = rootFuture.isDone();\n        const isFailed = rootFuture.isError();\n        const isCancelled = rootFuture.isCanceled();\n        if (!isReady || isFailed || isCancelled || !this.rootApi) {\n            //             Log.warn(\"Flush skipped: Root API not available or connection closed/errored.\", { uri: this.uri, isReady, isFailed, isCancelled, hasRootApi: !!this.rootApi });\n            this.inProcess.set(false);\n            return;\n        }\n        //         Log.trace(\"Executing explicit flush\", { component: \"ConnectionWork\", server: this.uri });\n        this.lastWorkTime = aether_utils_1.RU.time();\n        const f = aether_future_1.AFuture.make();\n        f.addListener(() => this.inProcess.set(false));\n        f.timeoutError(5, `explicit flush timeout on ${this.uri}`);\n        this.apiSafeCtx.flush(f);\n    }\n}\nexports.ConnectionWork = ConnectionWork;\n// ---   aether_client_connection_work.ts ---\n//# sourceMappingURL=aether_client_connection_work.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client_connection_work.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client_message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client_message.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MessageNode = exports.MessageEventListenerDefault = void 0;\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n// --- [ ] ---\n//      toApi\nconst aether_fastmeta_1 = __webpack_require__(/*! ./aether_fastmeta */ \"./node_modules/aether-client/build/aether_fastmeta.js\");\nconst aether_datainout_1 = __webpack_require__(/*! ./aether_datainout */ \"./node_modules/aether-client/build/aether_datainout.js\");\n/**\n * @description Default implementation of the connection resolution strategy.\n * ( )\n */\nexports.MessageEventListenerDefault = {\n    setConsumerCloud: (messageNode, cloud) => {\n        // ... (  ) ...\n        aether_logging_1.Log.debug(\"Strategy: setConsumerCloud called\", { component: \"MsgEvListenerDefault\", uidTo: messageNode.consumerUUID.toString() });\n        if (cloud?.data?.length > 0) {\n            aether_logging_1.Log.debug(\"Strategy: Cloud has servers. Requesting server descriptor...\", { component: \"MsgEvListenerDefault\", serverId: cloud.data[0] });\n            messageNode.addConsumerServerOutById(cloud.data[0]);\n        }\n        else {\n            aether_logging_1.Log.warn(\"Received null or empty cloud, cannot establish connection.\", { cloud });\n            let msg;\n            while ((msg = messageNode.bufferOut.poll())) {\n                msg.future.error(new Error(`Could not resolve cloud/server for consumer ${messageNode.consumerUUID}`));\n            }\n        }\n    },\n    onResolveConsumerServer: (messageNode, serverDescriptor) => {\n        // ... (  ) ...\n        aether_logging_1.Log.debug(\"Strategy: onResolveConsumerServer called\", { component: \"MsgEvListenerDefault\", uidTo: messageNode.consumerUUID.toString(), serverId: serverDescriptor.id });\n        messageNode.addConsumerServerOutByDescriptor(serverDescriptor);\n    },\n    onResolveConsumerConnection: (messageNode, connection) => {\n        // ... (  ) ...\n        aether_logging_1.Log.debug(\"Strategy: onResolveConsumerConnection called\", { component: \"MsgEvListenerDefault\", uidTo: messageNode.consumerUUID.toString(), uri: connection.uri });\n        messageNode.addConsumerConnectionOut(connection);\n    },\n};\n/**\n * @class MessageNode\n * ( ...  `send`)\n */\nclass MessageNode {\n    connectionsOut = new Set();\n    bufferOut = new aether_utils_1.Queue();\n    bufferIn = new aether_future_1.EventConsumer();\n    consumerUUID;\n    client;\n    strategy;\n    constructor(client, consumerId, strategy) {\n        // ... (   ) ...\n        aether_logging_1.Log.trace(\"Creating MessageNode\", {\n            component: \"MessageNode\",\n            uidFrom: client.getUid()?.toString() ?? \"N/A\",\n            uidTo: consumerId.toString()\n        });\n        this.client = client;\n        this.consumerUUID = consumerId;\n        this.strategy = strategy;\n        this.client.getCloud(consumerId).to((c) => {\n            if (c) {\n                aether_logging_1.Log.debug(\"Cloud resolution SUCCESS\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString(), cloudData: c.data });\n                try {\n                    this.strategy.setConsumerCloud(this, c);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in strategy.setConsumerCloud\", e);\n                }\n            }\n            else {\n                aether_logging_1.Log.warn(\"Cloud resolution FAILED (result was null)\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString() });\n                let msg;\n                while ((msg = this.bufferOut.poll())) {\n                    msg.future.error(new Error(`Could not resolve cloud for consumer ${this.consumerUUID}`));\n                }\n            }\n        }).onError((err) => {\n            aether_logging_1.Log.error(\"Cloud resolution FAILED (exception thrown)\", err, { component: \"MessageNode\", uidTo: this.consumerUUID.toString() });\n            let msg;\n            while ((msg = this.bufferOut.poll())) {\n                msg.future.error(new Error(`Failed to get cloud for consumer ${this.consumerUUID}: ${err.message}`));\n            }\n        });\n    }\n    // \n    send(data, future) {\n        const sendFuture = future ?? aether_future_1.AFuture.make();\n        const message = { data, future: sendFuture };\n        this.bufferOut.add(message);\n        aether_logging_1.Log.trace(\"MessageNode: Added message to bufferOut\");\n        if (this.connectionsOut.size === 0) {\n            aether_logging_1.Log.trace(\"MessageNode: Message buffered, no connections yet.\");\n        }\n        return sendFuture;\n    }\n    // --- ( addConsumer...  ) ---\n    addConsumerServerOutById(serverId) {\n        this.client.getServer(serverId).to((sd) => {\n            if (sd) {\n                try {\n                    this.strategy.onResolveConsumerServer(this, sd);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in strategy.onResolveConsumerServer\", e, { serverId });\n                }\n            }\n            else {\n                aether_logging_1.Log.warn(\"Server descriptor resolved to null\", { serverId });\n            }\n        }).onError((err) => aether_logging_1.Log.error(\"Failed to resolve server ID in addConsumerServerOutById\", err, { serverId }));\n    }\n    addConsumerServerOutByDescriptor(serverDescriptor) {\n        try {\n            const connection = this.client.getConnection(serverDescriptor);\n            this.strategy.onResolveConsumerConnection(this, connection);\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Error resolving/passing connection in addConsumerServerOutByDescriptor\", e);\n        }\n    }\n    addConsumerConnectionOut(conn) {\n        aether_logging_1.Log.debug(\"Attempting to add connection to connectionsOut\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString(), server: conn.uri, currentSize: this.connectionsOut.size });\n        if (this.connectionsOut.has(conn)) {\n            aether_logging_1.Log.trace(\"Connection already added, skipping.\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString(), server: conn.uri });\n            return;\n        }\n        this.connectionsOut.add(conn);\n        aether_logging_1.Log.info(\"SUCCESS: Added new outgoing connection\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString(), server: conn.uri, newSize: this.connectionsOut.size });\n    }\n    removeConsumerConnectionOut(conn) {\n        if (this.connectionsOut.delete(conn)) {\n            aether_logging_1.Log.warn(\"Removing outgoing connection\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString(), server: conn.uri, newSize: this.connectionsOut.size });\n            if (this.connectionsOut.size === 0 && this.bufferOut.size() > 0) {\n                aether_logging_1.Log.warn(\"Last connection removed, triggering cloud resolution again for buffered messages.\", { component: \"MessageNode\" });\n                this.client.getCloud(this.consumerUUID).to((c) => { if (c)\n                    this.strategy.setConsumerCloud(this, c); });\n            }\n        }\n    }\n    sendMessageFromServerToClient(data) {\n        aether_logging_1.Log.trace(\"Received message from server\", { component: \"MessageNode\", uidTo: this.consumerUUID.toString() });\n        this.bufferIn.fire({ data });\n    }\n    toConsumer(o) {\n        this.bufferIn.add((msg) => o(msg.data));\n    }\n    getConsumerUUID() { return this.consumerUUID; }\n    // --- [ ]   MessageNode.java ---\n    /**\n     * @description  FastApiContext,  \"\" (flushes)    MessageNode,\n     *      API.\n     * (  MessageNode.java)\n     */\n    toApiR(metaLt, localApiFactory) {\n        const nodeSend = this.send.bind(this);\n        const ctx = new (class extends aether_fastmeta_1.FastApiContextLocal {\n            constructor() {\n                super(localApiFactory); //  \n            }\n            flush(sendFuture) {\n                const d = this.remoteDataToArrayAsArray();\n                if (d.length > 0) {\n                    nodeSend(d).to(sendFuture); //  send(data)\n                }\n                else {\n                    sendFuture.tryDone();\n                }\n            }\n        })();\n        // ctx.localApi  \n        this.toApi(ctx, metaLt, ctx.localApi);\n        return ctx;\n    }\n    // \n    toApi(arg1, arg2, arg3) {\n        // ---  1: toApi(ctx, meta, localApi) ---\n        // (  SmartHomeService.java)\n        if (arg1 instanceof aether_fastmeta_1.FastApiContext) {\n            const ctx = arg1;\n            const metaLt = arg2;\n            const localApi = arg3;\n            this.toConsumer((v) => {\n                if (v.length === 0)\n                    return;\n                try {\n                    metaLt.makeLocal_fromDataIn(ctx, new aether_datainout_1.DataInOutStatic(v), localApi);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in toApi.makeLocal\", e, { component: \"MessageNode\" });\n                }\n            });\n            return;\n        }\n        // ---  2: toApi(meta, localApi) ---\n        // (   SmartHomeController.ts)\n        if (arg3 === undefined) {\n            const metaLt = arg1;\n            const localApi = arg2;\n            const nodeSend = this.send.bind(this); // bind 'this'\n            const ctx = new (class extends aether_fastmeta_1.FastApiContextLocal {\n                constructor() {\n                    super(localApi);\n                }\n                flush(sendFuture) {\n                    const d = this.remoteDataToArrayAsArray();\n                    if (d.length > 0) {\n                        nodeSend(d).to(sendFuture); //  send(data)\n                    }\n                    else {\n                        sendFuture.tryDone();\n                    }\n                }\n            })();\n            //   1,   consumer\n            this.toApi(ctx, metaLt, localApi);\n            return ctx;\n        }\n        // \n        throw new Error(\"Invalid toApi overload\");\n    }\n}\nexports.MessageNode = MessageNode;\n//# sourceMappingURL=aether_client_message.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client_message.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_client_state.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_client_state.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// FILE: aether_client_state.ts\n// PURPOSE: Contains the implementation of ClientStateInMemory.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientState = exports.ClientStateInMemory = void 0;\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_astring_1 = __webpack_require__(/*! ./aether_astring */ \"./node_modules/aether-client/build/aether_astring.js\");\nconst aether_crypto_1 = __webpack_require__(/*! ./aether_crypto */ \"./node_modules/aether-client/build/aether_crypto.js\");\nconst aether_crypto_utils_1 = __webpack_require__(/*! ./aether_crypto_utils */ \"./node_modules/aether-client/build/aether_crypto_utils.js\");\nconst aether_datainout_1 = __webpack_require__(/*! ./aether_datainout */ \"./node_modules/aether-client/build/aether_datainout.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n/**\n * @class ClientStateInMemory\n * @implements {ClientState}\n * @description In-memory implementation of ClientState for temporary storage of client configuration and data.\n */\nclass ClientStateInMemory {\n    /**\n     * @private\n     * @type {(UUID | null)}\n     */\n    uid = null;\n    /**\n     * @private\n     * @type {(UUID | null)}\n     */\n    alias = null;\n    /**\n     * @private\n     * @type {(Key | null)}\n     */\n    masterKey = null;\n    /**\n     * @private\n     * @type {Map<number, ClientState.ServerInfo>}\n     */\n    servers = new Map();\n    /**\n     * @private\n     * @type {Map<string, ClientState.ClientInfoMutable>}\n     */\n    clients = new Map();\n    /**\n     * @private\n     * @type {URI[]}\n     */\n    registrationUris = [];\n    /**\n     * @private\n     * @type {AMFuture<number>}\n     */\n    pingDuration = aether_future_1.AMFuture.completed(10);\n    /**\n     * @private\n     * @type {UUID}\n     */\n    parentUid;\n    /**\n     * @private\n     * @type {CryptoLib}\n     */\n    cryptoLib = aether_api_1.CryptoLib.HYDROGEN;\n    /**\n     * @private\n     * @type {Map<string, SignChecker>}\n     * @description A map used as a unique-by-content Set for trusted root signers.\n     * The key is the uppercase string representation of the public key (provider:data),\n     * which ensures proper uniqueness mirroring Java's hashCode/equals logic for keys.\n     */\n    rootSigners = new Map();\n    /**\n     * @private\n     * @type {number}\n     */\n    timeoutForConnectToRegistrationServer = 5000;\n    /**\n     * @private\n     * @type {number}\n     */\n    countServersForRegistration = 1;\n    /**\n     * @constructor\n     * @param {UUID | Uint8Array | null} arg1 Parent UUID, loaded state data (Uint8Array), or null/undefined.\n     * @param {URI[] | undefined} arg2 Registration URIs.\n     * @param {Set<SignChecker> | undefined} arg3 Optional set of initial root signers.\n     * @param {CryptoLib | undefined} arg4 Optional CryptoLib preference.\n     */\n    constructor(arg1, arg2, arg3, arg4) {\n        const BaseUUID = aether_utils_1.StandardUUIDs.ROOT_UID.constructor;\n        if (arg1 instanceof Uint8Array) {\n            this.parentUid = aether_utils_1.StandardUUIDs.ANONYMOUS_UID;\n            this.load(arg1);\n        }\n        else if (BaseUUID && arg1 instanceof BaseUUID && arg2 instanceof Array) {\n            if (!arg1)\n                throw new Error(\"Parent UID cannot be null\");\n            this.parentUid = arg1;\n            this.registrationUris = arg2.slice();\n            this.uid = null;\n            this.cryptoLib = arg4 ?? aether_api_1.CryptoLib.SODIUM;\n            if (arg3) {\n                for (const signer of arg3) {\n                    this.addSigner(signer);\n                }\n            }\n            this.addDefaultRootSigners();\n        }\n        else if (arg1 === null && arg2 instanceof Array) {\n            this.parentUid = aether_utils_1.StandardUUIDs.ANONYMOUS_UID;\n            this.registrationUris = arg2.slice();\n            this.uid = null;\n            this.cryptoLib = arg4 ?? aether_api_1.CryptoLib.SODIUM;\n            if (arg3) {\n                for (const signer of arg3) {\n                    this.addSigner(signer);\n                }\n            }\n            this.addDefaultRootSigners();\n        }\n        else {\n            if (arg1 &&\n                typeof arg1.toString === \"function\" &&\n                arg2 instanceof Array) {\n                aether_logging_1.Log.warn(\"ClientStateInMemory constructor: arg1 seems UUID-like but not instanceof BaseUUID.\");\n                this.parentUid = arg1;\n                this.registrationUris = arg2.slice();\n                this.uid = null;\n                this.cryptoLib = arg4 ?? aether_api_1.CryptoLib.SODIUM;\n                if (arg3) {\n                    for (const signer of arg3) {\n                        this.addSigner(signer);\n                    }\n                }\n                this.addDefaultRootSigners();\n            }\n            else {\n                throw new Error(\"Invalid ClientStateInMemory constructor arguments\");\n            }\n        }\n        if (!this.parentUid) {\n            this.parentUid = aether_utils_1.StandardUUIDs.ANONYMOUS_UID;\n        }\n    }\n    setServerDescriptor(serverDescriptor) {\n        this.getServerInfo(serverDescriptor.getId()).setDescriptor(serverDescriptor);\n    }\n    /**\n     * @private\n     * @description Adds default root signers if they are not already present.\n     * The expected string format for SignChecker.of() is \"PROVIDER:KEY_DATA\" (e.g., SODIUM:HEX_DATA).\n     * This format is necessary for the SignChecker parsing logic (via CryptoProviderFactory).\n     */\n    addDefaultRootSigners() {\n        const defaultSignerStrings = [\n            \"SODIUM:4F202A94AB729FE9B381613AE77A8A7D89EDAB9299C3320D1A0B994BA710CCEB\",\n        ];\n        for (const keyString of defaultSignerStrings) {\n            try {\n                const checker = aether_crypto_1.SignChecker.of(keyString);\n                this.addSigner(checker);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Failed to add default root signer\", e, {\n                    keyString,\n                });\n            }\n        }\n    }\n    /**\n     * @private\n     * @description Adds a SignChecker to the internal map, ensuring uniqueness based on the public key's string representation.\n     * @param {SignChecker} signer The signer to add.\n     */\n    addSigner(signer) {\n        const keyString = signer.getPublicKey().keyToString().toUpperCase();\n        this.rootSigners.set(keyString, signer);\n    }\n    /** @inheritDoc */\n    getUid() {\n        return this.uid;\n    }\n    /** @inheritDoc */\n    setUid(uid) {\n        this.uid = uid;\n    }\n    /** @inheritDoc */\n    getAlias() {\n        return this.alias;\n    }\n    /** @inheritDoc */\n    setAlias(alias) {\n        this.alias = alias;\n    }\n    /** @inheritDoc */\n    setMasterKey(key) {\n        this.masterKey = aether_crypto_utils_1.CryptoUtils.aKeyToDtoKey(key);\n    }\n    /** @inheritDoc */\n    getMasterKey() {\n        if (this.masterKey === null)\n            return null;\n        return aether_crypto_utils_1.CryptoUtils.dtoKeyToAKey(this.masterKey);\n    }\n    /** @inheritDoc */\n    getServerInfo(sid) {\n        if (!this.servers.has(sid)) {\n            this.servers.set(sid, new ClientState.ServerInfoImpl(sid));\n        }\n        return this.servers.get(sid);\n    }\n    /** @inheritDoc */\n    getServerInfoAll() {\n        return this.servers.values();\n    }\n    /** @inheritDoc */\n    getServerDescriptor(serverId) {\n        if (serverId <= 0) {\n            aether_logging_1.Log.warn(\"getServerDescriptor invalid id\", {\n                serverId\n            });\n            return null;\n        }\n        return this.servers.get(serverId)?.getDescriptor() ?? null;\n    }\n    /** @inheritDoc */\n    getClientInfo(uid) {\n        const key = uid.toString().toString();\n        if (!this.clients.has(key)) {\n            this.clients.set(key, new ClientState.ClientInfoMutable(uid));\n        }\n        return this.clients.get(key);\n    }\n    /** @inheritDoc */\n    getClientInfoAll() {\n        return this.clients.values();\n    }\n    /** @inheritDoc */\n    setCloud(uid, cloud) {\n        this.getClientInfo(uid).setCloud(cloud);\n    }\n    /** @inheritDoc */\n    getCloud(uid) {\n        if (!uid) {\n            aether_logging_1.Log.warn(\"getCloud called with null/undefined UID\");\n            return null;\n        }\n        return this.getClientInfo(uid).getCloud();\n    }\n    /** @inheritDoc */\n    getRegistrationUri() {\n        return [...this.registrationUris];\n    }\n    /** @inheritDoc */\n    getPingDuration() {\n        return this.pingDuration;\n    }\n    /** @inheritDoc */\n    getParentUid() {\n        return this.parentUid;\n    }\n    /** @inheritDoc */\n    setParentUid(uid) {\n        this.parentUid = uid;\n    }\n    /** @inheritDoc */\n    getCryptoLib() {\n        return this.cryptoLib;\n    }\n    /** @inheritDoc */\n    getRootSigners() {\n        return new Set(this.rootSigners.values());\n    }\n    /** @inheritDoc */\n    getTimeoutForConnectToRegistrationServer() {\n        return this.timeoutForConnectToRegistrationServer;\n    }\n    /** @inheritDoc */\n    getCountServersForRegistration() {\n        return this.countServersForRegistration;\n    }\n    /** @inheritDoc */\n    save() {\n        if (!this.uid || !this.alias || !this.masterKey || !this.parentUid) {\n            throw new Error(`Client state incomplete`);\n        }\n        const dtoRootSigners = [];\n        for (const rs of this.rootSigners.values()) {\n            try {\n                const aKey = rs.getPublicKey();\n                const dtoKey = aether_crypto_utils_1.CryptoUtils.aKeyToDtoKey(aKey);\n                if (dtoKey) {\n                    dtoRootSigners.push(dtoKey);\n                }\n                else {\n                    aether_logging_1.Log.warn(\"Failed to convert root signer AKey to DTO Key structure\", {\n                        keyString: aKey.keyToString(),\n                    });\n                }\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Failed to convert root signer public key during save\", e);\n            }\n        }\n        const dto = new aether_api_1.ClientStateForSave(this.registrationUris.slice(), Array.from(this.servers.values())\n            .map((s) => s.getDescriptor())\n            .filter((d) => d !== null), Array.from(this.clients.values())\n            .filter((c) => c.getCloud() !== null)\n            .map((c) => new aether_api_1.ClientInfo(c.getUid(), c.getCloud())), dtoRootSigners, this.cryptoLib, BigInt(this.pingDuration.getNow() ?? 1000), this.parentUid, this.countServersForRegistration, BigInt(this.timeoutForConnectToRegistrationServer), this.uid, this.alias, this.masterKey);\n        const d = new aether_datainout_1.DataInOut();\n        aether_api_1.ClientStateForSave.META.serialize(null, dto, d);\n        return d.toArray();\n    }\n    /** @inheritDoc */\n    load(data) {\n        try {\n            const dto = aether_api_1.ClientStateForSave.META.deserialize(null, new aether_datainout_1.DataInOutStatic(data));\n            this.uid = dto.uid;\n            this.alias = dto.alias;\n            this.parentUid = dto.parentUid;\n            this.masterKey = dto.masterKey;\n            this.cryptoLib = dto.cryptoLib;\n            this.countServersForRegistration = dto.countServersForRegistration;\n            this.timeoutForConnectToRegistrationServer =\n                Number(dto.timeoutForConnectToRegistrationServer);\n            this.pingDuration.set(Number(dto.pingDuration));\n            this.registrationUris = dto.registrationUri.slice();\n            this.servers.clear();\n            dto.servers.forEach((sd) => this.getServerInfo(sd.id).setDescriptor(sd));\n            this.clients.clear();\n            dto.clients.forEach((ci) => this.getClientInfo(ci.uid).setCloud(ci.cloud));\n            this.rootSigners.clear();\n            dto.rootSigners.forEach((k) => {\n                let keyStringForError = \"unknown DTO Key\";\n                try {\n                    if (typeof k.toString === \"function\" &&\n                        k.toString.length === 1) {\n                        const sb = aether_astring_1.AString.of();\n                        k.toString(sb);\n                        keyStringForError = sb.toString();\n                    }\n                    else if (typeof k.toString === \"function\") {\n                        let sb = aether_astring_1.AString.of();\n                        k.toString(sb);\n                        keyStringForError = sb.toString();\n                    }\n                    else {\n                        keyStringForError = `DTOKey(TypeID:${k.getAetherTypeId()})`;\n                    }\n                    const akey = aether_crypto_utils_1.CryptoUtils.dtoKeyToAKey(k);\n                    if (akey && akey.getKeyType() === aether_crypto_1.KeyType.SIGN_PUBLIC) {\n                        const checker = akey.asSignPublicKey().toSignChecker();\n                        if (checker) {\n                            this.addSigner(checker);\n                        }\n                        else {\n                            aether_logging_1.Log.warn(\"Could not create SignChecker from loaded AKey\", {\n                                key: akey.keyToString(),\n                            });\n                        }\n                    }\n                    else {\n                        aether_logging_1.Log.warn(\"Loaded root signer is not SIGN_PUBLIC\", {\n                            key: akey?.keyToString() ?? keyStringForError,\n                        });\n                    }\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Failed to load/convert root signer DTO Key\", e, {\n                        key: keyStringForError,\n                    });\n                }\n            });\n            this.addDefaultRootSigners();\n            if (!this.parentUid) {\n                this.parentUid = aether_utils_1.StandardUUIDs.ANONYMOUS_UID;\n            }\n        }\n        catch (e) {\n            aether_logging_1.Log.error(\"Failed to load client state\", e);\n            throw new Error(`Unparsable state: ${e.message}`);\n        }\n    }\n}\nexports.ClientStateInMemory = ClientStateInMemory;\n/**\n * @namespace ClientState\n * @description Contains nested interfaces and classes related to ClientState.\n */\nvar ClientState;\n(function (ClientState) {\n    /**\n     * @class ServerInfoImpl\n     * @implements {ClientState.ServerInfo}\n     * @description Mutable implementation of ServerInfo.\n     */\n    class ServerInfoImpl {\n        /**\n         * @description The server's ID.\n         */\n        sid;\n        /**\n         * @description The server's descriptor.\n         */\n        descriptor = null;\n        /**\n         * @constructor\n         * @param {number | ServerDescriptor} sidOrDescriptor Either the server ID or the full descriptor.\n         */\n        constructor(sidOrDescriptor) {\n            if (typeof sidOrDescriptor === 'number') {\n                this.sid = sidOrDescriptor;\n            }\n            else {\n                this.sid = sidOrDescriptor.id;\n                this.descriptor = sidOrDescriptor;\n            }\n        }\n        /** @inheritDoc */\n        getServerId() { return this.sid; }\n        /** @inheritDoc */\n        getDescriptor() { return this.descriptor; }\n        /** @inheritDoc */\n        setDescriptor(serverDescriptor) { this.descriptor = serverDescriptor; }\n    }\n    ClientState.ServerInfoImpl = ServerInfoImpl;\n    /**\n     * @class ClientInfoMutable\n     * @implements {ClientState.ClientInfo}\n     * @description Mutable implementation of ClientInfo.\n     */\n    class ClientInfoMutable {\n        /**\n         * @description The peer's UID.\n         */\n        uid;\n        /**\n         * @description The peer's Cloud object.\n         */\n        cloud = null;\n        /**\n         * @constructor\n         * @param {UUID | ClientInfo} uidOrDto Either the peer's UID or a DTO object.\n         * @param {Cloud} [cloud] Optional cloud object if constructing with a UID.\n         */\n        constructor(uidOrDto, cloud) {\n            if (aether_types_1.UUID && uidOrDto instanceof aether_types_1.UUID) {\n                this.uid = uidOrDto;\n                this.cloud = cloud ?? null;\n            }\n            else {\n                this.uid = uidOrDto.getUid();\n                this.cloud = uidOrDto.getCloud();\n            }\n        }\n        /** @inheritDoc */\n        getUid() { return this.uid; }\n        /** @inheritDoc */\n        getCloud() { return this.cloud; }\n        /** @inheritDoc */\n        setCloud(cloud) { this.cloud = cloud; }\n    }\n    ClientState.ClientInfoMutable = ClientInfoMutable;\n    function setServerDescriptor(key, arg1) {\n        throw new Error('Function not implemented.');\n    }\n    ClientState.setServerDescriptor = setServerDescriptor;\n})(ClientState || (exports.ClientState = ClientState = {}));\n//# sourceMappingURL=aether_client_state.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_client_state.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_crypto.js":
/*!***********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_crypto.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether.crypto.ts\n// PURPOSE: Contains all Cryptographic INTERFACES and the FACTORY.\n//          Conversion utilities (like KeyUtil) are REMOVED. Conversions should happen\n//          at the point of use via instanceof checks and factory methods.\n// DEPENDENCIES: aether.types.ts, aether.logging.ts, aether.utils.ts\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AKey = exports.SignChecker = exports.CryptoProviderFactory = exports.CryptoEngine = exports.KeyType = exports.DecryptException = exports.EncryptException = void 0;\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n// --- Exceptions ---\nclass EncryptException extends Error {\n    constructor(message, cause) { super(message); this.name = 'EncryptException'; if (cause)\n        this.stack = `${this.stack}\\nCaused by: ${cause.stack}`; }\n}\nexports.EncryptException = EncryptException;\nclass DecryptException extends Error {\n    constructor(message, cause) { super(message); this.name = 'DecryptException'; if (cause)\n        this.stack = `${this.stack}\\nCaused by: ${cause.stack}`; }\n}\nexports.DecryptException = DecryptException;\n// --- Enum and Core Interfaces ---\nvar KeyType;\n(function (KeyType) {\n    KeyType[KeyType[\"SYMMETRIC\"] = 0] = \"SYMMETRIC\";\n    KeyType[KeyType[\"ASYMMETRIC_PUBLIC\"] = 1] = \"ASYMMETRIC_PUBLIC\";\n    KeyType[KeyType[\"ASYMMETRIC_PRIVATE\"] = 2] = \"ASYMMETRIC_PRIVATE\";\n    KeyType[KeyType[\"SIGN_PUBLIC\"] = 3] = \"SIGN_PUBLIC\";\n    KeyType[KeyType[\"SIGN_PRIVATE\"] = 4] = \"SIGN_PRIVATE\";\n})(KeyType || (exports.KeyType = KeyType = {}));\nvar CryptoEngine;\n(function (CryptoEngine) {\n    function of(encoder, decoder) {\n        return new class {\n            getCryptoProvider() {\n                return encoder.getCryptoProvider();\n            }\n            getProviderName() {\n                return this.getCryptoProvider().getCryptoLibName();\n            }\n            decrypt(data) {\n                return decoder.decrypt(data);\n            }\n            encrypt(data) {\n                return encoder.encrypt(data);\n            }\n        };\n    }\n    CryptoEngine.of = of;\n})(CryptoEngine || (exports.CryptoEngine = CryptoEngine = {}));\n// --- Registry and Factory Implementation ---\nconst providers = new Map();\n/**\n * Type guard function to check if an object implements the getProviderName method.\n * @param obj The object to check.\n * @returns True if the object has getProviderName, false otherwise.\n */\nfunction hasGetProviderName(obj) {\n    return !!obj && typeof obj.getProviderName === 'function';\n}\n/**\n * Factory class for managing and retrieving CryptoProvider implementations.\n */\nexports.CryptoProviderFactory = {\n    /**\n     * Registers a CryptoProvider instance.\n     * @param provider The provider instance to register.\n     */\n    register: (provider) => { const nameLower = provider.getCryptoLibName().toLowerCase(); if (providers.has(nameLower)) {\n        aether_logging_1.Log.warn(`CryptoProvider already registered: ${nameLower}. Overwriting.`);\n    } providers.set(nameLower, provider); aether_logging_1.Log.debug(`Registered CryptoProvider: ${provider.getCryptoLibName()}`); },\n    /**\n    * Retrieves a registered CryptoProvider by name.\n    * @param libName The name of the cryptographic library.\n    * @returns The registered CryptoProvider.\n    * @throws {Error} If the provider is not registered.\n    */\n    getProvider: (libName) => {\n        const nameLower = libName.toLowerCase();\n        const res = providers.get(nameLower);\n        if (res == null) {\n            throw new Error(`Provider not registered: ${libName}`);\n        }\n        return res;\n    },\n    /**\n     * Retrieves a registered CryptoProvider using a key object.\n     * @param key The CryptoKey instance.\n     * @returns The associated CryptoProvider.\n     * @throws {Error} If the key object is invalid or the provider is not registered.\n     */\n    getProviderByKey: (key) => {\n        if (!hasGetProviderName(key)) {\n            let keyIdentifier = 'unknown key object';\n            if (key && typeof key === 'object') { /* ... provide details ... */\n                keyIdentifier = `object with keys: ${Object.keys(key).join(', ')}`;\n            }\n            throw new Error(`Invalid key object passed to getProviderByKey: missing getProviderName method. Key: ${keyIdentifier}`);\n        }\n        return exports.CryptoProviderFactory.getProvider(key.getProviderName());\n    },\n    /**\n     * Retrieves a registered CryptoProvider using a Sign object.\n     * @param sign The Sign instance.\n     * @returns The associated CryptoProvider.\n     */\n    getProviderBySign: (sign) => exports.CryptoProviderFactory.getProvider(sign.getProviderName()),\n    /**\n     * Returns a set of all registered CryptoProviders.\n     * @returns A Set of CryptoProvider instances.\n     */\n    all: () => new Set(providers.values()),\n    /**\n     * Returns an array of all registered CryptoProviders.\n     * @returns An array of CryptoProvider instances.\n     */\n    allFlow: () => Array.from(providers.values()),\n    /**\n     * Creates an AKey instance from provider details or a key string.\n     * @param providerNameOrString Provider name, or key string.\n     * @param keyType Optional key type.\n     * @param data Optional raw key data.\n     * @returns The created AKey instance.\n     */\n    createKey(providerNameOrString, keyType, data) {\n        if (keyType !== undefined && data !== undefined) {\n            const provider = exports.CryptoProviderFactory.getProvider(providerNameOrString);\n            return provider.createKey(keyType, data);\n        }\n        else if (keyType === undefined && data === undefined) {\n            const s = providerNameOrString;\n            if (s == null || s.length === 0) {\n                return aether_utils_1.RU.cast(null);\n            }\n            const parts = s.split(\":\");\n            if (parts.length !==\n                3) {\n                throw new Error(`Invalid key string format: ${s}`);\n            }\n            const providerName = parts[0];\n            const provider = exports.CryptoProviderFactory.getProvider(providerName);\n            return provider.createKey(s);\n        }\n        throw new Error(\"Invalid arguments for CryptoProviderFactory.createKey\");\n    },\n    /**\n     * Creates a SignChecker instance from a key string.\n     * @param s The key string (e.g., \"PROVIDER:KEY_HEX\").\n     * @returns The created SignChecker.\n     */\n    createSignChecker: (s) => { if (s == null || s.length === 0) {\n        return aether_utils_1.RU.cast(null);\n    } const i = s.indexOf(\":\"); if (i === -1 || s.indexOf(\":\", i + 1) !== -1) {\n        throw new Error(\"Invalid SignChecker string format.\");\n    } const providerName = s.substring(0, i); const keyHex = s.substring(i + 1); const cp = exports.CryptoProviderFactory.getProvider(providerName); const publicKey = cp.createSignPublicKey(aether_utils_1.HexUtils.hexToBytes(keyHex)); return cp.createSigner(publicKey); },\n    /**\n     * Creates a Signer from provider name and key hex strings.\n     * @param providerName The name of the provider.\n     * @param publicKeyHex The hex string of the public key.\n     * @param privateKeyHex The hex string of the private key.\n     * @returns The created Signer.\n     */\n    createSigner: (providerName, publicKeyHex, privateKeyHex) => {\n        const p = exports.CryptoProviderFactory.getProvider(providerName);\n        return p.createSigner(p.createSignKeys(publicKeyHex, privateKeyHex));\n    },\n    /**\n     * Creates a Set of Signer instances, one for each registered provider.\n     * @returns A Set of Signer instances.\n     */\n    makeSigners: () => {\n        const res = new Set();\n        for (const p of exports.CryptoProviderFactory.all()) {\n            try {\n                res.add(p.createSigner());\n            }\n            catch (e) {\n                // Skip providers that can't create a default signer\n                aether_logging_1.Log.warn(`Skipping crypto provider ${p.getCryptoLibName()} for signer creation: ${e.message}`);\n            }\n        }\n        return res;\n    }\n};\n// --- Add static 'of' methods that rely on the factory ---\nvar SignChecker;\n(function (SignChecker) {\n    function of(s) { return exports.CryptoProviderFactory.createSignChecker(s); }\n    SignChecker.of = of;\n})(SignChecker || (exports.SignChecker = SignChecker = {}));\nvar AKey;\n(function (AKey) {\n    function of(v) { return aether_utils_1.RU.cast(exports.CryptoProviderFactory.createKey(v)); }\n    AKey.of = of;\n})(AKey || (exports.AKey = AKey = {}));\n// =============================================================================================\n// UTILS: REMOVED - Conversions handled inline where needed\n// =============================================================================================\n// KeyUtil REMOVED\n// KeySymmetricUtil REMOVED\n// SignedKeyUtil REMOVED\n// SignUtil REMOVED\n// PairSignKeysUtils REMOVED\n//# sourceMappingURL=aether_crypto.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_crypto.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_crypto_utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_crypto_utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_crypto_utils.ts\n// PURPOSE: Contains conversion utilities between DTO (aether_api) types and\n//          internal (aether_crypto) types. Ported from CryptoUtils.java.\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CryptoUtils = void 0;\nconst aether_crypto_1 = __webpack_require__(/*! ./aether_crypto */ \"./node_modules/aether-client/build/aether_crypto.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./node_modules/aether-client/build/aether_api.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n/**\n * Provides static utility methods for converting between DTO (aether_api)\n * transport types and internal (aether_crypto) types.\n * (Port of CryptoUtils.java)\n */\nvar CryptoUtils;\n(function (CryptoUtils) {\n    /**\n     * Converts a DTO Key (transport layer) to an AKey (cryptographic layer interface).\n     * (Port of Java: `public static <T extends AKey> T of(Key key)`)\n     *\n     * @param key The DTO Key instance from the generated aether_api.\n     * @returns The corresponding AKey implementation.\n     * @throws {Error} If the DTO Key type is unsupported or missing data.\n     */\n    function dtoKeyToAKey(key) {\n        let providerName = undefined;\n        let keyType = undefined;\n        const data = key.data;\n        if (!data || !(data instanceof Uint8Array)) {\n            const className = key.constructor.name;\n            if (className === \"Key\") {\n                throw new Error(`DTO Key is abstract. Cannot convert abstract 'Key' to AKey.`);\n            }\n            throw new Error(`DTO Key (${className}) is missing valid 'data' property.`);\n        }\n        if (key instanceof aether_api_1.SodiumChacha20Poly1305) {\n            providerName = \"SODIUM\";\n            keyType = aether_crypto_1.KeyType.SYMMETRIC;\n        }\n        else if (key instanceof aether_api_1.HydrogenSecretBox) {\n            providerName = \"HYDROGEN\";\n            keyType = aether_crypto_1.KeyType.SYMMETRIC;\n        }\n        else if (key instanceof aether_api_1.SodiumCurvePublic) {\n            providerName = \"SODIUM\";\n            keyType = aether_crypto_1.KeyType.ASYMMETRIC_PUBLIC;\n        }\n        else if (key instanceof aether_api_1.HydrogenCurvePublic) {\n            providerName = \"HYDROGEN\";\n            keyType = aether_crypto_1.KeyType.ASYMMETRIC_PUBLIC;\n        }\n        else if (key instanceof aether_api_1.SodiumCurvePrivate) {\n            providerName = \"SODIUM\";\n            keyType = aether_crypto_1.KeyType.ASYMMETRIC_PRIVATE;\n        }\n        else if (key instanceof aether_api_1.HydrogenCurvePrivate) {\n            providerName = \"HYDROGEN\";\n            keyType = aether_crypto_1.KeyType.ASYMMETRIC_PRIVATE;\n        }\n        else if (key instanceof aether_api_1.SodiumSignPublic) {\n            providerName = \"SODIUM\";\n            keyType = aether_crypto_1.KeyType.SIGN_PUBLIC;\n        }\n        else if (key instanceof aether_api_1.HydrogenSignPublic) {\n            providerName = \"HYDROGEN\";\n            keyType = aether_crypto_1.KeyType.SIGN_PUBLIC;\n        }\n        else if (key instanceof aether_api_1.SodiumSignPrivate) {\n            providerName = \"SODIUM\";\n            keyType = aether_crypto_1.KeyType.SIGN_PRIVATE;\n        }\n        else if (key instanceof aether_api_1.HydrogenSignPrivate) {\n            providerName = \"HYDROGEN\";\n            keyType = aether_crypto_1.KeyType.SIGN_PRIVATE;\n        }\n        if (providerName && keyType !== undefined) {\n            const provider = aether_crypto_1.CryptoProviderFactory.getProvider(providerName);\n            return aether_utils_1.RU.cast(provider.createKey(keyType, data));\n        }\n        else {\n            const className = key.constructor.name;\n            aether_logging_1.Log.error(`dtoKeyToAKey: Could not determine provider/type`, undefined, {\n                className,\n            });\n            throw new Error(`Unsupported DTO Key type: ${className}`);\n        }\n    }\n    CryptoUtils.dtoKeyToAKey = dtoKeyToAKey;\n    /**\n     * Converts an AKey (cryptographic layer interface) back to its corresponding DTO Key (transport layer).\n     * (Port of Java: `public static <T extends Key> T of(AKey key)`)\n     *\n     * @param key The AKey instance.\n     * @returns The corresponding DTO Key instance.\n     * @throws {Error} If the AKey type/provider combination is unsupported.\n     */\n    function aKeyToDtoKey(key) {\n        const providerName = key.getProviderName().toLowerCase();\n        const keyType = key.getKeyType();\n        const data = key.getData();\n        switch (providerName) {\n            case \"sodium\":\n                switch (keyType) {\n                    case aether_crypto_1.KeyType.SYMMETRIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.SodiumChacha20Poly1305(data));\n                    case aether_crypto_1.KeyType.ASYMMETRIC_PRIVATE:\n                        return aether_utils_1.RU.cast(new aether_api_1.SodiumCurvePrivate(data));\n                    case aether_crypto_1.KeyType.ASYMMETRIC_PUBLIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.SodiumCurvePublic(data));\n                    case aether_crypto_1.KeyType.SIGN_PRIVATE:\n                        return aether_utils_1.RU.cast(new aether_api_1.SodiumSignPrivate(data));\n                    case aether_crypto_1.KeyType.SIGN_PUBLIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.SodiumSignPublic(data));\n                    default:\n                        throw new Error(`Unsupported AKey KeyType for provider ${providerName}: ${aether_crypto_1.KeyType[keyType]}`);\n                }\n            case \"hydrogen\":\n                switch (keyType) {\n                    case aether_crypto_1.KeyType.SYMMETRIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.HydrogenSecretBox(data));\n                    case aether_crypto_1.KeyType.ASYMMETRIC_PRIVATE:\n                        return aether_utils_1.RU.cast(new aether_api_1.HydrogenCurvePrivate(data));\n                    case aether_crypto_1.KeyType.ASYMMETRIC_PUBLIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.HydrogenCurvePublic(data));\n                    case aether_crypto_1.KeyType.SIGN_PRIVATE:\n                        return aether_utils_1.RU.cast(new aether_api_1.HydrogenSignPrivate(data));\n                    case aether_crypto_1.KeyType.SIGN_PUBLIC:\n                        return aether_utils_1.RU.cast(new aether_api_1.HydrogenSignPublic(data));\n                    default:\n                        throw new Error(`Unsupported AKey KeyType for provider ${providerName}: ${aether_crypto_1.KeyType[keyType]}`);\n                }\n            // Note: `break` is unreachable.\n            default:\n                throw new Error(`Unsupported AKey for DTO conversion: Provider ${providerName}, Type ${aether_crypto_1.KeyType[keyType]}`);\n        }\n    }\n    CryptoUtils.aKeyToDtoKey = aKeyToDtoKey;\n    /**\n     * Converts a DTO Sign (transport layer) to an internal Sign (cryptographic layer).\n     * (Port of Java: `public static io.aether.crypto.Sign of(Sign sign)`)\n     */\n    function dtoSignToInternal(sign) {\n        if (sign instanceof aether_api_1.SignAE_ED25519) {\n            return aether_crypto_1.CryptoProviderFactory.getProvider(\"SODIUM\").createSign(sign.getData());\n        }\n        else if (sign instanceof aether_api_1.SignHYDROGEN) {\n            return aether_crypto_1.CryptoProviderFactory.getProvider(\"HYDROGEN\").createSign(sign.getData());\n        }\n        else {\n            throw new Error(\"UnsupportedOperationException: Unknown DTO Sign type\");\n        }\n    }\n    CryptoUtils.dtoSignToInternal = dtoSignToInternal;\n    /**\n     * Converts an internal Sign (cryptographic layer) to a DTO Sign (transport layer).\n     * (Port of Java: `public static Sign of(io.aether.crypto.Sign sign)`)\n     */\n    function internalSignToDto(sign) {\n        switch (sign.getProviderName().toLowerCase()) {\n            case \"sodium\":\n                return new aether_api_1.SignAE_ED25519(sign.getSignData());\n            case \"hydrogen\":\n                return new aether_api_1.SignHYDROGEN(sign.getSignData());\n            default:\n                throw new Error(\"UnsupportedOperationException: Unknown internal Sign provider\");\n        }\n    }\n    CryptoUtils.internalSignToDto = internalSignToDto;\n    /**\n     * Converts a DTO SignedKey (transport layer) to an internal SignedKey (cryptographic layer).\n     * (Port of Java: `public static io.aether.crypto.SignedKey of(SignedKey key)`)\n     */\n    function dtoSignedKeyToInternal(key) {\n        const internalAKey = dtoKeyToAKey(key.getKey());\n        const internalSign = dtoSignToInternal(key.getSign());\n        // Re-create the InternalSignedKey using the provider to ensure correct implementation\n        const provider = aether_crypto_1.CryptoProviderFactory.getProvider(internalAKey.getProviderName());\n        return provider.createSignedKey(internalAKey, internalSign);\n    }\n    CryptoUtils.dtoSignedKeyToInternal = dtoSignedKeyToInternal;\n    /**\n     * Converts an internal SignedKey (cryptographic layer) to a DTO SignedKey (transport layer).\n     * (Port of Java: `public static SignedKey of(io.aether.crypto.SignedKey key)`)\n     */\n    function internalSignedKeyToDto(key) {\n        return new aether_api_1.SignedKey(aKeyToDtoKey(key.key), internalSignToDto(key.sign));\n    }\n    CryptoUtils.internalSignedKeyToDto = internalSignedKeyToDto;\n    /**\n     * Verifies the signature of a DTO SignedKey using a list of trusted SignCheckers.\n     * (Port of Java: `public static boolean verifySign(SignedKey key, Iterable<SignChecker> checkers)`)\n     */\n    function verifySign(key, checkers) {\n        const k = dtoKeyToAKey(key.getKey());\n        const s = dtoSignToInternal(key.getSign());\n        for (const c of checkers) {\n            if (c.getCryptoProvider() == k.getCryptoProvider() && c.checkSign(k.getData(), s)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    CryptoUtils.verifySign = verifySign;\n    /**\n     * Creates a CryptoEngine (for encryption or decryption) from a DTO Key.\n     * (Port of Java: `public static CryptoEngine makeProvider(Key key)`)\n     */\n    function makeProvider(key) {\n        const k = dtoKeyToAKey(key);\n        switch (k.getKeyType()) {\n            case aether_crypto_1.KeyType.ASYMMETRIC_PUBLIC:\n                return k.toCryptoEngine();\n            case aether_crypto_1.KeyType.SYMMETRIC:\n                return k.toCryptoEngine();\n            default:\n                throw new Error(\"UnsupportedOperationException: Key type cannot be used to make an engine\");\n        }\n    }\n    CryptoUtils.makeProvider = makeProvider;\n})(CryptoUtils || (exports.CryptoUtils = CryptoUtils = {}));\n//# sourceMappingURL=aether_crypto_utils.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_crypto_utils.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_datainout.js":
/*!**************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_datainout.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_datainout.ts\n// PURPOSE: Contains Data I/O interfaces and implementation (DataInOut, DataInOutStatic).\n// DEPENDENCIES: aether_types.ts, aether_utils.ts (for HexUtils)\n// (  - Refactored: Merged Impl classes with interfaces, fixed exports)\n// ( 2:   64-bit Long -> readLong() : bigint, writeLong(v: number | bigint))\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataInOut = exports.DataInOutStatic = void 0;\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\n// --- Implementation Helpers ---\nconst DataIO_Utils = {\n    /** Reads N bytes in Little Endian format, calling readUByte0 for each byte. */\n    readLE(readUByte0, numBytes, isLong) {\n        let res = 0;\n        if (isLong) { // Use floating-point arithmetic for potential > 32-bit results (e.g., readUInt)\n            for (let i = 0; i < numBytes; i++) {\n                res += readUByte0() * Math.pow(2, 8 * i);\n            }\n        }\n        else { // Use bitwise operations for up to 32-bit results\n            for (let i = 0; i < numBytes; i++) {\n                res |= (readUByte0() << (8 * i));\n            }\n        }\n        return res;\n    },\n};\n// --- DataIOBase Abstract Class ---\nclass DataIOBase {\n    read(b, offset, len) {\n        if (offset === undefined && len === undefined) { // Check for 1-argument overload\n            const buf = b instanceof Uint8Array ? b : new Uint8Array(b);\n            return this._readCore(buf, 0, buf.length);\n        }\n        if (offset !== undefined && len !== undefined) { // Check for 3-argument overload\n            if (b instanceof Uint8Array) {\n                return this._readCore(b, offset, len);\n            }\n            else if (b instanceof Array) { // number[]\n                // Reading into number[] (assuming reading ints) - Less efficient\n                let elementsRead = 0;\n                const targetLen = Math.min(len, b.length - offset);\n                for (let i = offset; i < offset + targetLen; i++) {\n                    if (this.getSizeForRead() < 4)\n                        return elementsRead; // Check if enough bytes remain for an int\n                    b[i] = this.readInt(); // Use the class's readInt method\n                    elementsRead++;\n                }\n                return elementsRead;\n            }\n        }\n        throw new Error(\"Invalid arguments for read()\");\n    }\n    isEmpty() { return this.getSizeForRead() === 0; }\n    isReadable() { return this.getSizeForRead() !== 0; }\n    skipAllBytes() { this.skipBytes(this.getSizeForRead()); }\n    readBoolean() { return this.readUByte() !== 0; }\n    readByte() {\n        const ubyte = this.readUByte();\n        return ubyte > 127 ? ubyte - 256 : ubyte; // Convert unsigned to signed byte\n    }\n    readUShort() { return DataIO_Utils.readLE(this.readUByte.bind(this), 2, false) & 0xFFFF; }\n    readShort() {\n        let value = 0;\n        value |= this.readUByte();\n        value |= (this.readUByte() << 8);\n        return (value >= 0x8000) ? value - 0x10000 : value;\n    }\n    readInt() { return DataIO_Utils.readLE(this.readUByte.bind(this), 4, false) | 0; } // Ensure 32-bit signed int\n    readUInt() { return DataIO_Utils.readLE(this.readUByte.bind(this), 4, true); } // Use floating point for unsigned\n    readLong() {\n        let res = 0n;\n        let shift = 0n;\n        const readUByte = this.readUByte.bind(this); // Bind once\n        for (let i = 0; i < 8; i++) {\n            const byte = BigInt(readUByte());\n            res |= (byte << shift);\n            shift += 8n;\n        }\n        // Handle signed 64-bit integer (twos complement)\n        if (res >= 0x8000000000000000n) { // If sign bit (63) is set\n            res -= 0x10000000000000000n; // Subtract 2^64\n        }\n        return res;\n    }\n    readChar() { return String.fromCharCode(this.readUByte()); }\n    readFloat() {\n        const buffer = this.readBytes(4).buffer;\n        return (new DataView(buffer, 0, 4)).getFloat32(0, true);\n    }\n    readDouble() {\n        const buffer = this.readBytes(8).buffer;\n        return (new DataView(buffer, 0, 8)).getFloat64(0, true);\n    }\n    readString1() {\n        const len = this.readUByte();\n        const data = this.readBytes(len);\n        if (typeof TextDecoder !== 'undefined') {\n            return new TextDecoder(\"latin1\").decode(data);\n        }\n        else {\n            let str = '';\n            for (let i = 0; i < data.length; i++) {\n                str += String.fromCharCode(data[i]);\n            }\n            return str;\n        }\n    }\n    readSubData(length) {\n        const res = new DataInOutStatic(length);\n        const bytesRead = this._readCore(res.data, 0, length);\n        if (bytesRead !== length) {\n            throw new Error(`Underflow: Tried to readSubData of length ${length}, but only got ${bytesRead} bytes.`);\n        }\n        res.setWritePos(length);\n        return res;\n    }\n    readBytes(len) {\n        const res = new Uint8Array(len);\n        const bytesRead = this._readCore(res, 0, len);\n        if (bytesRead !== len) {\n            throw new Error(`Underflow: Tried to readBytes of length ${len}, but only got ${bytesRead} bytes.`);\n        }\n        return res;\n    }\n    write(b, off, len) {\n        if (off !== undefined && len !== undefined) {\n            const targetLen = len;\n            if (b instanceof Uint8Array) {\n                return this._writeCore(b, off, targetLen);\n            }\n            else if (b instanceof Array) {\n                const buf = new Uint8Array(b.slice(off, off + targetLen));\n                return this._writeCore(buf, 0, buf.length);\n            }\n            else {\n                throw new Error(\"Invalid arguments for write(b, off, len)\");\n            }\n        }\n        if (b instanceof Uint8Array) {\n            const r = this._writeCore(b, 0, b.length);\n            if (r !== b.length) {\n                throw new Error(\"Assertion failed: Failed to write all bytes from Uint8Array\");\n            }\n            return;\n        }\n        else if (b instanceof Array) {\n            const buf = new Uint8Array(b);\n            const r = this._writeCore(buf, 0, buf.length);\n            if (r !== buf.length) {\n                throw new Error(\"Assertion failed: Failed to write all bytes from number[]\");\n            }\n            return;\n        }\n        else if (b && typeof b.getSizeForRead === 'function' && b.data instanceof Uint8Array) {\n            const dataIn = b;\n            const size = dataIn.getSizeForRead();\n            if (size > 0) {\n                const bytesWritten = this._writeCore(dataIn.data, dataIn.readPos, size);\n                if (bytesWritten !== size) {\n                    throw new Error(\"Assertion failed: Failed to write all data from DataIn source\");\n                }\n                //    'b'\n            }\n            return;\n        }\n        else if (b && typeof b.toArray === 'function') {\n            this.write(b.toArray());\n            return;\n        }\n        else {\n            throw new Error(\"Invalid arguments for write()\");\n        }\n    }\n    writeBoolean(v) { this.writeByte(v ? 1 : 0); }\n    writeShort(v) {\n        this.writeByte((v) & 0xFF);\n        this.writeByte((v >>> 8) & 0xFF);\n    }\n    writeChar(v) { this.writeByte(v.charCodeAt(0) & 0xFF); }\n    writeInt(v) {\n        this.writeByte((v) & 0xFF);\n        this.writeByte((v >>> 8) & 0xFF);\n        this.writeByte((v >>> 16) & 0xFF);\n        this.writeByte((v >>> 24) & 0xFF);\n    }\n    writeLong(v) {\n        if (typeof v === 'bigint') {\n            const low = v & 0xffffffffn;\n            const high = v >> 32n;\n            this.writeInt(Number(low)); // Write low 32 bits\n            this.writeInt(Number(high)); // Write high 32 bits\n        }\n        else {\n            this.writeInt(v & 0xFFFFFFFF);\n            this.writeInt(Math.floor(v / 0x100000000));\n        }\n    }\n    writeFloat(v) {\n        const buffer = new ArrayBuffer(4);\n        (new DataView(buffer)).setFloat32(0, v, true);\n        this._writeCore(new Uint8Array(buffer), 0, 4);\n    }\n    writeDouble(v) {\n        const buffer = new ArrayBuffer(8);\n        (new DataView(buffer)).setFloat64(0, v, true);\n        this._writeCore(new Uint8Array(buffer), 0, 8);\n    }\n    writeHexBytes(hex) { this.write(aether_utils_1.HexUtils.hexToBytes(hex)); }\n}\nclass DataInOutStatic extends DataIOBase {\n    data;\n    writePos = 0;\n    readPos = 0;\n    constructor(ar, readPos = 0, writePos) {\n        super();\n        if (typeof ar === 'number') {\n            this.data = new Uint8Array(ar);\n        }\n        else {\n            this.data = ar;\n        }\n        this.readPos = readPos;\n        this.writePos = writePos !== undefined ? writePos : (typeof ar === 'number' ? 0 : ar.length);\n        if (this.readPos < 0 || this.readPos > this.data.length || this.writePos < 0 || this.writePos > this.data.length || this.readPos > this.writePos) {\n            throw new Error(`Invalid initial positions: readPos=${readPos}, writePos=${writePos}, capacity=${this.data.length}`);\n        }\n    }\n    // --- Core Abstract Implementations ---\n    _readCore(b, offset, len) {\n        const available = this.getSizeForRead();\n        const l = Math.min(len, available);\n        if (l > 0) {\n            b.set(this.data.subarray(this.readPos, this.readPos + l), offset);\n            this.readPos += l;\n        }\n        return l;\n    }\n    _writeCore(b, off, len) {\n        const availableSpace = this.data.length - this.writePos;\n        const l = Math.min(len, availableSpace);\n        if (l < len)\n            throw new Error(`BufferOverflow: Not enough space to write ${len} bytes (available: ${availableSpace}) in DataInOutStatic`);\n        this.data.set(b.subarray(off, off + l), this.writePos);\n        this.writePos += l;\n        return l;\n    }\n    readUByte() {\n        if (this.readPos >= this.writePos) {\n            throw new Error(`Underflow: Cannot read byte, readPos=${this.readPos}, writePos=${this.writePos}`);\n        }\n        return this.data[this.readPos++];\n    }\n    writeByte(v) {\n        if (this.writePos >= this.data.length) {\n            throw new Error(\"BufferOverflow: Cannot write byte, buffer full (DataInOutStatic)\");\n        }\n        this.data[this.writePos++] = v & 0xFF;\n    }\n    toArray() {\n        const readableBytes = this.data.slice(this.readPos, this.writePos);\n        this.readPos = this.writePos;\n        return readableBytes;\n    }\n    indexOf(limit, val) {\n        const searchEnd = Math.min(this.writePos, this.readPos + limit);\n        for (let i = this.readPos; i < searchEnd; i++) {\n            if (this.data[i] === val)\n                return i - this.readPos;\n        }\n        return -1;\n    }\n    skipBytes(n) {\n        const newReadPos = this.readPos + n;\n        if (newReadPos > this.writePos) {\n            throw new Error(`Underflow: Cannot skip ${n} bytes, only ${this.getSizeForRead()} available.`);\n        }\n        this.readPos = newReadPos;\n    }\n    clear() { this.writePos = 0; this.readPos = 0; }\n    getSizeForRead() { return this.writePos - this.readPos; }\n    isWritable() { return this.writePos < this.data.length; }\n    getSizeForWrite() { return this.data.length - this.writePos; }\n    // --- DataInOutStatic specific methods ---\n    total() { return this.data.length; }\n    getWritePos() { return this.writePos; }\n    setWritePos(writePos) {\n        if (writePos < 0 || writePos > this.data.length)\n            throw new Error(`IndexOutOfBounds: writePos ${writePos} is out of bounds [0, ${this.data.length}]`);\n        if (writePos < this.readPos)\n            throw new Error(`IllegalArgument: writePos ${writePos} cannot be less than readPos ${this.readPos}`);\n        this.writePos = writePos;\n    }\n    getReadPos() { return this.readPos; }\n    setReadPos(readPos) {\n        if (readPos < 0 || readPos > this.writePos)\n            throw new Error(`IndexOutOfBounds: readPos ${readPos} is out of bounds [0, ${this.writePos}]`);\n        this.readPos = readPos;\n    }\n}\nexports.DataInOutStatic = DataInOutStatic;\nclass DataInOut extends DataIOBase {\n    data;\n    writePos = 0;\n    readPos = 0;\n    constructor(dataOrCapacity = 100, len) {\n        super();\n        if (dataOrCapacity instanceof Uint8Array) {\n            this.data = dataOrCapacity;\n            this.writePos = len !== undefined ? len : dataOrCapacity.length;\n        }\n        else {\n            this.data = new Uint8Array(dataOrCapacity);\n            this.writePos = 0;\n        }\n        this.readPos = 0;\n    }\n    readUByte0() {\n        if (this.readPos >= this.writePos) {\n            throw new Error(\"Underflow: Cannot read byte, buffer empty or read past end.\");\n        }\n        return this.data[this.readPos++];\n    }\n    trim() {\n        if (this.readPos > 0 && this.readPos === this.writePos) {\n            this.writePos = 0;\n            this.readPos = 0;\n        }\n    }\n    // Overridden primitive reads using trim()\n    readUByte() {\n        const res = this.readUByte0();\n        this.trim();\n        return res;\n    }\n    readUShort() {\n        if (this.readPos + 2 > this.writePos)\n            throw new Error(`Underflow: Cannot read UShort, need 2 bytes, have ${this.getSizeForRead()}`);\n        const res = DataIO_Utils.readLE(this.readUByte0.bind(this), 2, false) & 0xFFFF;\n        this.trim();\n        return res;\n    }\n    readShort() {\n        if (this.readPos + 2 > this.writePos)\n            throw new Error(`Underflow: Cannot read Short, need 2 bytes, have ${this.getSizeForRead()}`);\n        const ushortVal = DataIO_Utils.readLE(this.readUByte0.bind(this), 2, false);\n        this.trim();\n        return (ushortVal >= 0x8000) ? ushortVal - 0x10000 : ushortVal;\n    }\n    readInt() {\n        if (this.readPos + 4 > this.writePos)\n            throw new Error(`Underflow: Cannot read Int, need 4 bytes, have ${this.getSizeForRead()}`);\n        const res = DataIO_Utils.readLE(this.readUByte0.bind(this), 4, false) | 0;\n        this.trim();\n        return res;\n    }\n    readUInt() {\n        if (this.readPos + 4 > this.writePos)\n            throw new Error(`Underflow: Cannot read UInt, need 4 bytes, have ${this.getSizeForRead()}`);\n        const res = DataIO_Utils.readLE(this.readUByte0.bind(this), 4, true);\n        this.trim();\n        return res;\n    }\n    readLong() {\n        if (this.readPos + 8 > this.writePos)\n            throw new Error(`Underflow: Cannot read Long, need 8 bytes, have ${this.getSizeForRead()}`);\n        let res = 0n;\n        let shift = 0n;\n        const readUByte0 = this.readUByte0.bind(this); // Use the internal, non-trimming read\n        for (let i = 0; i < 8; i++) {\n            const byte = BigInt(readUByte0());\n            res |= (byte << shift);\n            shift += 8n;\n        }\n        this.trim(); // Trim once at the end\n        // Handle signed 64-bit integer (twos complement)\n        if (res >= 0x8000000000000000n) {\n            res -= 0x10000000000000000n;\n        }\n        return res;\n    }\n    // --- Core Abstract Implementations ---\n    _readCore(b, offset, len) {\n        const available = this.getSizeForRead();\n        const l = Math.min(len, available);\n        if (l > 0) {\n            b.set(this.data.subarray(this.readPos, this.readPos + l), offset);\n            this.readPos += l;\n        }\n        this.trim();\n        return l;\n    }\n    _writeCore(b, off, len) {\n        this.checkSize(len);\n        this.data.set(b.subarray(off, off + len), this.writePos);\n        this.writePos += len;\n        return len;\n    }\n    writeByte(v) {\n        this.checkSize(1);\n        this.data[this.writePos++] = (v) & 0xFF;\n    }\n    toArray() {\n        const readableBytes = this.data.slice(this.readPos, this.writePos);\n        this.clear();\n        return readableBytes;\n    }\n    indexOf(limit, val) {\n        const searchEnd = Math.min(this.writePos, this.readPos + limit);\n        for (let i = this.readPos; i < searchEnd; i++) {\n            if (this.data[i] === val)\n                return i - this.readPos;\n        }\n        return -1;\n    }\n    skipBytes(n) {\n        const newReadPos = this.readPos + n;\n        if (newReadPos > this.writePos) {\n            throw new Error(`Underflow: Cannot skip ${n} bytes, only ${this.getSizeForRead()} available.`);\n        }\n        this.readPos = newReadPos;\n        this.trim();\n    }\n    clear() { this.writePos = 0; this.readPos = 0; }\n    getSizeForRead() { return this.writePos - this.readPos; }\n    isWritable() { return true; }\n    getSizeForWrite() { return Infinity; }\n    // --- DataInOut specific methods ---\n    toArrayCopy() { return this.data.slice(this.readPos, this.writePos); }\n    getData() { return this.data; }\n    setData(data, readPos = 0, writePos) {\n        this.data = data;\n        this.readPos = readPos;\n        this.writePos = writePos !== undefined ? writePos : data.length;\n        if (this.readPos < 0 || this.readPos > this.data.length || this.writePos < 0 || this.writePos > this.data.length || this.readPos > this.writePos) {\n            throw new Error(`Invalid positions set via setData: readPos=${readPos}, writePos=${writePos}, capacity=${this.data.length}`);\n        }\n    }\n    getWritePos() { return this.writePos; }\n    setWritePos(writePos) {\n        if (writePos < 0)\n            throw new Error(\"writePos cannot be negative\");\n        if (writePos < this.readPos)\n            throw new Error(`IllegalArgument: writePos ${writePos} cannot be less than readPos ${this.readPos}`);\n        if (writePos > this.data.length) {\n            this.checkSize(writePos - this.writePos);\n        }\n        this.writePos = writePos;\n    }\n    getReadPos() { return this.readPos; }\n    setReadPos(readPos) {\n        if (readPos < 0 || readPos > this.writePos)\n            throw new Error(`IndexOutOfBounds: readPos ${readPos} is out of bounds [0, ${this.writePos}]`);\n        this.readPos = readPos;\n        this.trim();\n    }\n    checkSize(sizeNeeded) {\n        const requiredCapacity = this.writePos + sizeNeeded;\n        if (this.data.length < requiredCapacity) {\n            const doubleSize = this.data.length * 2;\n            const resizeWithFactor = Math.ceil(requiredCapacity * 1.3);\n            const newSize = Math.max(doubleSize, resizeWithFactor, requiredCapacity);\n            const newData = new Uint8Array(newSize);\n            if (this.writePos > 0) {\n                newData.set(this.data.subarray(0, this.writePos));\n            }\n            this.data = newData;\n        }\n    }\n}\nexports.DataInOut = DataInOut;\n//# sourceMappingURL=aether_datainout.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_datainout.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_fastmeta.js":
/*!*************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_fastmeta.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        env.stack.push({ value: value, dispose: dispose, async: async });\n    }\n    else if (async) {\n        env.stack.push({ async: true });\n    }\n    return value;\n};\nvar __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {\n    return function (env) {\n        function fail(e) {\n            env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        function next() {\n            while (env.stack.length) {\n                var rec = env.stack.pop();\n                try {\n                    var result = rec.dispose && rec.dispose.call(rec.value);\n                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n                }\n                catch (e) {\n                    fail(e);\n                }\n            }\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    };\n})(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RemoteApiFuture = exports.FastApiContextLocal = exports.FastApiContext = exports.FastMeta = exports.FastFutureContextStub = exports.DeserializerPackNumber = exports.SerializerPackNumber = void 0;\n// @ts-nocheck\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_datainout_1 = __webpack_require__(/*! ./aether_datainout */ \"./node_modules/aether-client/build/aether_datainout.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER_UTF8 = new TextDecoder('utf-8');\nclass SerializerPackNumber {\n    static INSTANCE = new SerializerPackNumber();\n    static u8 = 251n;\n    static pow8_mask = 0xffn;\n    static pow8_shift = 8n;\n    static k8ReservedFor16 = 16n;\n    static k16ReservedFor32 = 256n;\n    static pow32 = 4294967296n;\n    static u16 = 5n * 256n + SerializerPackNumber.u8 - SerializerPackNumber.k8ReservedFor16;\n    static u32 = 1024n * 1024n + SerializerPackNumber.u16 - SerializerPackNumber.k16ReservedFor32;\n    static u64 = SerializerPackNumber.u32 + SerializerPackNumber.pow32 * SerializerPackNumber.k16ReservedFor32;\n    static pow16_mask = 0xffffn;\n    static pow16_shift = 16n;\n    static pow32_shift = 32n;\n    static pow32_mask = 0xffffffffn;\n    put(out, val) {\n        const v = BigInt(val);\n        if (v < SerializerPackNumber.u8) {\n            out.writeByte(Number(v));\n        }\n        else if (v < SerializerPackNumber.u16) {\n            out.writeByte(Number((((v - SerializerPackNumber.u8) >> SerializerPackNumber.pow8_shift) & 0xffn) + SerializerPackNumber.u8));\n            out.writeByte(Number((v - SerializerPackNumber.u8) & SerializerPackNumber.pow8_mask));\n        }\n        else if (v < SerializerPackNumber.u32) {\n            out.writeByte(255);\n            out.writeByte(Number(((v - SerializerPackNumber.u16) >> SerializerPackNumber.pow16_shift) - SerializerPackNumber.u8 + SerializerPackNumber.u16));\n            out.writeShort(Number((v - SerializerPackNumber.u16) & SerializerPackNumber.pow16_mask));\n        }\n        else if (v < SerializerPackNumber.u64) {\n            out.writeByte(255);\n            out.writeByte(255);\n            out.writeShort(Number(((v - SerializerPackNumber.u32) >> SerializerPackNumber.pow32_shift) - SerializerPackNumber.u16 + SerializerPackNumber.u32));\n            out.writeInt(Number((v - SerializerPackNumber.u32) & SerializerPackNumber.pow32_mask));\n        }\n        else {\n            throw new Error(\"Value too large for SerializerPackNumber: \" + v);\n        }\n    }\n}\nexports.SerializerPackNumber = SerializerPackNumber;\nclass DeserializerPackNumber {\n    static INSTANCE = new DeserializerPackNumber();\n    static u8 = 251n;\n    static pow8_shift = 8n;\n    static k8ReservedFor16 = 16n;\n    static k16ReservedFor32 = 256n;\n    static pow32 = 4294967296n;\n    static u16 = 5n * 256n + DeserializerPackNumber.u8 - DeserializerPackNumber.k8ReservedFor16;\n    static u32 = 1024n * 1024n + DeserializerPackNumber.u16 - DeserializerPackNumber.k16ReservedFor32;\n    static u64 = DeserializerPackNumber.u32 + DeserializerPackNumber.pow32 * DeserializerPackNumber.k16ReservedFor32;\n    static pow16_shift = 16n;\n    static pow32_shift = 32n;\n    put(in_) {\n        let val = BigInt(in_.readUByte());\n        if (val < DeserializerPackNumber.u8) {\n            return val;\n        }\n        let v = BigInt(in_.readUByte());\n        val = ((val - DeserializerPackNumber.u8) << DeserializerPackNumber.pow8_shift) + DeserializerPackNumber.u8 + v;\n        if (val < DeserializerPackNumber.u16) {\n            return val;\n        }\n        let f = BigInt(in_.readUShort());\n        val = ((val - DeserializerPackNumber.u16) << DeserializerPackNumber.pow16_shift) + DeserializerPackNumber.u16 + f;\n        if (val < DeserializerPackNumber.u32) {\n            return val;\n        }\n        let f1 = BigInt(in_.readUInt());\n        val = ((val - DeserializerPackNumber.u32) << DeserializerPackNumber.pow32_shift) + DeserializerPackNumber.u32 + f1;\n        if (val < DeserializerPackNumber.u64) {\n            return val;\n        }\n        throw new Error(\"Value too large for DeserializerPackNumber (marker > u64)\");\n    }\n}\nexports.DeserializerPackNumber = DeserializerPackNumber;\n/**\n * A stub implementation of FastFutureContext for synchronous operations.\n */\nexports.FastFutureContextStub = {\n    sendToRemote: (data) => { throw new Error(\"Context is a stub and cannot send data.\"); },\n    sendResultToRemote: (requestId, data) => { throw new Error(\"Context is a stub and cannot send result.\"); },\n    sendResultToRemoteNoData: (requestId) => { throw new Error(\"Context is a stub and cannot send result.\"); },\n    regFuture: (worker) => 0,\n    regLocalFuture: () => { },\n    getFuture: (requestId) => { throw new Error(\"UnsupportedOperationException\"); },\n    flush: (sendFuture) => { throw new Error(\"UnsupportedOperationException\"); },\n    remoteDataToArray: (out) => { },\n    remoteDataToArrayAsArray: () => new Uint8Array(0),\n    isEmpty: () => true,\n    size: () => 0,\n    close: () => aether_future_1.AFuture.completed(),\n    destroy: (_force) => aether_future_1.AFuture.of(),\n    [Symbol.dispose]: () => { },\n    invokeLocalMethodBefore: (_methodName, _argsNames, _argsValues) => { },\n    invokeLocalMethodAfter: (_methodName, _result, _argsNames, _argsValues) => { },\n    invokeRemoteMethodAfter: (_methodName, _result, _argsNames, _argsValues) => { },\n};\n/**\n * Helper class for an Array of T, utilizing the element's FastMetaType.\n * This is an internal implementation detail for FastMeta.getMetaArray.\n */\nclass UniversalMetaArrayImpl {\n    elementMeta;\n    constructor(elementMeta) {\n        this.elementMeta = elementMeta;\n    }\n    serialize(ctx, obj, out) {\n        SerializerPackNumber.INSTANCE.put(out, obj.length);\n        for (const el of obj) {\n            this.elementMeta.serialize(ctx, el, out);\n        }\n    }\n    deserialize(ctx, dataIn) {\n        const len = Number(DeserializerPackNumber.INSTANCE.put(dataIn));\n        if (this.elementMeta === FastMeta.META_BYTE) {\n            return dataIn.readBytes(len);\n        }\n        const ar = new Array(len);\n        for (let i = 0; i < len; i++) {\n            ar[i] = this.elementMeta.deserialize(ctx, dataIn);\n        }\n        return ar;\n    }\n    serializeToBytes(obj) {\n        const d = new aether_datainout_1.DataInOut();\n        this.serialize(exports.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_datainout_1.DataInOutStatic(data);\n        return this.deserialize(exports.FastFutureContextStub, d);\n    }\n    loadFromFile(_file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        if (this.elementMeta === FastMeta.META_BYTE) {\n            const arr = obj;\n            let hash = 1;\n            for (let i = 0; i < arr.length; i++) {\n                hash = (31 * hash + arr[i]) | 0;\n            }\n            return hash;\n        }\n        let hash = 1;\n        for (const el of obj) {\n            hash = (31 * hash + this.elementMeta.metaHashCode(el)) | 0;\n        }\n        return hash;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !Array.isArray(v2))\n            return false;\n        if (this.elementMeta === FastMeta.META_BYTE) {\n            const arr1 = v1;\n            const arr2 = v2;\n            if (!(v2 instanceof Uint8Array))\n                return false;\n            if (arr1.length !== arr2.length)\n                return false;\n            for (let i = 0; i < arr1.length; i++) {\n                if (arr1[i] !== arr2[i])\n                    return false;\n            }\n            return true;\n        }\n        if (v1.length !== v2.length)\n            return false;\n        for (let i = 0; i < v1.length; i++) {\n            if (!this.elementMeta.metaEquals(v1[i], v2[i]))\n                return false;\n        }\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        if (this.elementMeta === FastMeta.META_BYTE) {\n            res.add('byte[').add(obj.length).add(']');\n            return;\n        }\n        res.add('[');\n        let first = true;\n        for (const el of obj) {\n            if (!first)\n                res.add(', ');\n            this.elementMeta.metaToString(el, res);\n            first = false;\n        }\n        res.add(']');\n    }\n}\n/**\n * Central class containing FastMetaType for all primitive and standard types.\n */\nclass FastMeta {\n    static META_BOOLEAN = new class {\n        serialize(_ctx, obj, out) { out.writeBoolean(obj); }\n        deserialize(_ctx, dataIn) { return dataIn.readBoolean(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return obj ? 1231 : 1237;\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_BYTE = new class {\n        serialize(_ctx, obj, out) { out.writeByte(obj); }\n        deserialize(_ctx, in_) { return in_.readByte(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_f) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_SHORT = new class {\n        serialize(_ctx, obj, out) { out.writeShort(obj); }\n        deserialize(_ctx, in_) { return in_.readShort(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_f) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_INT = new class {\n        serialize(_ctx, obj, out) { out.writeInt(obj); }\n        deserialize(_ctx, in_) { return in_.readInt(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_f) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_LONG = new class {\n        serialize(_ctx, obj, out) { out.writeLong(obj); }\n        deserialize(_ctx, in_) { return in_.readLong(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            const hash = obj ^ (obj >> 32n);\n            return Number(hash & 0xffffffffn) | 0;\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_FLOAT = new class {\n        serialize(_ctx, obj, out) { out.writeFloat(obj); }\n        deserialize(_ctx, in_) { return in_.readFloat(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            const buf = new ArrayBuffer(4);\n            new Float32Array(buf)[0] = obj;\n            return new Int32Array(buf)[0];\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_DOUBLE = new class {\n        serialize(_ctx, obj, out) { out.writeDouble(obj); }\n        deserialize(_ctx, in_) { return in_.readDouble(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            const buf = new ArrayBuffer(8);\n            new Float64Array(buf)[0] = obj;\n            const longView = new BigInt64Array(buf)[0];\n            const hash = longView ^ (longView >> 32n);\n            return Number(hash & 0xffffffffn) | 0;\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_DATE = new class {\n        serialize(_ctx, obj, out) { out.writeLong(obj.getTime()); }\n        deserialize(_ctx, in_) { return new Date(Number(in_.readLong())); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            const time = BigInt(obj.getTime());\n            const hash = time ^ (time >> 32n);\n            return Number(hash & 0xffffffffn) | 0;\n        }\n        metaEquals(v1, v2) {\n            if (v1 === v2)\n                return true;\n            if (v1 === null || v1 === undefined || v2 === null || v2 === undefined)\n                return false;\n            if (!(v2 instanceof Date))\n                return false;\n            return v1.getTime() === v2.getTime();\n        }\n        metaToString(obj, res) { res.add(obj ? obj.toISOString() : \"null\"); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_PACK = new class {\n        serialize(_ctx, obj, out) { SerializerPackNumber.INSTANCE.put(out, obj); }\n        deserialize(_ctx, dataIn) { return Number(DeserializerPackNumber.INSTANCE.put(dataIn)); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_STRING = new class {\n        serialize(_ctx, obj, out) {\n            const ar = TEXT_ENCODER.encode(obj);\n            SerializerPackNumber.INSTANCE.put(out, ar.length);\n            out.write(ar);\n        }\n        deserialize(_ctx, dataIn) {\n            const len = Number(DeserializerPackNumber.INSTANCE.put(dataIn));\n            const ar = dataIn.readBytes(len);\n            return TEXT_DECODER_UTF8.decode(ar);\n        }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            let hash = 0;\n            for (let i = 0; i < obj.length; i++) {\n                hash = (31 * hash + obj.charCodeAt(i)) | 0;\n            }\n            return hash;\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_UUID = new class {\n        serialize(_ctx, obj, out) {\n            if (!obj || !obj.data || obj.data.length !== 16) {\n                if (obj && typeof obj.getMostSignificantBits === 'function') {\n                    const view = new DataView(new ArrayBuffer(16));\n                    view.setBigInt64(0, obj.getMostSignificantBits(), false);\n                    view.setBigInt64(8, obj.getLeastSignificantBits(), false);\n                    out.write(new Uint8Array(view.buffer));\n                    return;\n                }\n                throw new Error(\"Invalid UUID object for serialization. 'data' field missing or wrong length.\");\n            }\n            out.write(obj.data);\n        }\n        deserialize(_ctx, dataIn) {\n            const data = dataIn.readBytes(16);\n            if (data.length !== 16)\n                throw new Error(\"Could not read 16 bytes for UUID\");\n            const uuid = new aether_types_1.UUID();\n            uuid.data = data;\n            const view = new DataView(data.buffer, data.byteOffset, 16);\n            uuid.mostSignificantBits = view.getBigInt64(0, false);\n            uuid.leastSignificantBits = view.getBigInt64(8, false);\n            return uuid;\n        }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            let high;\n            let low;\n            if (obj.data && obj.data.length === 16) {\n                const view = new DataView(obj.data.buffer, obj.data.byteOffset);\n                high = view.getBigInt64(0, false);\n                low = view.getBigInt64(8, false);\n            }\n            else if (typeof obj.getMostSignificantBits === 'function') {\n                high = obj.getMostSignificantBits();\n                low = obj.getLeastSignificantBits();\n            }\n            else {\n                return 0;\n            }\n            const xor = high ^ low;\n            const hash = xor ^ (xor >> 32n);\n            return Number(hash & 0xffffffffn) | 0;\n        }\n        metaEquals(v1, v2) {\n            if (v1 === v2)\n                return true;\n            if (v1 === null || v1 === undefined || v2 === null || v2 === undefined)\n                return false;\n            if (v1.data && v2.data) {\n                if (!(v2 instanceof aether_types_1.UUID))\n                    return false;\n                const d1 = v1.data;\n                const d2 = v2.data;\n                if (d1 === d2)\n                    return true;\n                if (d1.length !== 16 || d2.length !== 16)\n                    return false;\n                for (let i = 0; i < 16; i++) {\n                    if (d1[i] !== d2[i])\n                        return false;\n                }\n                return true;\n            }\n            if (typeof v1.getMostSignificantBits === 'function' &&\n                typeof v2.getMostSignificantBits === 'function') {\n                return v1.getMostSignificantBits() === v2.getMostSignificantBits() &&\n                    v1.getLeastSignificantBits() === v2.getLeastSignificantBits();\n            }\n            return false;\n        }\n        metaToString(obj, res) { res.add(obj ? obj.toString() : \"null\"); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_URI = new class {\n        serialize(_ctx, obj, out) {\n            const ar = TEXT_ENCODER.encode(obj);\n            SerializerPackNumber.INSTANCE.put(out, ar.length);\n            out.write(ar);\n        }\n        deserialize(_ctx, dataIn) {\n            const len = Number(DeserializerPackNumber.INSTANCE.put(dataIn));\n            const ar = dataIn.readBytes(len);\n            const uriString = TEXT_DECODER_UTF8.decode(ar);\n            return uriString;\n        }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            let hash = 0;\n            for (let i = 0; i < obj.length; i++) {\n                hash = (31 * hash + obj.charCodeAt(i)) | 0;\n            }\n            return hash;\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_REQUEST_ID = new class {\n        serialize(_ctx, ar, out) { out.writeInt(ar); }\n        deserialize(_ctx, dataIn) { return dataIn.readInt(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static META_COMMAND = new class {\n        serialize(_ctx, ar, out) { out.writeByte(ar); }\n        deserialize(_ctx, dataIn) { return dataIn.readUByte(); }\n        metaHashCode(obj) {\n            if (obj === null || obj === undefined)\n                return 0;\n            return (obj | 0);\n        }\n        metaEquals(v1, v2) {\n            return v1 === v2;\n        }\n        metaToString(obj, res) { res.add(String(obj)); }\n        serializeToBytes(obj) {\n            const d = new aether_datainout_1.DataInOut();\n            this.serialize(exports.FastFutureContextStub, obj, d);\n            return d.toArray();\n        }\n        deserializeFromBytes(data) {\n            const d = new aether_datainout_1.DataInOutStatic(data);\n            return this.deserialize(exports.FastFutureContextStub, d);\n        }\n        loadFromFile(_file) { throw new Error(\"UnsupportedOperationException\"); }\n    };\n    static metaArrayCache = new Map();\n    /**\n     * Returns or creates a FastMetaType for an array T[] based on the element's FastMetaType<T>.\n     * @param elementMeta - The FastMetaType of the array element.\n     * @returns FastMetaType<T[]>\n     */\n    static getMetaArray(elementMeta) {\n        if (this.metaArrayCache.has(elementMeta)) {\n            return this.metaArrayCache.get(elementMeta);\n        }\n        const newMeta = new UniversalMetaArrayImpl(elementMeta);\n        this.metaArrayCache.set(elementMeta, newMeta);\n        return newMeta;\n    }\n    /**\n     * Returns the FastMetaType for a byte array (Uint8Array). Delegates to getMetaArray.\n     */\n    static get META_ARRAY_BYTE() {\n        return this.getMetaArray(this.META_BYTE);\n    }\n}\nexports.FastMeta = FastMeta;\n/**\n * Implementation of FastApiContext.\n */\nclass FastApiContext {\n    futures = new Map();\n    futuresCounter = new aether_types_1.AtomicInteger(0);\n    toRemote = new aether_types_1.ConcurrentLinkedQueue_C();\n    returnTasks = new aether_types_1.AtomicInteger(0);\n    sizeBytes = new aether_types_1.AtomicInteger(0);\n    destroy(_force) { return this.close(); }\n    [Symbol.dispose]() { this.close(); }\n    getFuture(requestId) {\n        const future = this.futures.get(requestId);\n        this.futures.delete(requestId);\n        return future;\n    }\n    regLocalFuture() { this.returnTasks.incrementAndGet(); }\n    sendResultToRemoteNoData(requestId) {\n        this.sendResultToRemote(requestId, new Uint8Array(0));\n    }\n    sendResultToRemote(requestId, data) {\n        const d = new aether_datainout_1.DataInOut();\n        FastMeta.META_COMMAND.serialize(exports.FastFutureContextStub, 0, d);\n        FastMeta.META_REQUEST_ID.serialize(exports.FastFutureContextStub, requestId, d);\n        if (data.length > 0) {\n            d.write(data);\n        }\n        this.sendToRemote(d.toArray());\n        if (this.returnTasks.decrementAndGet() === 0) {\n            this.flush(aether_future_1.AFuture.make());\n        }\n    }\n    sendToRemote(data) {\n        this.toRemote.add(data);\n        this.sizeBytes.addAndGet(data.length);\n    }\n    isEmpty() { return this.toRemote.isEmpty(); }\n    size() { return this.sizeBytes.get(); }\n    remoteDataToArrayAsArray() {\n        const out = new aether_datainout_1.DataInOut();\n        this.remoteDataToArray(out);\n        return out.toArray();\n    }\n    remoteDataToArray(out) {\n        let data;\n        while ((data = this.toRemote.poll()) !== undefined) {\n            out.write(data);\n        }\n        this.sizeBytes.set(0);\n    }\n    regFuture(worker) {\n        const r = this.futuresCounter.incrementAndGet();\n        this.futures.set(r, worker);\n        return r;\n    }\n    flush(sendFuture) {\n        sendFuture.tryDone();\n    }\n    close() {\n        this.futures.clear();\n        this.toRemote.clear();\n        this.sizeBytes.set(0);\n        this.returnTasks.set(0);\n        return aether_future_1.AFuture.of();\n    }\n    makeRemote(meta) {\n        return meta.makeRemote(this);\n    }\n    invokeLocalMethodBefore(methodName, argsNames, argsValues) {\n        const logData = {\n            \"methodName\": methodName\n        };\n        for (let i = 0; i < argsNames.length; i++) {\n            logData[`arg_${argsNames[i]}`] = argsValues[i];\n        }\n        aether_logging_1.Log.trace(`cmd local before: ${methodName}`, logData);\n    }\n    invokeLocalMethodAfter(methodName, result, argsNames, argsValues) {\n        const logData = {\n            \"methodName\": methodName,\n            \"result\": result\n        };\n        for (let i = 0; i < argsNames.length; i++) {\n            logData[`arg_${argsNames[i]}`] = argsValues[i];\n        }\n        aether_logging_1.Log.trace(`cmd local after : ${methodName}`, logData);\n    }\n    invokeRemoteMethodAfter(methodName, result, argsNames, argsValues) {\n        const logData = {\n            \"methodName\": methodName,\n            \"result\": result\n        };\n        for (let i = 0; i < argsNames.length; i++) {\n            logData[`arg_${argsNames[i]}`] = argsValues[i];\n        }\n        aether_logging_1.Log.trace(`cmd remote      : ${methodName}`, logData);\n    }\n}\nexports.FastApiContext = FastApiContext;\n/**\n * Implementation of FastApiContext for a local API instance.\n */\nclass FastApiContextLocal extends FastApiContext {\n    localApi;\n    constructor(localApi) {\n        super();\n        if (typeof localApi === 'function') {\n            this.localApi = localApi(this);\n        }\n        else {\n            this.localApi = localApi;\n        }\n    }\n}\nexports.FastApiContextLocal = FastApiContextLocal;\n/**\n * Manages executing tasks against a RemoteApi instance.\n */\nclass RemoteApiFuture {\n    queue = new aether_types_1.ConcurrentLinkedQueue_C();\n    permanent = new Set();\n    meta;\n    logContext;\n    constructor(meta) {\n        this.meta = meta;\n        this.logContext = aether_logging_1.Log.of({ Component: \"RemoteApiFuture\" });\n    }\n    run(t) {\n        if (t.length === 1) {\n            this.queue.add(aether_logging_1.Log.wrap((a, _f) => t(a)));\n        }\n        else {\n            this.queue.add(aether_logging_1.Log.wrap(t));\n        }\n    }\n    runRes(t) {\n        const res = aether_future_1.ARFuture.of();\n        this.run((a, f) => {\n            let nextFuture;\n            try {\n                if (t.length === 1) {\n                    nextFuture = t(a);\n                }\n                else {\n                    nextFuture = t(a, f);\n                }\n                nextFuture.to(res);\n            }\n            catch (e) {\n                res.error(e);\n            }\n        });\n        return res;\n    }\n    executeAll(ctx, sendFuture) {\n        const env_1 = { stack: [], error: void 0, hasError: false };\n        try {\n            const ll = __addDisposableResource(env_1, aether_logging_1.Log.context(this.logContext), false);\n            try {\n                const api = this.meta.makeRemote(ctx);\n                let e;\n                while ((e = this.queue.poll()) !== undefined) {\n                    try {\n                        e(api, sendFuture);\n                    }\n                    catch (err) {\n                        aether_logging_1.Log.error(\"Error executing queued RemoteApiFuture task.\", err);\n                    }\n                }\n                for (const t of this.permanent) {\n                    try {\n                        t(api, sendFuture);\n                    }\n                    catch (err) {\n                        aether_logging_1.Log.error(\"Error executing permanent RemoteApiFuture task.\", err);\n                    }\n                }\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Error creating remote API or executing RemoteApiFuture tasks.\", e);\n            }\n            finally {\n            }\n        }\n        catch (e_1) {\n            env_1.error = e_1;\n            env_1.hasError = true;\n        }\n        finally {\n            __disposeResources(env_1);\n        }\n    }\n    addPermanent(task) {\n        if (task.length === 1) {\n            this.permanent.add((a, _f) => task(a));\n        }\n        else {\n            this.permanent.add(task);\n        }\n    }\n    isEmpty() {\n        return this.queue.isEmpty() && this.permanent.size === 0;\n    }\n    size() {\n        return this.queue.length + this.permanent.size;\n    }\n}\nexports.RemoteApiFuture = RemoteApiFuture;\n//# sourceMappingURL=aether_fastmeta.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_fastmeta.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_fastmeta_net.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_fastmeta_net.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\n// FILE: aether_fastmeta_net.ts\n// PURPOSE: Contains the FastMetaNet factory interface, related network interfaces,\n//          and the default WebSocket implementation (FastMetaClientWebSocket).\n// =P============================================================================================\nvar __addDisposableResource = (this && this.__addDisposableResource) || function (env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        env.stack.push({ value: value, dispose: dispose, async: async });\n    }\n    else if (async) {\n        env.stack.push({ async: true });\n    }\n    return value;\n};\nvar __disposeResources = (this && this.__disposeResources) || (function (SuppressedError) {\n    return function (env) {\n        function fail(e) {\n            env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        function next() {\n            while (env.stack.length) {\n                var rec = env.stack.pop();\n                try {\n                    var result = rec.dispose && rec.dispose.call(rec.value);\n                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n                }\n                catch (e) {\n                    fail(e);\n                }\n            }\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    };\n})(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionState = exports.FastMetaNet = void 0;\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_fastmeta_1 = __webpack_require__(/*! ./aether_fastmeta */ \"./node_modules/aether-client/build/aether_fastmeta.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_datainout_1 = __webpack_require__(/*! ./aether_datainout */ \"./node_modules/aether-client/build/aether_datainout.js\");\nconst isomorphic_ws_1 = __importDefault(__webpack_require__(/*! isomorphic-ws */ \"./node_modules/isomorphic-ws/browser.js\"));\n/**\n * @namespace FastMetaNet\n * @description Contains nested interfaces and the singleton instance for FastMetaNet.\n */\nvar FastMetaNet;\n(function (FastMetaNet) {\n    /**\n     * @class DefaultFastMetaNetImpl\n     * @implements {FastMetaNet}\n     * @description Default implementation of FastMetaNet that uses WebSocket for clients\n     * and throws errors for server creation.\n     * @internal\n     */\n    class DefaultFastMetaNetImpl {\n        /**\n         * @inheritdoc\n         */\n        makeClient(uri, lt, rt, localApi, writableConsumer) {\n            return new FastMetaClientAdapter(uri, lt, rt, localApi, writableConsumer);\n        }\n        /**\n         * @inheritdoc\n         */\n        makeServer(_uri, _localApiMeta, _remoteApiMeta, _handler) {\n            throw new Error(\"Server implementation (makeServer) is not supported in this FastMetaNet build.\");\n        }\n    }\n    /**\n     * @description Singleton instance container for FastMetaNet.\n     */\n    class Instance {\n        static _instance = null;\n        /**\n         * @description Gets the singleton instance of FastMetaNet.\n         * @returns {FastMetaNet} The instance.\n         */\n        static get() {\n            if (!this._instance) {\n                this._instance = new DefaultFastMetaNetImpl();\n            }\n            return this._instance;\n        }\n    }\n    /**\n     * @description Public singleton accessor for the FastMetaNet factory.\n     */\n    FastMetaNet.INSTANCE = Instance;\n})(FastMetaNet || (exports.FastMetaNet = FastMetaNet = {}));\n/**\n * @enum ConnectionState\n * @description Business-logic level connection state.\n */\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[\"CONNECTING\"] = \"connecting\";\n    ConnectionState[\"CONNECTED\"] = \"connected\";\n    ConnectionState[\"DISCONNECTED\"] = \"disconnected\";\n    ConnectionState[\"RECONNECTING\"] = \"reconnecting\";\n})(ConnectionState || (exports.ConnectionState = ConnectionState = {}));\n/**\n * @class FastMetaClientWebSocket\n * @description WebSocket-based transport implementation with auto-reconnect.\n * This class is the concrete implementation used by the DefaultFastMetaNet.\n * It is *not* intended to be used directly by Connection, but by the FastMetaClientAdapter.\n * @internal\n */\nclass FastMetaClientWebSocket {\n    /**\n     * @private\n     * @type {(WebSocket | null)}\n     */\n    websocket = null;\n    /**\n     * @private\n     * @type {(FastApiContextLocal<LT> | null)}\n     */\n    context = null;\n    /**\n     * @private\n     * @type {ARFuture<FastApiContextLocal<LT>>}\n     */\n    connectFuture;\n    /**\n     * @private\n     * @type {LNode}\n     */\n    log;\n    /**\n     * @private\n     * @type {URI}\n     */\n    uri = \"\";\n    /**\n     * @private\n     * @type {(FastMetaApi<LT, any> | null)}\n     */\n    localApiMeta = null;\n    /**\n     * @private\n     * @type {(AFunction<RT, LT> | null)}\n     */\n    localApiProvider = null;\n    /**\n     * @private\n     * @type {(FastMetaApi<any, RT> | null)}\n     */\n    remoteApiMeta = null;\n    /**\n     * @private\n     * @type {DataInOut}\n     */\n    receiveBuffer = new aether_datainout_1.DataInOut();\n    /**\n     * @private\n     * @type {ReconnectConfig}\n     */\n    reconnectConfig = {\n        maxAttempts: 5,\n        baseDelay: 1000,\n        maxDelay: 30000,\n        backoffMultiplier: 2\n    };\n    /**\n     * @private\n     * @type {number}\n     */\n    reconnectAttempts = 0;\n    /**\n     * @private\n     * @type {(NodeJS.Timeout | null)}\n     */\n    reconnectTimeout = null;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    isManualClose = false;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    isReconnecting = false;\n    /**\n     * @private\n     * @type {ConnectionState}\n     */\n    connectionState = ConnectionState.DISCONNECTED;\n    /**\n     * @private\n     * @type {Array<(state: ConnectionState) => void>}\n     */\n    stateChangeCallbacks = [];\n    /**\n     * @private\n     * @type {*}\n     */\n    connectionStats = {\n        connected: false,\n        lastConnectTime: 0,\n        totalReconnects: 0,\n        connectionUri: \"\"\n    };\n    /**\n     * @constructor\n     * @param {Partial<ReconnectConfig>} [reconnectConfig] Optional reconnect config override.\n     */\n    constructor(reconnectConfig) {\n        this.log = aether_logging_1.Log.of({ component: 'FastMetaClientWebSocket' });\n        this.connectFuture = aether_future_1.ARFuture.of();\n        if (reconnectConfig) {\n            this.reconnectConfig = { ...this.reconnectConfig, ...reconnectConfig };\n        }\n    }\n    /**\n     * @description Initiates the connection.\n     * @param {URI} uri The server URI.\n     * @param {FastMetaApi<LT, any>} localApiMeta The local API META.\n     * @param {FastMetaApi<any, RT>} remoteApiMeta The remote API META.\n     * @param {AFunction<RT, LT>} localApiProvider The local API provider.\n     * @returns {ARFuture<FastApiContextLocal<LT>>} A future that resolves with the context on connection.\n     */\n    connect(uri, localApiMeta, remoteApiMeta, localApiProvider) {\n        const env_1 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_1, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.info(\"Connecting...\", { uri });\n            if (this.websocket || !this.connectFuture.isNotDone()) {\n                aether_logging_1.Log.warn(\"Connect called on an already connecting or connected client.\", { uri });\n                return this.connectFuture;\n            }\n            this.uri = uri;\n            this.connectionStats.connectionUri = uri;\n            this.localApiMeta = localApiMeta;\n            this.remoteApiMeta = remoteApiMeta;\n            this.localApiProvider = localApiProvider;\n            this.isManualClose = false;\n            this.setConnectionState(ConnectionState.CONNECTING);\n            this.createWebSocketConnection();\n            return this.connectFuture;\n        }\n        catch (e_1) {\n            env_1.error = e_1;\n            env_1.hasError = true;\n        }\n        finally {\n            __disposeResources(env_1);\n        }\n    }\n    /**\n     * @private\n     * @description Creates and configures a new WebSocket connection.\n     */\n    createWebSocketConnection() {\n        const env_2 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_2, aether_logging_1.Log.context(this.log), false);\n            try {\n                aether_logging_1.Log.debug(\"Creating 'isomorphic-ws' transport.\");\n                this.websocket = new isomorphic_ws_1.default(this.uri);\n                this.websocket.binaryType = \"arraybuffer\";\n                this.setupEventHandlers();\n                aether_logging_1.Log.debug(\"'isomorphic-ws' WebSocket created successfully.\");\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Failed to create 'isomorphic-ws' WebSocket\", e, { uri: this.uri });\n                this.handleConnectionError(new aether_types_1.ClientStartException(`Failed to create WebSocket: ${e.message}`, e));\n            }\n        }\n        catch (e_2) {\n            env_2.error = e_2;\n            env_2.hasError = true;\n        }\n        finally {\n            __disposeResources(env_2);\n        }\n    }\n    /**\n     * @private\n     * @description Attaches event listeners to the WebSocket.\n     */\n    setupEventHandlers() {\n        if (!this.websocket)\n            return;\n        this.websocket.onopen = () => {\n            this.handleOpen();\n        };\n        this.websocket.onmessage = (event) => {\n            let data;\n            if (typeof Buffer !== 'undefined' && event.data instanceof Buffer) {\n                data = event.data;\n            }\n            else if (event.data instanceof ArrayBuffer) {\n                data = event.data;\n            }\n            else if (typeof event.data === 'string') {\n                data = event.data;\n            }\n            else {\n                data = event.data;\n            }\n            this.handleMessage(data);\n        };\n        this.websocket.onerror = (event) => {\n            const error = event.error || new Error('WebSocket error');\n            this.handleError(error);\n        };\n        this.websocket.onclose = (event) => {\n            this.handleClose(event.code, event.reason);\n        };\n    }\n    // : aether_fastmeta_net.ts\n    //  : FastMetaClientWebSocket\n    /**\n     * @private\n     * @description Called when the WebSocket connection is successfully opened.\n     */\n    handleOpen() {\n        const env_3 = { stack: [], error: void 0, hasError: false };\n        try {\n            this.log = aether_logging_1.Log.of({\n                component: 'FastMetaClientWebSocket',\n                connectionUri: this.uri\n            });\n            const _l = __addDisposableResource(env_3, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.info(\"WebSocket connection established.\");\n            this.reconnectAttempts = 0;\n            this.isReconnecting = false;\n            this.connectionStats.connected = true;\n            this.connectionStats.lastConnectTime = Date.now();\n            this.connectionStats.totalReconnects++;\n            // --- [RACE CONDITION FIX] ---\n            // DO NOT set state to CONNECTED here.\n            // this.setConnectionState(ConnectionState.CONNECTED); // <--- [MOVED]\n            if (!this.remoteApiMeta || !this.localApiProvider || !this.websocket) {\n                const err = new aether_types_1.ClientStartException(\"Internal state error: API metadata or websocket missing during onOpen.\");\n                aether_logging_1.Log.error(err.message, err);\n                this.connectFuture.error(err);\n                this.close();\n                return;\n            }\n            try {\n                const context = new aether_fastmeta_1.FastApiContextLocal((self) => {\n                    const remoteApi = this.remoteApiMeta.makeRemote(self);\n                    const localApi = this.localApiProvider(remoteApi);\n                    return localApi;\n                });\n                this.context = context;\n                this.context.flush = (sendFuture) => {\n                    const env_4 = { stack: [], error: void 0, hasError: false };\n                    try {\n                        const _l_flush = __addDisposableResource(env_4, aether_logging_1.Log.context(this.log), false);\n                        try {\n                            if (this.websocket && this.isConnected()) {\n                                const dataArray = context.remoteDataToArrayAsArray();\n                                if (dataArray.length > 0) {\n                                    aether_logging_1.Log.trace(`Flushing ${dataArray.length} bytes (raw payload).`);\n                                    const frameBuffer = new aether_datainout_1.DataInOut();\n                                    aether_fastmeta_1.SerializerPackNumber.INSTANCE.put(frameBuffer, dataArray.length);\n                                    frameBuffer.write(dataArray);\n                                    const finalBytesToSend = frameBuffer.toArray();\n                                    // --- [ ] ---\n                                    //   ( )  send.\n                                    //  Node.js (ws)  > 1 (data, options, cb).\n                                    //   (native)  == 1 (data).\n                                    const hasCallbackSupport = this.websocket.send.length > 1;\n                                    if (hasCallbackSupport) {\n                                        //  NODE.JS:      (backpressure)\n                                        aether_logging_1.Log.trace(\"Using Node.js 'send' with callback.\");\n                                        this.websocket.send(finalBytesToSend, (sendError) => {\n                                            if (sendError) {\n                                                //    ()\n                                                aether_logging_1.Log.error(\"Error sending data through WebSocket (async)\", sendError);\n                                                this.handleConnectionError(sendError);\n                                                sendFuture.error(sendError);\n                                            }\n                                            else {\n                                                //   \n                                                aether_logging_1.Log.debug(\"Binary frame sent successfully (async)\", { totalBytes: finalBytesToSend.length });\n                                                sendFuture.tryDone();\n                                            }\n                                        });\n                                    }\n                                    else {\n                                        //  : \"Fire-and-forget\".\n                                        //      ,   \n                                        //     .\n                                        //     ,   future .\n                                        aether_logging_1.Log.trace(\"Using Browser 'send' (fire-and-forget).\");\n                                        // `send`   ,  -  ,\n                                        //      `catch (e)`\n                                        this.websocket.send(finalBytesToSend);\n                                        //  `send`   , ,  flush .\n                                        aether_logging_1.Log.debug(\"Binary frame sent (fire-and-forget)\", { totalBytes: finalBytesToSend.length });\n                                        sendFuture.tryDone();\n                                    }\n                                    // --- [ ] ---\n                                }\n                                else {\n                                    aether_logging_1.Log.trace(\"Flush called, but no data to send.\");\n                                    sendFuture.tryDone();\n                                }\n                            }\n                            else {\n                                aether_logging_1.Log.warn(\"Flush called, but WebSocket is not open.\", {\n                                    reconnecting: this.isReconnecting\n                                });\n                                sendFuture.error(new Error(\"WebSocket is not open.\"));\n                            }\n                        }\n                        catch (e) {\n                            //  catch  :\n                            // 1.   (dataArray, frameBuffer)\n                            // 2.    `send()`  \n                            // 3. ()    `send()`  Node.js\n                            aether_logging_1.Log.error(\"Error during WebSocket flush preparation or sync send\", e);\n                            this.handleConnectionError(e);\n                            sendFuture.error(e);\n                        }\n                    }\n                    catch (e_4) {\n                        env_4.error = e_4;\n                        env_4.hasError = true;\n                    }\n                    finally {\n                        __disposeResources(env_4);\n                    }\n                };\n                this.connectFuture.tryDone(this.context);\n                this.setConnectionState(ConnectionState.CONNECTED);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Error during connection setup (onOpen)\", e);\n                this.connectFuture.error(new aether_types_1.ClientStartException(\"Failed to setup context onOpen\", e));\n                this.scheduleReconnect();\n            }\n        }\n        catch (e_3) {\n            env_3.error = e_3;\n            env_3.hasError = true;\n        }\n        finally {\n            __disposeResources(env_3);\n        }\n    }\n    /**\n     * @private\n     * @description Called when a message is received from the WebSocket.\n     * @param {Buffer | ArrayBuffer | string} data The incoming data.\n     */\n    handleMessage(data) {\n        const env_5 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_5, aether_logging_1.Log.context(this.log), false);\n            if (!this.context || !this.localApiMeta) {\n                aether_logging_1.Log.warn(\"Received WebSocket message, but context or localApiMeta is not initialized. Ignoring.\");\n                return;\n            }\n            let binaryData;\n            try {\n                if (typeof Buffer !== 'undefined' && data instanceof Buffer) {\n                    binaryData = new Uint8Array(data);\n                }\n                else if (data instanceof ArrayBuffer) {\n                    binaryData = new Uint8Array(data);\n                }\n                else if (typeof data === 'string') {\n                    aether_logging_1.Log.warn(\"Received text message, but expected binary data. Ignoring.\");\n                    return;\n                }\n                else {\n                    aether_logging_1.Log.warn(`Received unknown data type: ${typeof data}. Ignoring.`);\n                    return;\n                }\n                aether_logging_1.Log.trace(`Received ${binaryData.length} bytes chunk from WebSocket.`);\n                this.receiveBuffer.write(binaryData);\n                while (true) {\n                    if (this.receiveBuffer.isEmpty()) {\n                        break;\n                    }\n                    const originalReadPos = this.receiveBuffer.getReadPos();\n                    let payloadSize = 0;\n                    try {\n                        payloadSize = Number(aether_fastmeta_1.DeserializerPackNumber.INSTANCE.put(this.receiveBuffer));\n                    }\n                    catch (e) {\n                        this.receiveBuffer.setReadPos(originalReadPos);\n                        aether_logging_1.Log.trace(\"Waiting for more data to read frame length.\");\n                        break;\n                    }\n                    if (this.receiveBuffer.getSizeForRead() >= payloadSize) {\n                        const payload = this.receiveBuffer.readBytes(payloadSize);\n                        aether_logging_1.Log.trace(`Successfully parsed frame of ${payloadSize} bytes.`);\n                        try {\n                            this.localApiMeta.makeLocal_fromBytes_ctxLocal(this.context, payload);\n                        }\n                        catch (processingError) {\n                            aether_logging_1.Log.error(\"Error processing frame payload\", processingError);\n                        }\n                    }\n                    else {\n                        this.receiveBuffer.setReadPos(originalReadPos);\n                        aether_logging_1.Log.trace(`Waiting for more data (need ${payloadSize}, have ${this.receiveBuffer.getSizeForRead()}).`);\n                        break;\n                    }\n                }\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Error processing incoming WebSocket message.\", e);\n            }\n        }\n        catch (e_5) {\n            env_5.error = e_5;\n            env_5.hasError = true;\n        }\n        finally {\n            __disposeResources(env_5);\n        }\n    }\n    /**\n     * @private\n     * @description Called on a WebSocket error.\n     * @param {Error} error The WebSocket error.\n     */\n    handleError(error) {\n        const env_6 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_6, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.error(\"WebSocket error\", error);\n            this.handleConnectionError(new aether_types_1.ClientApiException(`WebSocket error: ${error.message}`, error));\n        }\n        catch (e_6) {\n            env_6.error = e_6;\n            env_6.hasError = true;\n        }\n        finally {\n            __disposeResources(env_6);\n        }\n    }\n    handleClose(code, reason) {\n        const env_7 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_7, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.info(\"WebSocket connection closed.\", {\n                code,\n                reason,\n                wasClean: code === 1000\n            });\n            this.connectionStats.connected = false;\n            this.setConnectionState(ConnectionState.DISCONNECTED); // <--- \n            if (!this.connectFuture.isFinalStatus()) {\n                this.connectFuture.error(new aether_types_1.ClientApiException(`WebSocket closed unexpectedly (Code: ${code}, Reason: ${reason})`));\n            }\n            this.context?.close();\n            this.context = null;\n            this.websocket = null; //   \n            // --- [ ] ---\n            //  future,     close()\n            if (this.closeFuture) {\n                this.closeFuture.tryDone();\n                this.closeFuture = null;\n            }\n            // --- [ ] ---\n            if (!this.isManualClose && !this.isReconnecting) {\n                this.scheduleReconnect();\n            }\n        }\n        catch (e_7) {\n            env_7.error = e_7;\n            env_7.hasError = true;\n        }\n        finally {\n            __disposeResources(env_7);\n        }\n    }\n    /**\n     * @private\n     * @description Handles connection errors and initiates reconnection logic.\n     * @param {Error} error The connection error.\n     */\n    handleConnectionError(error) {\n        const env_8 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_8, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.error(\"Connection error\", error);\n            if (!this.connectFuture.isFinalStatus()) {\n                this.connectFuture.error(error);\n            }\n            if (this.closeFuture && !this.closeFuture.isFinalStatus()) {\n                this.closeFuture.tryError(error);\n                this.closeFuture = null;\n            }\n            this.connectionStats.connected = false;\n            // This will trigger the writableConsumer in the adapter\n            this.setConnectionState(ConnectionState.DISCONNECTED);\n            if (!this.isManualClose) {\n                this.scheduleReconnect();\n            }\n        }\n        catch (e_8) {\n            env_8.error = e_8;\n            env_8.hasError = true;\n        }\n        finally {\n            __disposeResources(env_8);\n        }\n    }\n    /**\n     * @private\n     * @description Checks if the WebSocket is connected (readyState OPEN).\n     * @returns {boolean} True if connected.\n     */\n    isConnected() {\n        return this.websocket !== null && this.websocket.readyState === isomorphic_ws_1.default.OPEN;\n    }\n    /**\n     * @private\n     * @description Schedules an auto-reconnect attempt with exponential backoff.\n     */\n    scheduleReconnect() {\n        const env_9 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_9, aether_logging_1.Log.context(this.log), false);\n            if (this.isManualClose || this.reconnectAttempts >= this.reconnectConfig.maxAttempts) {\n                aether_logging_1.Log.info(\"Auto-reconnect stopped\", {\n                    manualClose: this.isManualClose,\n                    maxAttemptsReached: this.reconnectAttempts >= this.reconnectConfig.maxAttempts,\n                    totalAttempts: this.reconnectAttempts\n                });\n                this.setConnectionState(ConnectionState.DISCONNECTED);\n                return;\n            }\n            this.reconnectAttempts++;\n            this.isReconnecting = true;\n            const delay = this.calculateReconnectDelay();\n            aether_logging_1.Log.info(\"Scheduling auto-reconnect\", {\n                attempt: this.reconnectAttempts,\n                maxAttempts: this.reconnectConfig.maxAttempts,\n                delayMs: delay\n            });\n            this.setConnectionState(ConnectionState.RECONNECTING);\n            this.reconnectTimeout = setTimeout(() => {\n                aether_logging_1.Log.info(\"Attempting auto-reconnect...\", { attempt: this.reconnectAttempts });\n                this.connectFuture = aether_future_1.ARFuture.of();\n                this.createWebSocketConnection();\n            }, delay);\n        }\n        catch (e_9) {\n            env_9.error = e_9;\n            env_9.hasError = true;\n        }\n        finally {\n            __disposeResources(env_9);\n        }\n    }\n    /**\n     * @private\n     * @description Calculates the reconnect delay.\n     * @returns {number} The delay in milliseconds.\n     */\n    calculateReconnectDelay() {\n        const delay = this.reconnectConfig.baseDelay *\n            Math.pow(this.reconnectConfig.backoffMultiplier, this.reconnectAttempts - 1);\n        return Math.min(delay, this.reconnectConfig.maxDelay);\n    }\n    /**\n     * @private\n     * @description Sets the connection state and notifies listeners.\n     * @param {ConnectionState} state The new state.\n     */\n    setConnectionState(state) {\n        if (this.connectionState !== state) {\n            this.connectionState = state;\n            aether_logging_1.Log.debug(`Connection state changed: ${state}`);\n            this.stateChangeCallbacks.forEach(callback => {\n                try {\n                    callback(state);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in connection state callback\", e);\n                }\n            });\n        }\n    }\n    /**\n     * @description Subscribes to connection state changes.\n     * @param {(state: ConnectionState) => void} callback The callback function.\n     */\n    onStateChange(callback) {\n        this.stateChangeCallbacks.push(callback);\n    }\n    /**\n     * @description Gets the current connection state.\n     * @returns {ConnectionState} The current state.\n     */\n    getConnectionState() {\n        return this.connectionState;\n    }\n    closeFuture = null;\n    /**\n     * @description Closes the connection manually.\n     * @returns {AFuture} A future that completes when the close operation is initiated.\n     */\n    close() {\n        const env_10 = { stack: [], error: void 0, hasError: false };\n        try {\n            const _l = __addDisposableResource(env_10, aether_logging_1.Log.context(this.log), false);\n            aether_logging_1.Log.info(\"Closing FastMetaClientWebSocket...\");\n            if (this.closeFuture) {\n                return this.closeFuture;\n            }\n            this.closeFuture = aether_future_1.AFuture.make();\n            this.isManualClose = true;\n            this.isReconnecting = false;\n            if (this.reconnectTimeout) {\n                clearTimeout(this.reconnectTimeout);\n                this.reconnectTimeout = null;\n            }\n            if (!this.connectFuture.isFinalStatus()) {\n                this.connectFuture.cancel();\n            }\n            this.context?.close();\n            this.context = null;\n            if (this.websocket) {\n                try {\n                    //   ,   OPEN  CONNECTING\n                    if (this.websocket.readyState === isomorphic_ws_1.default.OPEN || this.websocket.readyState === isomorphic_ws_1.default.CONNECTING) {\n                        aether_logging_1.Log.debug(\"Initiating WebSocket close (code 1000)...\");\n                        this.websocket.close(1000, \"Client initiated close\");\n                    }\n                    else {\n                        aether_logging_1.Log.debug(\"WebSocket already closing or closed.\", { state: this.websocket.readyState });\n                        this.closeFuture.tryDone();\n                    }\n                }\n                catch (e) {\n                    aether_logging_1.Log.warn(\"Error during WebSocket close\", e);\n                    this.closeFuture.tryError(e);\n                }\n            }\n            else {\n                aether_logging_1.Log.debug(\"Close called but no WebSocket instance exists.\");\n                this.closeFuture.tryDone();\n            }\n            this.connectionStats.connected = false;\n            this.reconnectAttempts = 0;\n            return this.closeFuture;\n        }\n        catch (e_10) {\n            env_10.error = e_10;\n            env_10.hasError = true;\n        }\n        finally {\n            __disposeResources(env_10);\n        }\n    }\n    /**\n     * @description Gets connection statistics.\n     * @returns {*} An object with connection stats.\n     */\n    getConnectionStats() {\n        return {\n            ...this.connectionStats,\n            reconnectAttempts: this.reconnectAttempts,\n            isReconnecting: this.isReconnecting,\n            isManualClose: this.isManualClose,\n            connectionState: this.connectionState\n        };\n    }\n    /**\n     * @description Gets the current context.\n     * @returns {FastApiContextLocal<LT> | null} The context or null.\n     */\n    getContext() {\n        return this.context;\n    }\n    /**\n     * @description Gets the local API instance.\n     * @returns {LT} The local API.\n     * @throws {Error} If the context is not initialized.\n     */\n    getLocalApi() {\n        if (!this.context)\n            throw new Error(\"Cannot getLocalApi: context is not initialized.\");\n        return this.context.localApi;\n    }\n    /**\n     * @description Gets the remote API instance.\n     * @returns {RT} The remote API.\n     * @throws {Error} If the context is not initialized.\n     */\n    getRemoteApi() {\n        if (!this.context)\n            throw new Error(\"Cannot getRemoteApi: context is not initialized.\");\n        const remote = this.remoteApiMeta?.makeRemote(this.context);\n        if (!remote)\n            throw new Error(\"Cannot getRemoteApi: failed to create remote from context.\");\n        return remote;\n    }\n    /**\n     * @inheritdoc\n     */\n    destroy(force) {\n        return this.close();\n    }\n    /**\n     * @inheritdoc\n     */\n    [Symbol.dispose]() {\n        this.destroy(true);\n    }\n}\n// =============================================================================================\n// SECTION 3: FastMetaClientAdapter\n// (This is the adapter that implements FastMetaClient and wraps FastMetaClientWebSocket)\n// =============================================================================================\n/**\n * @class FastMetaClientAdapter\n * @implements {FastMetaClient<LT, RT>}\n * @description An adapter that implements the `FastMetaClient` interface (which matches the Java design)\n * by wrapping and managing the `FastMetaClientWebSocket` implementation.\n * @internal\n */\nclass FastMetaClientAdapter {\n    /**\n     * @private\n     * @readonly\n     * @type {FastMetaClientWebSocket<LT, RT>}\n     */\n    wsClient;\n    /**\n     * @private\n     * @readonly\n     * @type {AConsumer<boolean>}\n     */\n    writableConsumer;\n    /**\n     * @private\n     * @type {(FastApiContextLocal<LT> | null)}\n     */\n    context = null;\n    /**\n     * @private\n     * @readonly\n     * @type {LNode}\n     */\n    log;\n    /**\n     * @private\n     * @readonly\n     * @type {ARFuture<FastApiContextLocal<LT>>}\n     */\n    contextFuture;\n    /**\n     * @constructor\n     * @param {URI} uri The server URI.\n     * @param {FastMetaApi<LT, any>} lt The local API META.\n     * @param {FastMetaApi<any, RT>} rt The remote API META.\n     * @param {AFunction<RT, LT>} localApiProvider The local API provider function.\n     * @param {AConsumer<boolean>} writableConsumer The connection status callback.\n     */\n    constructor(uri, lt, rt, localApiProvider, writableConsumer) {\n        this.writableConsumer = writableConsumer;\n        this.log = aether_logging_1.Log.of({ component: \"FastMetaClientAdapter\", uri: uri });\n        this.wsClient = new FastMetaClientWebSocket();\n        this.wsClient.onStateChange((state) => {\n            this.writableConsumer(state === 'connected');\n        });\n        this.contextFuture = this.wsClient.connect(uri, lt, rt, localApiProvider);\n        this.contextFuture.to((ctx) => {\n            this.context = ctx;\n        }).onError(() => {\n            this.context = null;\n        });\n    }\n    /**\n     * @inheritdoc\n     */\n    flush(sendFuture) {\n        if (this.context) {\n            this.context.flush(sendFuture);\n        }\n        else {\n            aether_logging_1.Log.warn(\"Flush called, but client context is not available (not connected or connection lost).\", { uri: this.wsClient.getConnectionStats().connectionUri });\n            sendFuture.error(new Error(\"Cannot flush: client context not available.\"));\n        }\n    }\n    /**\n     * @inheritdoc\n     */\n    close() {\n        this.context = null;\n        return this.wsClient.close();\n    }\n    /**\n     * @inheritdoc\n     */\n    destroy(force) {\n        this.context = null;\n        return this.wsClient.destroy(force);\n    }\n    /**\n     * @inheritdoc\n     */\n    [Symbol.dispose]() {\n        this.destroy(true);\n    }\n    /**\n     * @inheritdoc\n     * @throws {Error} If the context is not initialized.\n     */\n    getLocalApi() {\n        const ctx = this.context;\n        if (!ctx) {\n            throw new Error(\"Cannot getLocalApi: context is not initialized or connection failed.\");\n        }\n        return ctx.localApi;\n    }\n    /**\n     * @inheritdoc\n     * @throws {Error} If the context is not initialized.\n     */\n    getRemoteApi() {\n        const ctx = this.context;\n        if (!ctx) {\n            throw new Error(\"Cannot getRemoteApi: context is not initialized or connection failed.\");\n        }\n        return this.wsClient.getRemoteApi();\n    }\n    /**\n     * @inheritdoc\n     */\n    getMetaContext() {\n        const ctx = this.context;\n        if (!ctx) {\n            throw new Error(\"Cannot getMetaContext: context is not initialized or connection failed.\");\n        }\n        return ctx;\n    }\n    /**\n     * @inheritdoc\n     */\n    isWritable() {\n        return this.wsClient.getConnectionState() === ConnectionState.CONNECTED;\n    }\n    /**\n     * @inheritdoc\n     */\n    read() {\n        // No-op for WebSocket\n    }\n    /**\n     * @inheritdoc\n     */\n    stopRead() {\n        // No-op for WebSocket\n    }\n    /**\n     * @inheritdoc\n     * @throws {Error} If the context is not initialized.\n     */\n    write(data) {\n        const ctx = this.context;\n        if (!ctx) {\n            const err = new Error(\"Cannot write: context is not initialized.\");\n            aether_logging_1.Log.warn(err.message);\n            return aether_future_1.AFuture.ofThrow(err);\n        }\n        const frameBuffer = new aether_datainout_1.DataInOut();\n        aether_fastmeta_1.SerializerPackNumber.INSTANCE.put(frameBuffer, data.length);\n        frameBuffer.write(data);\n        const finalBytesToSend = frameBuffer.toArray();\n        const ws = this.wsClient.websocket; // Access private member\n        if (ws && ws.readyState === isomorphic_ws_1.default.OPEN) {\n            try {\n                ws.send(finalBytesToSend);\n                return aether_future_1.AFuture.completed();\n            }\n            catch (e) {\n                return aether_future_1.AFuture.ofThrow(e);\n            }\n        }\n        else {\n            return aether_future_1.AFuture.ofThrow(new Error(\"WebSocket is not open for writing.\"));\n        }\n    }\n}\n//# sourceMappingURL=aether_fastmeta_net.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_fastmeta_net.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_future.js":
/*!***********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_future.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * @file aether_future.ts\n * @purpose Contains all Future (AFuture, ARFuture, AMFuture) implementations and EventConsumer.\n * @dependencies aether_types.ts, aether_logging.ts, aether_utils.ts\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ARFutureWithFlag = exports.ARFuture = exports.AFuture = exports.AMFuture = exports.createAMFuture = exports.EventBiConsumer = exports.EventConsumer = void 0;\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\n// =============================================================================================\n// SECTION 1: SLOTS (Event) IMPLEMENTATION\n// =============================================================================================\n/**\n * Manages and fires events for a single type.\n * @template T The type of the event value.\n */\nclass EventConsumer {\n    /**\n     * The set of all registered listeners.\n     */\n    listeners = new Set();\n    /**\n     * Adds a listener that will be executed only once.\n     * @param task The listener function.\n     */\n    once(task) {\n        task['_onceFlag'] = true;\n        this.add(task);\n    }\n    /**\n     * Adds a persistent listener.\n     * @param listener The listener function.\n     */\n    add(listener) {\n        this.listeners.add(aether_logging_1.Log.wrap(listener));\n    }\n    /**\n     * Removes a listener.\n     * This handles removing raw listeners, wrapped listeners, and WeakConsumer listeners.\n     * @param listener The original listener function to remove.\n     */\n    remove(listener) {\n        let toDelete = null;\n        for (const existing of this.listeners) {\n            /**\n             * 'existing' could be:\n             * 1. The raw listener (listener)\n             * 2. The wrapped listener (Log.wrap(listener))\n             * 3. The weak wrapper (WeakConsumer_T.create(...))\n             */\n            if (existing === listener) {\n                /** Case 1: Raw listener */\n                toDelete = existing;\n                break;\n            }\n            if (existing.__original === listener) {\n                /** Case 2: Log.wrap(listener) */\n                toDelete = existing;\n                break;\n            }\n            /** Case 3: Check if it's a weak consumer matching the listener */\n            const weakOriginal = existing._weakOriginalTask;\n            if (weakOriginal) {\n                if (weakOriginal === listener || weakOriginal.__original === listener) {\n                    toDelete = existing;\n                    break;\n                }\n            }\n        }\n        if (toDelete) {\n            this.listeners.delete(toDelete);\n        }\n    }\n    /**\n     * Fires the event, notifying all listeners.\n     * This also cleans up 'once' listeners and garbage-collected 'weak' listeners.\n     * @param v The value to pass to the listeners.\n     */\n    fire(v) {\n        const currentListeners = Array.from(this.listeners);\n        const toRemove = [];\n        for (const l of currentListeners) {\n            if (!this.listeners.has(l))\n                continue; /** Was removed during firing */\n            try {\n                const onceFlag = l['_onceFlag'];\n                if (onceFlag) {\n                    toRemove.push(l); /** Mark for removal after firing */\n                    l(v);\n                }\n                else if (aether_types_1.WeakConsumer_T.isGarbageCollected(l)) {\n                    toRemove.push(l); /** Mark GC'd weak listener for removal */\n                }\n                else {\n                    l(v);\n                }\n            }\n            catch (e) {\n                console.error(\"Error firing event listener:\", e);\n            }\n        }\n        /** Clean up 'once' and 'weak' listeners */\n        toRemove.forEach(l => this.listeners.delete(l));\n    }\n    /**\n     * Checks if any listeners are registered.\n     * @returns True if at least one listener exists.\n     */\n    hasListener() { return this.listeners.size > 0; }\n}\nexports.EventConsumer = EventConsumer;\n/**\n * Manages and fires events for two types.\n * @template T1 The type of the first event value.\n * @template T2 The type of the second event value.\n */\nclass EventBiConsumer {\n    listeners = new Set();\n    /**\n     * Adds a persistent listener.\n     * @param listener The listener function.\n     */\n    add(listener) { this.listeners.add(aether_logging_1.Log.wrap(listener)); }\n    /**\n     * Removes a listener.\n     * @param listener The listener function to remove.\n     */\n    remove(listener) {\n        let toDelete = null;\n        for (const existing of this.listeners) {\n            /** Check for the listener or the original wrapped listener */\n            if (existing === listener || existing.__original === listener) {\n                toDelete = existing;\n                break;\n            }\n        }\n        if (toDelete) {\n            this.listeners.delete(toDelete);\n        }\n    }\n    /**\n     * Checks if any listeners are registered.\n     * @returns True if at least one listener exists.\n     */\n    hasListener() { return this.listeners.size > 0; }\n    /**\n     * Fires the event, notifying all listeners.\n     * @param v1 The first value to pass to the listeners.\n     * @param v2 The second value to pass to the listeners.\n     */\n    fire(v1, v2) {\n        this.listeners.forEach(l => {\n            try {\n                l(v1, v2);\n            }\n            catch (e) {\n                console.error(\"Error firing bi-event listener:\", e);\n            }\n        });\n    }\n}\nexports.EventBiConsumer = EventBiConsumer;\n/**\n * Base class for AMFuture implementation details.\n * @internal\n */\nclass AMFutureBase {\n    eventConsumer;\n    value;\n    constructor(value) {\n        this.value = value === undefined ? null : value;\n        this.eventConsumer = new EventConsumer();\n    }\n    refresh() {\n        if (this.value !== null && this.value !== undefined) {\n            this.eventConsumer.fire(this.value);\n        }\n    }\n    accept = (value) => { this.set(value); };\n    set(value) {\n        const oldValue = this.value;\n        if (oldValue === value && value !== null && value !== undefined) {\n            return false;\n        }\n        /**\n         * This complex block mimics the Java VarHandle.compareAndSet\n         * to ensure `fire` happens only on the thread that successfully sets\n         * the value from null. In JS, it's less critical but preserved.\n         */\n        if (oldValue === null || oldValue === undefined) {\n            if (this.value === null || this.value === undefined) {\n                this.value = value;\n                this.eventConsumer.fire(value);\n                return true;\n            }\n            else {\n                /** Lost the \"race\" (e.g., recursive call), try again */\n                return this.set(value);\n            }\n        }\n        else {\n            this.value = value;\n            this.eventConsumer.fire(value);\n            return true;\n        }\n    }\n    map(f) {\n        const res = createAMFuture();\n        this.add((v) => {\n            try {\n                /** Call `res` as a function to set its value */\n                res(f(v));\n            }\n            catch (e) {\n                console.error(\"Error in AMFuture map function:\", e);\n            }\n        });\n        if (this.value !== null && this.value !== undefined) {\n            try {\n                /** Call `res` for the initial value */\n                res(f(this.value));\n            }\n            catch (e) {\n                console.error(\"Error in AMFuture map function (initial value):\", e);\n            }\n        }\n        return res;\n    }\n    once(taskOrT2, msOrSeconds, timeoutTask) {\n        /** Overload: (task, ms, timeoutTask) */\n        if (typeof msOrSeconds === 'number' && typeof timeoutTask === 'function') {\n            const ms = msOrSeconds > 1000000 ? msOrSeconds : msOrSeconds * 1000;\n            const task = taskOrT2;\n            let timerDisposer = null;\n            let executed = false;\n            const wrappedTask = aether_logging_1.Log.wrap(task);\n            wrappedTask['_onceFlag'] = true;\n            const removeListener = () => this.eventConsumer.remove(wrappedTask);\n            timerDisposer = aether_utils_1.RU.schedule(ms, () => {\n                timerDisposer = null;\n                if (!executed) {\n                    executed = true;\n                    try {\n                        timeoutTask();\n                        removeListener();\n                    }\n                    catch (e) {\n                        aether_logging_1.Log.error(e);\n                    }\n                }\n            });\n            this.eventConsumer.add(wrappedTask);\n            if (this.value !== null && this.value !== undefined && !executed) {\n                executed = true;\n                timerDisposer?.[Symbol.dispose]();\n                try {\n                    wrappedTask(this.value);\n                } /** fire() will handle removal */\n                catch (e) {\n                    aether_logging_1.Log.error(e);\n                    removeListener();\n                }\n            }\n        }\n        /** Overload: (task) */\n        else if (typeof taskOrT2 === 'function' && arguments.length === 1) {\n            this.toOnce(taskOrT2);\n        }\n        else {\n            throw new Error(\"Invalid arguments for AMFuture.once\");\n        }\n    }\n    toOnce(task) {\n        const wrappedTask = aether_logging_1.Log.wrap(task);\n        wrappedTask['_onceFlag'] = true;\n        this.eventConsumer.add(wrappedTask);\n        if (this.value !== null && this.value !== undefined) {\n            try {\n                wrappedTask(this.value);\n            } /** fire() will handle removal */\n            catch (e) {\n                aether_logging_1.Log.error(e);\n                this.eventConsumer.remove(wrappedTask);\n            }\n        }\n    }\n    addWeak(task) {\n        const wrappedTask = aether_logging_1.Log.wrap(task);\n        /** Create the weak wrapper */\n        const weakTask = aether_types_1.WeakConsumer_T.create(wrappedTask);\n        this.eventConsumer.add(weakTask);\n        /** Fire immediately if value exists */\n        if (this.value !== null && this.value !== undefined) {\n            try {\n                weakTask(this.value);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(e);\n            }\n        }\n    }\n    add(task) {\n        const wrappedTask = aether_logging_1.Log.wrap(task);\n        this.eventConsumer.add(wrappedTask);\n        if (this.value !== null && this.value !== undefined) {\n            try {\n                wrappedTask(this.value);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(e);\n            }\n        }\n    }\n    remove(task) {\n        this.eventConsumer.remove(task);\n    }\n    getNow() { return this.value ?? null; }\n    mapToARFuture() {\n        if (this.value !== null && this.value !== undefined) {\n            return ARFuture.of(this.value);\n        }\n        const res = new ARFuture();\n        this.once((value) => res.tryDone(value));\n        return res;\n    }\n    isDone() { return this.value !== null && this.value !== undefined; }\n}\n/**\n * Factory function to create a new AMFuture instance.\n * @param initialValue An optional initial value.\n * @returns A callable AMFuture instance.\n */\nfunction createAMFuture(initialValue) {\n    const instance = new AMFutureBase(initialValue);\n    /** Create the callable function */\n    const consumerFunction = instance.accept.bind(instance);\n    /** Assign all public properties from the base class to the function object */\n    return Object.assign(consumerFunction, {\n        eventConsumer: instance.eventConsumer,\n        refresh: instance.refresh.bind(instance),\n        set: instance.set.bind(instance),\n        map: instance.map.bind(instance),\n        once: instance.once.bind(instance),\n        toOnce: instance.toOnce.bind(instance),\n        addWeak: instance.addWeak.bind(instance),\n        add: instance.add.bind(instance),\n        remove: instance.remove.bind(instance),\n        getNow: instance.getNow.bind(instance),\n        mapToARFuture: instance.mapToARFuture.bind(instance),\n        isDone: instance.isDone.bind(instance),\n    });\n}\nexports.createAMFuture = createAMFuture;\n/**\n * Namespace for AMFuture static methods.\n */\nvar AMFuture;\n(function (AMFuture) {\n    /**\n     * Creates a new AMFuture that is already completed with the given value.\n     * @param value The completed value.\n     * @returns A new, completed AMFuture.\n     */\n    function completed(value) {\n        const res = createAMFuture();\n        res.set(value);\n        return res;\n    }\n    AMFuture.completed = completed;\n})(AMFuture || (exports.AMFuture = AMFuture = {}));\n// =============================================================================================\n// SECTION 2: FUTURE IMPLEMENTATION (Refactored)\n// =============================================================================================\n/**\n * Internal enum for future status.\n * @internal\n */\nvar FutureStatus;\n(function (FutureStatus) {\n    FutureStatus[FutureStatus[\"PENDING\"] = 0] = \"PENDING\";\n    FutureStatus[FutureStatus[\"DONE\"] = 1] = \"DONE\";\n    FutureStatus[FutureStatus[\"ERROR\"] = 2] = \"ERROR\";\n    FutureStatus[FutureStatus[\"CANCELED\"] = 3] = \"CANCELED\";\n})(FutureStatus || (FutureStatus = {}));\n/**\n * Base class for AFuture and ARFuture.\n * @internal\n */\nclass AFutureBaseImpl {\n    status = FutureStatus.PENDING;\n    errorValue = null;\n    listeners = [];\n    /**\n     * Checks if the future is in a final state (DONE, ERROR, or CANCELED).\n     * @returns True if the future is finalized.\n     */\n    isFinalStatus() { return this.status !== FutureStatus.PENDING; }\n    /**\n     * Checks if the future completed with an error.\n     * @returns True if the status is ERROR.\n     */\n    isError() { return this.status === FutureStatus.ERROR; }\n    /**\n     * Checks if the future completed successfully.\n     * @returns True if the status is DONE.\n     */\n    isDone() { return this.status === FutureStatus.DONE; }\n    /**\n     * Checks if the future was canceled.\n     * @returns True if the status is CANCELED.\n     */\n    isCanceled() { return this.status === FutureStatus.CANCELED; }\n    /**\n     * Checks if the future is *not* successfully completed.\n     * @returns True if PENDING, ERROR, or CANCELED.\n     */\n    isNotDone() { return this.status !== FutureStatus.DONE; }\n    /**\n     * Gets the error if the future is in an error state.\n     * @returns The Error object or null.\n     */\n    getError() { return this.errorValue; }\n    tryError(e) {\n        if (this.status === FutureStatus.PENDING) {\n            this.errorValue = e;\n            this.resolve(FutureStatus.ERROR);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Completes the future with an error.\n     * @param e The error.\n     * @returns This future instance.\n     */\n    error(e) {\n        if (this.status === FutureStatus.PENDING) {\n            this.errorValue = e;\n            this.resolve(FutureStatus.ERROR);\n        }\n        return this;\n    }\n    /**\n     * Alias for `error(e)`.\n     * @param e The error.\n     */\n    setError(e) { this.error(e); }\n    /**\n     * Cancels the future.\n     */\n    cancel() { this.resolve(FutureStatus.CANCELED); }\n    /**\n     * Resolves the future with a new status and notifies listeners.\n     * @param newStatus The final status.\n     * @returns True if the status was changed, false if already finalized.\n     */\n    resolve(newStatus) {\n        if (this.status !== FutureStatus.PENDING)\n            return false;\n        this.status = newStatus;\n        /** Notify listeners */\n        const currentListeners = [...this.listeners];\n        this.listeners = []; /** Clear listeners *before* firing */\n        currentListeners.forEach(l => {\n            try {\n                aether_logging_1.Log.wrap(l)(this);\n            }\n            catch (e) {\n                console.error(\"Error executing future listener:\", e);\n            }\n        });\n        return true;\n    }\n    /**\n     * Adds a listener to be called when the future is finalized.\n     * If the future is already finalized, the listener is called immediately.\n     * @param l The listener function.\n     * @returns True if the listener was added (future was pending), false otherwise.\n     */\n    addListener(l) {\n        if (this.isFinalStatus()) {\n            try {\n                l(this);\n            }\n            catch (e) {\n                console.error(\"Error executing immediate future listener:\", e);\n            }\n            return false;\n        }\n        this.listeners.push(l);\n        return true;\n    }\n    /**\n     * Adds a listener to be called only if the future is canceled.\n     * @param l The runnable to execute on cancellation.\n     * @returns This future instance.\n     */\n    onCancel(l) {\n        this.addListener(f => { if (f.isCanceled())\n            l(); });\n        return this;\n    }\n    /**\n     * Adds a listener to be called only if the future errors.\n     * @param l The consumer to accept the error.\n     * @returns This future instance.\n     */\n    onError(l) {\n        this.addListener(f => { if (f.isError() && f.getError())\n            l(f.getError()); });\n        return this;\n    }\n    /**\n     * @deprecated Synchronous waiting is not supported in JavaScript. Use .toPromise() with async/await.\n     */\n    waitSuccessful(_timeout) {\n        console.warn(\"AFutureBase.waitSuccessful is synchronous and not supported in JavaScript. Use .toPromise() instead.\");\n        return this.isDone();\n    }\n    /**\n     * @deprecated Synchronous waiting is not supported in JavaScript. Use .toPromise() with async/await.\n     */\n    waitDone(_timeout) {\n        console.warn(\"AFutureBase.waitDone is synchronous and not supported in JavaScript. Use .toPromise() instead.\");\n        return this.isFinalStatus();\n    }\n    /**\n     * Sets a timeout to mark the future as an error.\n     * @param seconds The timeout duration in seconds.\n     * @param text The error message to use.\n     * @returns This future instance.\n     */\n    timeoutError(seconds, text) {\n        const ms = seconds * 1000;\n        const timerDisposer = aether_utils_1.RU.schedule(ms, () => {\n            if (!this.isFinalStatus()) {\n                this.error(new Error(`Timeout: ${text} after ${seconds}s`));\n            }\n        });\n        /** Clean up the timer if the future completes first */\n        this.addListener(_ => timerDisposer[Symbol.dispose]());\n        return this;\n    }\n    /**\n     * Sets a timeout to execute a task and cancel the future.\n     * @param ms The timeout duration in milliseconds.\n     * @param task The task to run on timeout.\n     * @returns This future instance.\n     */\n    timeoutMs(ms, task) {\n        const timerDisposer = aether_utils_1.RU.schedule(ms, () => {\n            if (!this.isFinalStatus()) {\n                try {\n                    task();\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in future timeout task\", e);\n                }\n                this.cancel(); /** Cancel after task */\n            }\n        });\n        /** Clean up the timer if the future completes first */\n        this.addListener(_ => timerDisposer[Symbol.dispose]());\n        return this;\n    }\n    /**\n     * Converts this future to a native JavaScript Promise.\n     * @param timeoutMs Optional timeout in milliseconds for the promise.\n     * @returns A Promise that resolves or rejects based on the future's state.\n     */\n    toPromise(timeoutMs) {\n        return new Promise((resolve, reject) => {\n            let timerDisposer;\n            let timedOut = false;\n            const cleanUp = () => { if (timerDisposer) {\n                timerDisposer[Symbol.dispose]();\n                timerDisposer = undefined;\n            } };\n            if (timeoutMs !== undefined && timeoutMs > 0) {\n                timerDisposer = aether_utils_1.RU.schedule(timeoutMs, () => {\n                    timedOut = true;\n                    if (!this.isFinalStatus()) {\n                        /** Reject the promise, but don't cancel the underlying future */\n                        reject(new Error(`Future timed out after ${timeoutMs}ms`));\n                    }\n                });\n            }\n            /** Check immediate status */\n            if (this.isFinalStatus()) {\n                cleanUp();\n                if (this.isDone())\n                    resolve(undefined); /** AFuture resolves with undefined */\n                else if (this.isError())\n                    reject(this.getError() ?? new Error(\"Future failed\"));\n                else if (this.isCanceled())\n                    reject(new Error(\"Future was canceled\"));\n                return;\n            }\n            /** Add listener */\n            this.addListener(f => {\n                if (timedOut)\n                    return; /** Timed out first */\n                cleanUp();\n                if (f.isDone())\n                    resolve(undefined);\n                else if (f.isError())\n                    reject(f.getError() ?? new Error(\"Future failed\"));\n                else if (f.isCanceled())\n                    reject(new Error(\"Future was canceled\"));\n            });\n        });\n    }\n    /**\n     * Destroys the future, canceling it.\n     * @param _force (Not used).\n     * @returns A completed AFuture.\n     */\n    destroy(_force) {\n        this.cancel();\n        return AFuture.of(); /** Returns a *new* completed future */\n    }\n    /**\n     * Implements the Disposable interface.\n     */\n    [Symbol.dispose]() { this.destroy(true); }\n}\n/**\n * An asynchronous operation that completes with no return value (void).\n */\nclass AFuture extends AFutureBaseImpl {\n    /**\n     * Marks the future as successfully completed.\n     */\n    done() { this.resolve(FutureStatus.DONE); }\n    /**\n     * Attempts to mark the future as successfully completed.\n     * @returns True if the status was changed, false if already finalized.\n     */\n    tryDone() { return this.resolve(FutureStatus.DONE); }\n    /**\n     * Creates a new AFuture that completes when both this and the given future complete.\n     * @param f The other future.\n     * @returns A new AFuture.\n     */\n    and(f) {\n        return AFuture.all(this, f);\n    }\n    /**\n     * Executes a task upon successful completion.\n     * @param t The runnable task.\n     * @returns This future instance.\n     */\n    apply(t) {\n        this.to(t);\n        return this;\n    }\n    /**\n     * Maps the successful completion of this void future to a result-carrying future.\n     * @param t The supplier function to generate the result.\n     * @template T The type of the result.\n     * @returns An ARFuture with the result.\n     */\n    mapRFuture(t) {\n        const res = new ARFuture();\n        this.to(() => { try {\n            res.tryDone(t());\n        }\n        catch (e) {\n            res.error(e);\n        } }).onError((err) => res.error(err)).onCancel(() => res.cancel());\n        return res;\n    }\n    to(...args) {\n        const first = args[0];\n        const second = args[1];\n        /** Overload: to(f: AFuture) */\n        if (args.length === 1 && first instanceof AFutureBaseImpl) {\n            const f = first;\n            this.addListener(self => {\n                if (self.isDone())\n                    f.tryDone();\n                else if (self.isError())\n                    f.error(self.getError());\n                else if (self.isCanceled())\n                    f.cancel();\n            });\n            this.onCancel(() => f.cancel()); /** Propagate cancellation */\n            return this;\n        }\n        /** Overload: to(t: ARunnable) or to(executor: Executor, t: ARunnable) */\n        const taskRunnable = (typeof first === 'function' ? first : second);\n        const executor = (typeof first !== 'function' ? first : undefined);\n        if (!taskRunnable || typeof taskRunnable !== 'function' || (taskRunnable.length !== 0 && taskRunnable.length !== undefined)) {\n            /** Check for developer error. AConsumer<T> has length 1. */\n            throw new Error(\"Invalid arguments for AFuture.to (runnable variant)\");\n        }\n        const taskToRun = () => {\n            if (this.isDone()) {\n                try {\n                    taskRunnable();\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in future ARunnable task\", e);\n                }\n            }\n        };\n        this.addListener(_f => {\n            if (executor) {\n                try {\n                    executor(taskToRun);\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error submitting task to executor\", e);\n                }\n            }\n            else {\n                taskToRun();\n            }\n        });\n        return this;\n    }\n    /**\n     * Creates an AFuture that completes when the given promise resolves or rejects.\n     * @param f A supplier function that returns a Promise.\n     * @returns A new AFuture.\n     */\n    static ofPromise(f) {\n        const future = new AFuture();\n        try {\n            f().then(() => future.tryDone(), (e) => future.error(e instanceof Error ? e : new Error(String(e))));\n        }\n        catch (e) {\n            future.error(e);\n        }\n        return future;\n    }\n    /**\n     * Creates a new, pending AFuture.\n     * @returns A new AFuture.\n     */\n    static make() { return new AFuture(); }\n    /**\n     * Creates a completed AFuture or one completed with an error.\n     * @param e Optional error to complete with.\n     * @returns A new, finalized AFuture.\n     */\n    static of(e) {\n        const f = new AFuture();\n        if (e)\n            f.error(e);\n        else\n            f.tryDone();\n        return f;\n    }\n    /**\n     * Creates a new AFuture completed with an error.\n     * @param e The error.\n     * @returns A new, errored AFuture.\n     */\n    static ofThrow(e) {\n        const f = new AFuture();\n        f.error(e);\n        return f;\n    }\n    /**\n     * Returns a statically completed AFuture.\n     * @returns A completed AFuture.\n     */\n    static completed() { return AFuture.of(); }\n    /**\n     * Returns a statically canceled AFuture.\n     * @returns A canceled AFuture.\n     */\n    static canceled() {\n        const f = new AFuture();\n        f.cancel();\n        return f;\n    }\n    /**\n     * Returns an AFuture that completes when all provided futures complete.\n     * If any future errors or is canceled, the resulting future errors or is canceled.\n     * @param futures The futures to wait for.\n     * @returns A new AFuture.\n     */\n    static all(...futures) {\n        const result = new AFuture();\n        let count = futures.length;\n        let firstError = null;\n        let canceled = false;\n        if (count === 0) {\n            result.tryDone();\n            return result;\n        }\n        const checkDone = (self) => {\n            if (result.isFinalStatus())\n                return; /** Result already determined */\n            if (self.isError())\n                firstError = firstError ?? self.getError();\n            if (self.isCanceled())\n                canceled = true;\n            count--;\n            if (count === 0) { /** All futures are finalized */\n                if (canceled)\n                    result.cancel();\n                else if (firstError)\n                    result.error(firstError);\n                else\n                    result.tryDone();\n            }\n        };\n        futures.forEach(f => f.addListener(checkDone));\n        /** Propagate cancellation */\n        result.onCancel(() => futures.forEach(f => f.cancel()));\n        return result;\n    }\n    /**\n     * Returns an AFuture that completes when *any* provided future completes successfully.\n     * If all futures error or are canceled, the resulting future errors or is canceled.\n     * @param futures The futures to wait for.\n     * @returns A new AFuture.\n     */\n    static any(...futures) {\n        const result = AFuture.make();\n        if (futures.length === 0) {\n            result.cancel(); /** No futures, so it can't complete */\n            return result;\n        }\n        let errorCount = 0;\n        let cancelCount = 0;\n        const onComplete = () => {\n            if (!result.isFinalStatus()) {\n                result.tryDone();\n                /** Cancel all others */\n                futures.forEach(f => f.cancel());\n            }\n        };\n        const onError = (err) => {\n            if (!result.isFinalStatus()) {\n                errorCount++;\n                if (errorCount + cancelCount === futures.length) {\n                    /** All futures have failed or been canceled */\n                    result.error(err); /** Complete with the last error */\n                }\n            }\n        };\n        const onCancel = () => {\n            if (!result.isFinalStatus()) {\n                cancelCount++;\n                if (errorCount + cancelCount === futures.length) {\n                    /** All futures have failed or been canceled */\n                    result.cancel();\n                }\n            }\n        };\n        futures.forEach(f => f.to(onComplete).onError(onError).onCancel(onCancel));\n        return result;\n    }\n}\nexports.AFuture = AFuture;\n/**\n * An asynchronous operation that completes with a result value of type T.\n * @template T The type of the result value.\n */\nclass ARFuture extends AFutureBaseImpl {\n    value = null;\n    /**\n     * Converts this ARFuture to an ARFutureWithFlag.\n     * @returns A new ARFutureWithFlag.\n     */\n    toWithFlag() {\n        const ff = new ARFutureWithFlag();\n        this.to(ff); /** Propagates result */\n        return ff;\n    }\n    /**\n     * Marks the future as successfully completed with a value.\n     * @param value The result value.\n     */\n    done(value) {\n        if (this.status === FutureStatus.PENDING)\n            this.value = value;\n        this.resolve(FutureStatus.DONE);\n    }\n    /**\n     * Attempts to mark the future as successfully completed with a value.\n     * @param value The result value.\n     * @returns True if the status was changed, false if already finalized.\n     */\n    tryDone(value) {\n        if (this.status === FutureStatus.PENDING) {\n            this.value = value;\n            return this.resolve(FutureStatus.DONE);\n        }\n        return false;\n    }\n    /**\n     * Gets the result value.\n     * Throws an error if the future is not successfully completed.\n     * @param _timeout (Not used in JS implementation).\n     * @returns The result value.\n     */\n    get(_timeout) {\n        if (this.isDone() && this.value !== null)\n            return this.value;\n        if (this.isError())\n            throw this.errorValue ?? new Error(\"Future failed\");\n        if (this.isCanceled())\n            throw new Error(\"Future was canceled\");\n        /** This differs from Java, which would block. */\n        throw new Error(\"ARFuture.get() called on a pending future in JavaScript.\");\n    }\n    /**\n     * Gets the result value if successfully completed, otherwise null.\n     * @returns The result value or null.\n     */\n    getNow() {\n        return (this.isDone() && this.value !== null) ? this.value : null;\n    }\n    /**\n     * Gets the result value if successfully completed, otherwise returns a default.\n     * @param elseValue The value to return if not done.\n     * @returns The result value or elseValue.\n     */\n    getNowElse(elseValue) {\n        return (this.isDone() && this.value !== null) ? this.value : elseValue;\n    }\n    /**\n     * Converts this result-carrying future to a void future.\n     * @returns A new AFuture.\n     */\n    toFuture() {\n        const f = AFuture.make();\n        this.to(f); /** Propagates result (done/error/cancel) */\n        return f;\n    }\n    /**\n     * Combines this future with another, creating a new future for the tuple of results.\n     * @param f2 The other future.\n     * @template T2 The type of the other future's result.\n     * @returns A new ARFuture holding a Tuple2 [T, T2].\n     */\n    and(f2) {\n        const res = new ARFuture();\n        /** Wait for both to finalize */\n        AFuture.all(this, f2).to(() => {\n            /**\n             * This 'to' only fires if AFuture.all() is 'DONE'\n             * which means both this and f2 must be 'DONE'.\n             */\n            if (this.isDone() && f2.isDone()) {\n                res.tryDone([this.getNow(), f2.getNow()]);\n            }\n            else {\n                /** This should be unreachable */\n                res.error(new Error(\"Internal error in ARFuture.and\"));\n            }\n        }).onError((err) => res.error(err)) /** Propagate error from all() */\n            .onCancel(() => res.cancel()); /** Propagate cancel from all() */\n        return res;\n    }\n    /**\n     * Transforms the successful result of this future into a new ARFuture.\n     * @param func The mapping function.\n     * @template E The new result type.\n     * @returns A new ARFuture.\n     */\n    map(func) {\n        const res = new ARFuture();\n        this.to((value) => {\n            try {\n                res.tryDone(func(value));\n            }\n            catch (e) {\n                res.error(e);\n            }\n        }, (error) => res.error(error)).onCancel(() => res.cancel());\n        return res;\n    }\n    /**\n     * Chains this future with another async operation.\n     * @param func A function that takes the result T and returns a new ARFuture<E>.\n     * @template E The new result type.\n     * @returns A new ARFuture.\n     */\n    mapRFuture(func) {\n        const res = new ARFuture();\n        this.to((value) => {\n            try {\n                const nextFuture = func(value);\n                nextFuture.to(res); /** Propagate the result of the *next* future to res */\n            }\n            catch (e) {\n                res.error(e);\n            }\n        }, (error) => res.error(error)).onCancel(() => res.cancel());\n        return res;\n    }\n    /**\n     * Executes a task upon successful completion, preserving the original result.\n     * @param c A consumer (AConsumer<T>) or a runnable (ARunnable).\n     * @returns This future instance.\n     */\n    apply(c) {\n        this.to((value) => {\n            try {\n                /**\n                 * This will call AConsumer<T> with the value,\n                 * or ARunnable without the value.\n                 */\n                c(value);\n            }\n            catch (e) {\n                aether_logging_1.Log.error(\"Error in ARFuture.apply\", e);\n            }\n        });\n        return this;\n    }\n    /**\n     * Assumes this future's value (T) is *also* an ARFuture (e.g., ARFuture<ARFuture<E>>)\n     * and unwraps it, propagating the inner future's result.\n     * @template E The type of the inner future's result.\n     * @returns A new ARFuture<E>.\n     */\n    decompose() {\n        const res = new ARFuture();\n        this.addListener(self => {\n            if (self.isDone()) {\n                try {\n                    const innerFuture = self.getNow();\n                    if (innerFuture && typeof innerFuture.addListener === 'function') {\n                        /** Propagate the inner future's result to the new one */\n                        innerFuture.to(res);\n                    }\n                    else {\n                        /** The value was not a future, this is an error */\n                        res.error(new Error(\"Decompose failed: value is not an ARFuture\"));\n                    }\n                }\n                catch (e) {\n                    res.error(e);\n                }\n            }\n            else if (self.isError()) {\n                res.error(self.getError());\n            }\n            else if (self.isCanceled()) {\n                res.cancel();\n            }\n        });\n        return res;\n    }\n    to(...args) {\n        const first = args[0];\n        const second = args[1];\n        const third = args[2];\n        /** 1. to(onDone: AConsumer<T>) */\n        if (typeof first === 'function' && first.length === 1 && args.length === 1) {\n            this.addListener(f => { if (f.isDone())\n                first(f.getNow()); });\n            return this;\n        }\n        /** 2. to(onDone: AConsumer<T>, onError: AConsumer<Error>) */\n        else if (typeof first === 'function' && first.length === 1 && typeof second === 'function' && second.length === 1 && args.length === 2) {\n            this.addListener(f => {\n                if (f.isDone())\n                    first(f.getNow());\n                else if (f.isError() && f.getError())\n                    second(f.getError());\n            });\n            return this;\n        }\n        /** 3. to(task: AConsumer<T>, timeout: number, onTimeout: ARunnable) */\n        else if (typeof first === 'function' && first.length === 1 && typeof second === 'number' && typeof third === 'function' && args.length === 3) {\n            const task = first;\n            const timeoutMs = second > 1000000 ? second : second * 1000;\n            const onTimeout = third;\n            let timedOut = false;\n            const timerDisposer = aether_utils_1.RU.schedule(timeoutMs, () => {\n                timedOut = true;\n                try {\n                    onTimeout();\n                }\n                catch (e) {\n                    aether_logging_1.Log.error(\"Error in .to() timeout task\", e);\n                }\n            });\n            this.addListener(f => {\n                timerDisposer[Symbol.dispose](); /** Clean up timer */\n                if (!timedOut && f.isDone()) {\n                    task(f.getNow());\n                }\n            });\n            return this;\n        }\n        /** 4. to(f: ARFuture<T> | AFuture) */\n        else if (first instanceof AFutureBaseImpl && args.length === 1) {\n            const f = first;\n            this.addListener(self => {\n                if (self.isDone()) {\n                    /** Check if f is an ARFuture by checking for tryDone(value) */\n                    const fAsArFuture = f;\n                    if (fAsArFuture.tryDone && fAsArFuture.tryDone.length === 1) {\n                        fAsArFuture.tryDone(self.getNow());\n                    }\n                    else {\n                        /** It's a plain AFuture */\n                        f.tryDone();\n                    }\n                }\n                else if (self.isError()) {\n                    f.error(self.getError());\n                }\n                else if (self.isCanceled()) {\n                    f.cancel();\n                }\n            });\n            this.onCancel(() => f.cancel()); /** Propagate cancellation */\n            return this;\n        }\n        /** 5. to(t: ARunnable) or to(executor: Executor, t: ARunnable) */\n        else {\n            const taskRunnable = (typeof first === 'function' ? first : second);\n            const executor = (typeof first !== 'function' ? first : undefined);\n            if (!taskRunnable || typeof taskRunnable !== 'function' || (taskRunnable.length !== 0 && taskRunnable.length !== undefined)) {\n                throw new Error(\"Invalid arguments for ARFuture.to (runnable)\");\n            }\n            const taskToRun = () => {\n                if (this.isDone()) { /** Only run if 'done' */\n                    try {\n                        taskRunnable();\n                    }\n                    catch (e) {\n                        aether_logging_1.Log.error(\"Error in future ARunnable task\", e);\n                    }\n                }\n            };\n            this.addListener(_f => {\n                if (executor) {\n                    try {\n                        executor(taskToRun);\n                    }\n                    catch (e) {\n                        aether_logging_1.Log.error(\"Error submitting task to executor\", e);\n                    }\n                }\n                else {\n                    taskToRun();\n                }\n            });\n            return this;\n        }\n    }\n    /**\n     * Converts this future to a native JavaScript Promise.\n     * @param timeoutMs Optional timeout in milliseconds for the promise.\n     * @returns A Promise<T> that resolves or rejects based on the future's state.\n     */\n    toPromise(timeoutMs) {\n        return new Promise((resolve, reject) => {\n            let timerDisposer;\n            let timedOut = false;\n            const cleanUp = () => { if (timerDisposer) {\n                timerDisposer[Symbol.dispose]();\n                timerDisposer = undefined;\n            } };\n            if (timeoutMs !== undefined && timeoutMs > 0) {\n                timerDisposer = aether_utils_1.RU.schedule(timeoutMs, () => {\n                    timedOut = true;\n                    if (!this.isFinalStatus()) {\n                        reject(new Error(`Future timed out after ${timeoutMs}ms`));\n                    }\n                });\n            }\n            /** Check immediate status */\n            if (this.isFinalStatus()) {\n                cleanUp();\n                if (this.isDone())\n                    resolve(this.getNow());\n                else if (this.isError())\n                    reject(this.getError() ?? new Error(\"Future failed\"));\n                else if (this.isCanceled())\n                    reject(new Error(\"Future canceled\"));\n                return;\n            }\n            /** Add listener */\n            this.addListener(f => {\n                if (timedOut)\n                    return;\n                cleanUp();\n                if (f.isDone())\n                    resolve(f.getNow());\n                else if (f.isError())\n                    reject(f.getError() ?? new Error(\"Future failed\"));\n                else if (f.isCanceled())\n                    reject(new Error(\"Future canceled\"));\n            });\n        });\n    }\n    /**\n     * Creates a new, pending ARFuture, or a completed one if a value is provided.\n     * @param value Optional initial value to complete with.\n     * @returns A new ARFuture.\n     */\n    static of(value) {\n        const f = new ARFuture();\n        if (value !== undefined)\n            f.done(value);\n        return f;\n    }\n    static make() {\n        return new ARFuture();\n    }\n    /**\n     * Returns a statically canceled ARFuture.\n     * @returns A new, canceled ARFuture.\n     */\n    static canceled() {\n        const f = new ARFuture();\n        f.cancel();\n        return f;\n    }\n    /**\n     * Creates a new ARFuture completed with an error.\n     * @param throwable The error.\n     * @returns A new, errored ARFuture.\n     */\n    static ofThrow(throwable) {\n        const f = new ARFuture();\n        f.error(throwable);\n        return f;\n    }\n    /**\n     * Returns an ARFuture that completes with an array of all results.\n     * If any future errors or is canceled, the resulting future errors or is canceled.\n     * @param list The array of futures.\n     * @returns A new ARFuture holding an array of results.\n     */\n    static all(list) {\n        const futures = list;\n        if (futures.length === 0) {\n            return ARFuture.of([]);\n        }\n        const result = new ARFuture();\n        const results = new Array(futures.length).fill(null);\n        /** Wait for all to finalize */\n        AFuture.all(...futures).to(() => {\n            /** If all() is 'DONE', all futures in the list must be 'DONE' */\n            futures.forEach((f, index) => {\n                results[index] = f.getNow();\n            });\n            result.tryDone(results);\n        }).onError((err) => result.error(err)) /** Propagate error */\n            .onCancel(() => result.cancel()); /** Propagate cancel */\n        return result;\n    }\n}\nexports.ARFuture = ARFuture;\n/**\n * An ARFuture that includes a `tryRequest` flag, often used in\n * reactive maps (like BMap) to prevent re-fetching.\n * @template T The type of the result value.\n */\nclass ARFutureWithFlag extends ARFuture {\n    requested = false;\n    /**\n     * Attempts to set the \"requested\" flag.\n     * @returns True if the flag was set (was false), false otherwise.\n     */\n    tryRequest() {\n        if (this.isFinalStatus() || this.requested)\n            return false;\n        this.requested = true;\n        return true;\n    }\n    /**\n     * Attempts to complete the future with an error.\n     * @param error The error.\n     * @returns True if the status was changed, false if already finalized.\n     */\n    tryError(error) {\n        const initialStatus = this.status;\n        this.error(error);\n        /** Returns true only if this call *caused* the error state */\n        return initialStatus === FutureStatus.PENDING && this.status === FutureStatus.ERROR;\n    }\n    /**\n     * @override\n     */\n    resolve(newStatus) {\n        const success = super.resolve(newStatus);\n        if (success) {\n            /** Reset the request flag when the future is finalized */\n            this.requested = false;\n        }\n        return success;\n    }\n}\nexports.ARFutureWithFlag = ARFutureWithFlag;\n//# sourceMappingURL=aether_future.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_future.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_logging.js":
/*!************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_logging.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether_logging.ts (TypeScript Contextual Logger Implementation - FINAL)\n// PURPOSE: A powerful contextual and structured logger, ported from the new Java architecture.\n//          LogInternal = Static class with global stack and logic.\n//          Log = Public facade.\n//          LNode = \"Smart\" node with instance methods for logging.\n//\n// NOTE: This version uses a global stack, not AsyncLocalStorage.\n// Context must be manually propagated into async callbacks using `Log.wrap()`.\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Log = exports.LNode = exports.LogKeys = exports.LogLevel = void 0;\nconst aether_astring_1 = __webpack_require__(/*! ./aether_astring */ \"./node_modules/aether-client/build/aether_astring.js\");\nconst LogPrinter_1 = __webpack_require__(/*! ./LogPrinter */ \"./node_modules/aether-client/build/LogPrinter.js\");\n// --- Type Definitions ---\n/** Log levels corresponding to the Java Enum. */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"TRACE\"] = \"TRACE\";\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARN\"] = \"WARN\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n})(LogLevel || (exports.LogLevel = LogLevel = {}));\n/** Log entry keys (similar to Log.java constants). */\nexports.LogKeys = {\n    TIME: 'logTime',\n    LEVEL: 'logLevel',\n    SYSTEM_COMPONENT: 'SystemComponent',\n    MSG: 'logMessage',\n    EXCEPTION_STR: 'exception',\n};\n// =============================================================================================\n// LNode Implementation (The \"Smart\" Node)\n// =============================================================================================\nlet LNODE_ID_COUNTER = 0;\n/**\n * A single, immutable log context node.\n * This class now contains instance methods (.info, .warn, .add)\n * that create new child nodes, using `this` as the parent.\n */\nclass LNode {\n    /** The unique ID for this node. */\n    id = LNODE_ID_COUNTER++;\n    /** The parent node in the single-linked list. */\n    parent;\n    constructor(parent) {\n        this.parent = parent;\n    }\n    // --- Core \"add\" Methods (equivalent to Java LNode.add) ---\n    /**\n     * Creates a new LNode (from key-value data) with `this` as its parent.\n     * @param data The key-value data object.\n     * @returns The new LNode.\n     */\n    add(data) {\n        return LNode.ofData(this, data);\n    }\n    /**\n     * Creates a new composite LNode with `this` as its parent.\n     * @param nodes The child nodes to compose.\n     * @returns The new LNode.\n     */\n    addNodes(nodes) {\n        return LNode.ofComposite(this, nodes);\n    }\n    // --- Core API Methods (get, forEach, context) ---\n    /**\n     * Pushes this node onto the stack and returns a Disposable\n     * that will pop it off when disposed.\n     * @returns A ContextCloser (Disposable).\n     */\n    context() {\n        LogInternal.push(this);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        return {\n            node: self,\n            [Symbol.dispose]() {\n                LogInternal.pop(self);\n            }\n        };\n    }\n    /**\n     * Gets a value for a key, recursively searching parents (O(N) complexity).\n     * @param key The key to look up.\n     * @returns The value, or undefined if not found.\n     */\n    get(key) {\n        let val = this.get0(key);\n        if (val !== undefined) {\n            return val;\n        }\n        if (this.parent) {\n            return this.parent.get(key);\n        }\n        return undefined;\n    }\n    /**\n     * Iterates over all key-value pairs, recursively searching parents.\n     * @param callback The consumer to accept key-value pairs.\n     */\n    forEach(callback) {\n        const seenKeys = new Set();\n        let current = this;\n        while (current) {\n            current.forEach0((key, value) => {\n                if (!seenKeys.has(key)) {\n                    callback(key, value);\n                    seenKeys.add(key);\n                }\n            });\n            current = current.parent;\n        }\n    }\n    /**\n     * Counts all key-value pairs, recursively searching parents.\n     * @returns The total count of unique pairs.\n     */\n    count() {\n        let count = this.count0();\n        if (this.parent) {\n            count += this.parent.count(); // Note: This isn't perfectly accurate for composite keys\n        }\n        return count;\n    }\n    /**\n     * Checks if the node and its parents are empty.\n     * @returns true if count() is 0.\n     */\n    isEmpty() {\n        return this.count() === 0;\n    }\n    /**\n     * Checks if a specific value exists in the context for a given key.\n     * @param key The key to check.\n     * @param value The value to check against.\n     * @returns true if equal.\n     */\n    check(key, value) {\n        return this.get(key) === value;\n    }\n    /**\n     * Gets the log level (Log.LEVEL).\n     * @returns The LogLevel enum, or undefined.\n     */\n    getLevel() {\n        return this.get(exports.LogKeys.LEVEL);\n    }\n    // --- Instance Logging Methods (The \"Syntax Sugar\") ---\n    // These methods create a new log node and FIRE it.\n    /**\n     * Logs a custom LNode, firing it to the event bus.\n     * @param node The node to log.\n     */\n    log(node) {\n        if (!LogInternal.IS_ENABLED)\n            return;\n        LogInternal.fire(node);\n    }\n    /**\n     * Logs a TRACE level message.\n     * @param msg The message string or ToString object.\n     * @param data Additional key-value data.\n     * @returns The created LNode.\n     */\n    trace(msg, data = {}) {\n        if (!LogInternal.IS_ENABLED || !LogInternal.TRACE)\n            return LNode.EMPTY;\n        data[exports.LogKeys.TIME] = Date.now();\n        data[exports.LogKeys.LEVEL] = LogLevel.TRACE;\n        data[exports.LogKeys.MSG] = LogInternal.resolveMessage(msg);\n        const logNode = this.add(data);\n        LogInternal.fire(logNode);\n        return logNode;\n    }\n    /**\n     * Logs a DEBUG level message.\n     * @param msg The message string or ToString object.\n     * @param data Additional key-value data.\n     * @returns The created LNode.\n     */\n    debug(msg, data = {}) {\n        if (!LogInternal.IS_ENABLED)\n            return LNode.EMPTY;\n        data[exports.LogKeys.TIME] = Date.now();\n        data[exports.LogKeys.LEVEL] = LogLevel.DEBUG;\n        data[exports.LogKeys.MSG] = LogInternal.resolveMessage(msg);\n        const logNode = this.add(data);\n        LogInternal.fire(logNode);\n        return logNode;\n    }\n    /**\n     * Logs an INFO level message.\n     * @param msg The message string or ToString object.\n     * @param data Additional key-value data.\n     * @returns The created LNode.\n     */\n    info(msg, data = {}) {\n        if (!LogInternal.IS_ENABLED)\n            return LNode.EMPTY;\n        data[exports.LogKeys.TIME] = Date.now();\n        data[exports.LogKeys.LEVEL] = LogLevel.INFO;\n        data[exports.LogKeys.MSG] = LogInternal.resolveMessage(msg);\n        let logNode = this.add(data);\n        LogInternal.fire(logNode);\n        return logNode;\n    }\n    /**\n     * Logs a WARN level message.\n     * @param msg The message string or ToString object.\n     * @param data Additional key-value data.\n     * @returns The created LNode.\n     */\n    warn(msg, data = {}) {\n        if (!LogInternal.IS_ENABLED)\n            return LNode.EMPTY;\n        data[exports.LogKeys.TIME] = Date.now();\n        data[exports.LogKeys.LEVEL] = LogLevel.WARN;\n        data[exports.LogKeys.MSG] = LogInternal.resolveMessage(msg);\n        const logNode = this.add(data);\n        LogInternal.fire(logNode);\n        return logNode;\n    }\n    /**\n     * Logs an ERROR level message.\n     * @param msgOrThrowable The message, or the Error itself.\n     * @param throwableOrData The Error (if msg was provided) or data (if Error was provided).\n     * @param data Additional data.\n     * @returns The created LNode.\n     */\n    error(msgOrThrowable, throwableOrData, data = {}) {\n        if (!LogInternal.IS_ENABLED)\n            return LNode.EMPTY;\n        let msg;\n        let throwable;\n        let finalData = data; //   3- \n        if (msgOrThrowable instanceof Error) {\n            throwable = msgOrThrowable;\n            msg = throwable.message;\n            //  2-  ,    finalData\n            if (throwableOrData)\n                finalData = throwableOrData;\n        }\n        else {\n            msg = msgOrThrowable;\n            if (throwableOrData instanceof Error) {\n                throwable = throwableOrData;\n                // finalData  `data` (3- )\n            }\n            else if (throwableOrData) {\n                // 2-  -  ,   3-\n                finalData = { ...throwableOrData, ...data };\n            }\n        }\n        // `finalData` -  ,   \n        finalData[exports.LogKeys.TIME] = Date.now();\n        finalData[exports.LogKeys.LEVEL] = LogLevel.ERROR;\n        finalData[exports.LogKeys.MSG] = LogInternal.resolveMessage(msg);\n        if (throwable) {\n            finalData[exports.LogKeys.EXCEPTION_STR] = throwable;\n        }\n        const logNode = this.add(finalData); //   \n        LogInternal.fire(logNode);\n        return logNode;\n    }\n    // --- Static Factory Methods (Used by .add() and Log facade) ---\n    /**\n     * Factory for creating a node from key-value data.\n     * @param parent The parent node.\n     * @param data The data object.\n     * @returns A new LNode.\n     */\n    static ofData(parent, data) {\n        const map = new Map(Object.entries(data));\n        const keys = Object.keys(data);\n        return new class extends LNode {\n            constructor() { super(parent); }\n            get0(key) { return map.get(key); }\n            forEach0(cb) {\n                map.forEach((v, k) => cb(k, v));\n            }\n            count0() { return keys.length; }\n        }();\n    }\n    /**\n     * Factory for creating a composite node from other LNodes.\n     * @param parent The parent node.\n     * @param nodes The child nodes to compose.\n     * @returns A new LNode.\n     */\n    static ofComposite(parent, nodes) {\n        const validNodes = nodes.filter(n => n && !n.isEmpty());\n        return new class extends LNode {\n            constructor() { super(parent); }\n            get0(key) {\n                for (const n of validNodes) {\n                    const val = n.get(key); // Must use get() to check internal parents\n                    if (val !== undefined)\n                        return val;\n                }\n                return undefined;\n            }\n            forEach0(cb) {\n                for (const n of validNodes) {\n                    n.forEach(cb); // Must use forEach() to get all data\n                }\n            }\n            count0() {\n                return validNodes.reduce((sum, n) => sum + n.count(), 0);\n            }\n        }();\n    }\n    /**\n     * A global, shared, immutable empty LNode.\n     * This is returned when logging is disabled, silencing all\n     * subsequent chained calls (.info, .warn, etc).\n     */\n    static EMPTY = new class extends LNode {\n        constructor() { super(null); }\n        get0() { return undefined; }\n        forEach0() { }\n        count0() { return 0; }\n        // Override all methods to do nothing\n        add() { return this; }\n        addNodes() { return this; }\n        context() { return { node: this, [Symbol.dispose]: () => { } }; }\n        log() { }\n        trace() { return this; }\n        debug() { return this; }\n        info() { return this; }\n        warn() { return this; }\n        error() { return this; }\n    }();\n}\nexports.LNode = LNode;\n// =============================================================================================\n// LogInternal Class (The Static Facade and Stack Manager)\n// =============================================================================================\n/**\n * Central static logic and state management for the logger.\n * Renamed to `LogInternal` to avoid conflict with the exported `Log` const.\n */\nclass LogInternal {\n    /**\n     * The global logger stack.\n     * This is a simple array, mimicking Java's ThreadLocal.\n     * It is not automatically async-safe; `Log.wrap()` must be used.\n     */\n    static STACK = [];\n    /**\n     * Global TRACE toggle.\n     */\n    static TRACE = true;\n    /**\n     * Global logger toggle.\n     */\n    static IS_ENABLED = true;\n    static LOG_FILTER = (_node) => LogInternal.IS_ENABLED;\n    static LISTENERS = [];\n    // --- Core Stack Management (Global Array) ---\n    /**\n     * Gets the current LNode from the top of the global stack.\n     * If the stack is empty, it creates and pushes\n     * a new \"Root Node\" to act as a base parent.\n     * @returns The current LNode, or LNode.EMPTY if logging is disabled.\n     */\n    static get() {\n        // Case 1: Logging is globally disabled.\n        if (!LogInternal.IS_ENABLED) {\n            return LNode.EMPTY;\n        }\n        // We use the simple global STACK array. It always exists.\n        const store = this.STACK;\n        // Case 2: The stack is empty. Create and push the Root Node.\n        // This is now 1:1 identical to your Java logic.\n        if (store.length === 0) {\n            // LNode.ofData(null, {}) creates the Root Node (null parent, empty data).\n            const rootNode = LNode.ofData(null, {});\n            // Push this new root node onto the stack.\n            store.push(rootNode);\n            return rootNode;\n        }\n        // Case 3: The stack is not empty. Return the top element.\n        return store[store.length - 1];\n    }\n    /**\n     * Pushes a new node onto the global stack.\n     * @param node The LNode to push.\n     */\n    static push(node) {\n        if (!LogInternal.IS_ENABLED)\n            return;\n        this.STACK.push(node);\n    }\n    /**\n     * Pops the expected node from the global stack.\n     * @param node The LNode to pop.\n     */\n    static pop(node) {\n        if (!LogInternal.IS_ENABLED)\n            return;\n        const store = this.STACK;\n        if (store.length > 0) {\n            const top = store[store.length - 1];\n            if (top === node) {\n                store.pop();\n            }\n            else {\n                console.error(\"Logger context stack corruption: Node to pop is not the top element.\");\n            }\n        }\n        else {\n            // Store exists, but is empty\n            console.error(\"Logger context stack corruption: Pop called on empty stack.\");\n        }\n    }\n    // --- Centralized Event & Utility Methods ---\n    /**\n     * Centralized method to dispatch a log event.\n     * Applies the global filter and fires an event to listeners.\n     * @param node The LNode to fire.\n     */\n    static fire(node) {\n        if (!LogInternal.IS_ENABLED)\n            return;\n        if (!LogInternal.LOG_FILTER(node)) {\n            return;\n        }\n        this.LISTENERS.forEach(listener => {\n            try {\n                if (listener.filter(node)) {\n                    listener.consumer(node);\n                }\n            }\n            catch (e) {\n                console.error(\"Error in log listener:\", e);\n            }\n        });\n    }\n    /**\n     * Resolves a message object (string or ToString) into a string.\n     * @param msg The message to resolve.\n     * @returns The plain string message.\n     */\n    static resolveMessage(msg) {\n        if (typeof msg === 'string')\n            return msg;\n        try {\n            const sb = aether_astring_1.AString.of();\n            msg.toString(sb);\n            return sb.toString();\n        }\n        catch (e) {\n            return `[Error rendering object: ${e instanceof Error ? e.message : String(e)}]`;\n        }\n    }\n    // --- Proxy Logging API Methods ---\n    // These methods simply delegate to the current LNode (LogInternal.get()).\n    /**\n     * Creates a new LNode from data, using the current node as parent.\n     * @param data The key-value data.\n     * @returns The new LNode.\n     */\n    static of(data = {}) {\n        return this.get().add(data);\n    }\n    /**\n     * Creates a new composite LNode from other nodes, using the current node as parent.\n     * @param nodes The nodes to compose.\n     * @returns The new LNode.\n     */\n    static ofNodes(nodes) {\n        return this.get().addNodes(nodes);\n    }\n    /**\n     * Creates an auto-closing context.\n     * @param dataOrNode The data for a new node, or an existing node.\n     * @returns A ContextCloser (Disposable).\n     */\n    static context(dataOrNode) {\n        let node;\n        if (dataOrNode instanceof LNode) {\n            node = dataOrNode;\n        }\n        else {\n            node = this.get().add(dataOrNode);\n        }\n        return node.context();\n    }\n    /**\n     * Creates a new LNode with the current node as parent, but DOES NOT push it.\n     * This is just an alias for `LogInternal.of()`.\n     * @param data The key-value data.\n     * @returns The new LNode.\n     */\n    static createContext(data = {}) {\n        return this.get().add(data);\n    }\n    static trace(msg, data = {}) { return this.get().trace(msg, data); }\n    static debug(msg, data = {}) { return this.get().debug(msg, data); }\n    static info(msg, data = {}) { return this.get().info(msg, data); }\n    static warn(msg, data = {}) { return this.get().warn(msg, data); }\n    static error(msg, throwable, data = {}) {\n        return this.get().error(msg, throwable, data);\n    }\n    // --- Wrapper Methods (Manual Context Propagation) ---\n    /**\n     * Wraps a function to ensure it runs with the *current* logging context.\n     * This is necessary for manual context propagation into callbacks\n     * like setTimeout, setInterval, or event listeners.\n     * @param fn The function to wrap.\n     * @returns The wrapped function.\n     */\n    static wrap(fn) {\n        // Capture the node that is active *when wrap is called*.\n        const capturedNode = this.get();\n        if (!capturedNode || capturedNode.isEmpty()) {\n            return fn; // Nothing to capture\n        }\n        const wrapper = function (...args) {\n            // When the wrapper executes (e.g., in a setTimeout):\n            // Check what the *current* global node is.\n            // We MUST use the STACK directly, not get(), to avoid\n            // creating a new Root node if the stack is empty.\n            const currentNode = LogInternal.STACK.length > 0 ?\n                LogInternal.STACK[LogInternal.STACK.length - 1] :\n                null;\n            // We only need to push/pop if the current node\n            // is different from the one we captured.\n            const needsPush = !currentNode || currentNode.id !== capturedNode.id;\n            if (needsPush) {\n                LogInternal.push(capturedNode);\n            }\n            try {\n                return fn.apply(this, args);\n            }\n            finally {\n                if (needsPush) {\n                    LogInternal.pop(capturedNode);\n                }\n            }\n        };\n        return wrapper;\n    }\n    static wrapExecutor(executor) {\n        return (command) => {\n            const wrappedCommand = this.wrap(command);\n            executor(wrappedCommand);\n        };\n    }\n    // --- Global Controls ---\n    static loggerOff() { this.IS_ENABLED = false; }\n    static loggerOn() { this.IS_ENABLED = true; }\n    static addFilter(filter) {\n        const oldFilter = this.LOG_FILTER;\n        this.LOG_FILTER = (node) => oldFilter(node) && filter(node);\n    }\n    static addListener(filter, consumer) {\n        // Wrap the consumer to ensure it runs with the context\n        // that was active when addListener was called.\n        const wrappedConsumer = this.wrap(consumer);\n        const listenerEntry = { filter, consumer: wrappedConsumer, disposer: { [Symbol.dispose]: () => { } } };\n        const disposer = {\n            [Symbol.dispose]: () => {\n                const index = LogInternal.LISTENERS.indexOf(listenerEntry);\n                if (index > -1) {\n                    LogInternal.LISTENERS.splice(index, 1);\n                }\n            },\n        };\n        listenerEntry.disposer = disposer;\n        LogInternal.LISTENERS.push(listenerEntry);\n        return disposer;\n    }\n    // --- Printer Factory ---\n    static consolePrinter = null;\n    /**\n         * Creates and attaches a colored console printer, similar to the Java version.\n         * Ensures only one console printer is created.\n         * @param filter An optional filter to apply just for this printer.\n         */\n    static printConsoleColored(filter = () => true) {\n        if (LogInternal.consolePrinter) {\n            return LogInternal.consolePrinter;\n        }\n        const columns = [\n            LogPrinter_1.LogPrinter.col(exports.LogKeys.TIME, (v) => // <-- Changed to number\n             new Date(v).toISOString().substring(11, 23) // Format timestamp\n            ).min(12),\n            LogPrinter_1.LogPrinter.splitter(\" \"),\n            LogPrinter_1.LogPrinter.col(exports.LogKeys.LEVEL).min(5),\n            LogPrinter_1.LogPrinter.splitter(\"\"),\n            LogPrinter_1.LogPrinter.col(exports.LogKeys.SYSTEM_COMPONENT).min(10),\n            LogPrinter_1.LogPrinter.splitter(\"\"),\n            LogPrinter_1.LogPrinter.col(exports.LogKeys.MSG).min(50),\n            LogPrinter_1.LogPrinter.splitter(\"  \"),\n            LogPrinter_1.LogPrinter.colAll()\n        ];\n        const printer = new class extends LogPrinter_1.LogPrinter {\n            constructor() { super(columns, filter); }\n            printNode(s, n) {\n                const level = n.getLevel();\n                if (level) {\n                    switch (level) {\n                        case LogLevel.TRACE:\n                            s.styleForeground(null, 150, 150, 150);\n                            break;\n                        case LogLevel.DEBUG:\n                            s.styleForeground(null, 100, 255, 100);\n                            break;\n                        case LogLevel.INFO:\n                            s.styleForeground(null, 100, 100, 255);\n                            break;\n                        case LogLevel.WARN:\n                            s.styleForeground(null, 255, 50, 50);\n                            break;\n                        case LogLevel.ERROR:\n                            s.styleForeground(null, 255, 0, 0);\n                            break;\n                    }\n                }\n                super.printNode(s, n);\n                s.styleClear();\n                return s;\n            }\n        }();\n        LogInternal.addListener(filter, (node) => {\n            const sb = aether_astring_1.AString.of();\n            printer.printNode(sb, node);\n            console.log(sb.toString());\n        });\n        LogInternal.consolePrinter = printer;\n        return printer;\n    }\n}\n/**\n * The globally accessible logging object (Facade), providing static-like methods\n * for contextual logging.\n *\n * NOTE: This implementation uses a global stack and is not automatically\n * safe for concurrent asynchronous operations. You must use `Log.wrap()`\n * to manually propagate context into async callbacks (e.g., setTimeout).\n */\nexports.Log = {\n    // Keys\n    LEVEL: exports.LogKeys.LEVEL,\n    SYSTEM_COMPONENT: exports.LogKeys.SYSTEM_COMPONENT,\n    MSG: exports.LogKeys.MSG,\n    EXCEPTION_STR: exports.LogKeys.EXCEPTION_STR,\n    of: LogInternal.of.bind(LogInternal),\n    ofNodes: LogInternal.ofNodes.bind(LogInternal),\n    get: LogInternal.get.bind(LogInternal),\n    push: LogInternal.push.bind(LogInternal),\n    pop: LogInternal.pop.bind(LogInternal),\n    context: LogInternal.context.bind(LogInternal),\n    createContext: LogInternal.createContext.bind(LogInternal),\n    trace: LogInternal.trace.bind(LogInternal),\n    debug: LogInternal.debug.bind(LogInternal),\n    info: LogInternal.info.bind(LogInternal),\n    warn: LogInternal.warn.bind(LogInternal),\n    error: LogInternal.error.bind(LogInternal),\n    wrapExecutor: LogInternal.wrapExecutor.bind(LogInternal),\n    wrap: LogInternal.wrap.bind(LogInternal),\n    loggerOff: LogInternal.loggerOff.bind(LogInternal),\n    loggerOn: LogInternal.loggerOn.bind(LogInternal),\n    addFilter: LogInternal.addFilter.bind(LogInternal),\n    addListener: LogInternal.addListener.bind(LogInternal),\n    printConsoleColored: LogInternal.printConsoleColored.bind(LogInternal),\n};\n//# sourceMappingURL=aether_logging.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_logging.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_rcollection.js":
/*!****************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_rcollection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * @file aether_rcollection.ts\n * @purpose Contains reactive collection implementations (RMap, RSet, RQueue, BMap).\n * @dependencies aether.types.ts, aether.logging.ts, aether.utils.ts, aether_future.ts\n *\n * @version 4.0.0\n * @description   `extends JObj`.\n * CustomHashMap    :\n * 1. .hashCode()/.equals()  ,   .\n * 2.  /   (number, string, bigint).\n * 3. `allRequests`  `BMapSender.requests`  BMapImpl  CustomHashMap.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RCol = exports.RQueueBySrc = exports.RSetBySrc = exports.RCollectionBySrc = exports.BMapImpl = exports.RMapBySrc = exports.RMapUpdate = void 0;\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\nconst aether_future_2 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\n// =============================================================================================\n// SECTION 0: CustomHashMap (  HashMap)\n// =============================================================================================\n/**\n *   HashMap,  .hashCode()  .equals()\n *   (  )     .\n * @template K The key type.\n * @template V The value type.\n */\nclass CustomHashMap {\n    // : hashCode -> \"\" (  [, ])\n    buckets = new Map();\n    _size = 0;\n    constructor(initialEntries) {\n        if (initialEntries) {\n            for (const [key, value] of initialEntries) {\n                this.set(key, value);\n            }\n        }\n    }\n    /**\n     *  -  .\n     *   .hashCode(),     String(key).\n     */\n    _getHash(key) {\n        if (key === null || key === undefined)\n            return 0;\n        // 1.   JObj-\n        if (typeof key === 'object' && typeof key.hashCode === 'function') {\n            return key.hashCode();\n        }\n        // 2. \n        if (typeof key === 'number') {\n            return key | 0; //    \n        }\n        if (typeof key === 'bigint') {\n            const hash = key ^ (key >> 32n); // Java's Long.hashCode\n            return Number(hash & 0xffffffffn) | 0;\n        }\n        if (typeof key === 'string') {\n            let hash = 0;\n            for (let i = 0; i < key.length; i++) {\n                hash = (31 * hash + key.charCodeAt(i)) | 0;\n            }\n            return hash;\n        }\n        // 3. Fallback    (boolean, etc.)\n        const s = String(key);\n        let hash = 0;\n        for (let i = 0; i < s.length; i++) {\n            hash = (31 * hash + s.charCodeAt(i)) | 0;\n        }\n        return hash;\n    }\n    /**\n     *     .\n     *   .equals(),   ===.\n     */\n    _isEqual(keyA, keyB) {\n        if (keyA === keyB)\n            return true;\n        if (keyA === null || keyA === undefined)\n            return (keyB === null || keyB === undefined);\n        if (keyB === null || keyB === undefined)\n            return false;\n        // 1.   JObj-\n        if (typeof keyA === 'object' && typeof keyA.equals === 'function') {\n            return keyA.equals(keyB);\n        }\n        // 2.  (  ===,    )\n        // (bigint === bigint)    \n        // (number === number)  \n        // (string === string)  \n        // 3. Fallback (   .equals)\n        return false;\n    }\n    set(key, value) {\n        const hash = this._getHash(key);\n        let bucket = this.buckets.get(hash);\n        if (!bucket) {\n            //  \n            this.buckets.set(hash, [[key, value]]);\n            this._size++;\n            return this;\n        }\n        //  ,  \n        for (const entry of bucket) {\n            if (this._isEqual(entry[0], key)) {\n                //  ,  \n                entry[1] = value;\n                return this;\n            }\n        }\n        //   ,    ()\n        bucket.push([key, value]);\n        this._size++;\n        return this;\n    }\n    get(key) {\n        const bucket = this.buckets.get(this._getHash(key));\n        if (!bucket) {\n            return undefined;\n        }\n        for (const entry of bucket) {\n            if (this._isEqual(entry[0], key)) {\n                return entry[1]; //  \n            }\n        }\n        return undefined; //     \n    }\n    has(key) {\n        const bucket = this.buckets.get(this._getHash(key));\n        if (!bucket) {\n            return false;\n        }\n        for (const entry of bucket) {\n            if (this._isEqual(entry[0], key)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    delete(key) {\n        const hash = this._getHash(key);\n        const bucket = this.buckets.get(hash);\n        if (!bucket) {\n            return false;\n        }\n        for (let i = 0; i < bucket.length; i++) {\n            if (this._isEqual(bucket[i][0], key)) {\n                //  , \n                bucket.splice(i, 1);\n                this._size--;\n                //   ,   \n                if (bucket.length === 0) {\n                    this.buckets.delete(hash);\n                }\n                return true;\n            }\n        }\n        return false; //   \n    }\n    get size() {\n        return this._size;\n    }\n    clear() {\n        this.buckets.clear();\n        this._size = 0;\n    }\n    // --- Iterators ---\n    *entries() {\n        for (const bucket of this.buckets.values()) {\n            yield* bucket;\n        }\n    }\n    *[Symbol.iterator]() {\n        yield* this.entries();\n    }\n    *keys() {\n        for (const bucket of this.buckets.values()) {\n            for (const entry of bucket) {\n                yield entry[0];\n            }\n        }\n    }\n    *values() {\n        for (const bucket of this.buckets.values()) {\n            for (const entry of bucket) {\n                yield entry[1];\n            }\n        }\n    }\n    forEach(callbackfn, thisArg) {\n        for (const bucket of this.buckets.values()) {\n            for (const [key, value] of bucket) {\n                callbackfn.call(thisArg, value, key, this);\n            }\n        }\n    }\n}\n// =============================================================================================\n// SECTION 1: RMap (Reactive Map)\n// =============================================================================================\n/**\n * Represents an update event in an RMap.\n * @template K The key type.\n * @template V The value type.\n */\nclass RMapUpdate {\n    key;\n    newValue;\n    oldValue;\n    /**\n     * @param key The key that was updated.\n     * @param newValue The new value associated with the key.\n     * @param oldValue The previous value (if any) associated with the key.\n     */\n    constructor(key, newValue, oldValue) {\n        this.key = key;\n        this.newValue = newValue;\n        this.oldValue = oldValue;\n    }\n}\nexports.RMapUpdate = RMapUpdate;\n/**\n * Base implementation for RMap that wraps a **CustomHashMap**.\n * @template K The key type.\n * @template V The value type.\n */\nclass RMapBySrc {\n    src;\n    [Symbol.toStringTag] = \"RMap\";\n    updateEvent = new aether_future_1.EventConsumer();\n    removeEvent = new aether_future_1.EventConsumer();\n    /**\n     * @param src The underlying CustomHashMap instance to wrap.\n     */\n    constructor(src) {\n        this.src = src;\n    }\n    forUpdate() { return this.updateEvent; }\n    forRemove() { return this.removeEvent; }\n    /**\n     *   ,   mapKeyFuture\n     */\n    _isEqual(keyA, keyB) {\n        if (keyA === keyB)\n            return true;\n        if (keyA === null || keyA === undefined)\n            return (keyB === null || keyB === undefined);\n        if (keyB === null || keyB === undefined)\n            return false;\n        // 1.   JObj-\n        if (typeof keyA === 'object' && typeof keyA.equals === 'function') {\n            return keyA.equals(keyB);\n        }\n        return false;\n    }\n    set(key, value) {\n        const oldValue = this.src.get(key) ?? null;\n        if (oldValue === value || (oldValue !== null && this._isEqual(oldValue, value))) {\n            return this;\n        }\n        this.src.set(key, value);\n        this.updateEvent.fire(new RMapUpdate(key, value, oldValue));\n        return this;\n    }\n    delete(key) {\n        const oldValue = this.src.get(key);\n        if (oldValue !== undefined) {\n            const result = this.src.delete(key);\n            if (result) {\n                this.removeEvent.fire({ key: key, value: oldValue });\n            }\n            return result;\n        }\n        return false;\n    }\n    clear() {\n        for (const [key, value] of this.src.entries()) {\n            // Must fire event for each removed item\n            this.removeEvent.fire({ key: key, value: value });\n        }\n        this.src.clear();\n    }\n    get(key) {\n        return this.src.get(key);\n    }\n    has(key) {\n        return this.src.has(key);\n    }\n    get size() {\n        return this.src.size;\n    }\n    forEach(callbackfn, thisArg) {\n        this.src.forEach((value, key) => {\n            callbackfn.call(thisArg, value, key, this);\n        });\n    }\n    [Symbol.iterator]() {\n        return this.src[Symbol.iterator]();\n    }\n    entries() {\n        return this.src.entries();\n    }\n    keys() {\n        return this.src.keys();\n    }\n    values() {\n        return this.src.values();\n    }\n    mapVal(v1ToV2, v2ToV1) {\n        return this.map(k => k, k => k, v1ToV2, v2ToV1);\n    }\n    map(k1ToK2, k2ToK1, v1ToV2, v2ToV1) {\n        const resMap = new CustomHashMap();\n        for (const [k, v] of this.entries()) {\n            resMap.set(k1ToK2(k), v1ToV2(v));\n        }\n        const res = RCol.of(resMap);\n        this.forUpdate().add(u => {\n            const k2 = k1ToK2(u.key);\n            const v2 = v1ToV2(u.newValue);\n            res.set(k2, v2);\n        });\n        this.forRemove().add(e => {\n            res.delete(k1ToK2(e.key));\n        });\n        res.forUpdate().add(u => {\n            const k1 = k2ToK1(u.key);\n            const v1 = v2ToV1(u.newValue);\n            this.set(k1, v1);\n        });\n        res.forRemove().add(e => {\n            this.delete(k2ToK1(e.key));\n        });\n        return res;\n    }\n    mapKey(k1ToK2) {\n        const res = RCol.map();\n        this.forRemove().add(e => {\n            const k2 = k1ToK2(e.key, e.value);\n            res.delete(k2);\n        });\n        this.forUpdate().add(e => {\n            if (e.oldValue !== null && e.oldValue !== undefined) {\n                const oldK2 = k1ToK2(e.key, e.oldValue);\n                res.delete(oldK2);\n            }\n            if (e.newValue !== null && e.newValue !== undefined) {\n                const k2 = k1ToK2(e.key, e.newValue);\n                res.set(k2, e.newValue);\n            }\n        });\n        for (const [k, v] of this.entries()) {\n            res.set(k1ToK2(k, v), v);\n        }\n        return res;\n    }\n    link(other) {\n        this.forUpdate().add(e => { if (e.newValue !== null)\n            other.set(e.key, e.newValue); });\n        this.forRemove().add(e => other.delete(e.key));\n        other.forUpdate().add(e => { if (e.newValue !== null)\n            this.set(e.key, e.newValue); });\n        other.forRemove().add(e => this.delete(e.key));\n        for (const [k, v] of other.entries()) {\n            this.set(k, v);\n        }\n        for (const [k, v] of this.entries()) {\n            other.set(k, v);\n        }\n    }\n    mapToFutures() {\n        const map2 = new CustomHashMap();\n        const getOrCreateFuture = (key) => {\n            let future = map2.get(key);\n            if (!future) {\n                future = new aether_future_2.ARFutureWithFlag();\n                map2.set(key, future);\n                future.to((v) => {\n                    if (future.tryRequest()) {\n                        this.set(key, v);\n                    }\n                });\n            }\n            return future;\n        };\n        const rfMap = new RMapBySrc(map2);\n        for (const [key, value] of this.entries()) {\n            if (value !== null) {\n                const f = getOrCreateFuture(key);\n                f.tryDone(value);\n                f.tryRequest();\n            }\n        }\n        this.forUpdate().add(u => {\n            const f = getOrCreateFuture(u.key);\n            f.tryRequest();\n            if (u.newValue !== null) {\n                f.tryDone(u.newValue);\n            }\n            else {\n                f.cancel();\n            }\n        });\n        this.forRemove().add(e => {\n            const f = map2.get(e.key);\n            if (f) {\n                f.cancel();\n                rfMap.delete(e.key);\n            }\n        });\n        rfMap.mapValFuture = RFMapImpl.mapValFuture.bind(rfMap);\n        rfMap.mapKeyFuture = RFMapImpl.mapKeyFuture.bind(rfMap);\n        return rfMap;\n    }\n}\nexports.RMapBySrc = RMapBySrc;\n/**\n * Contains implementations for RFMap default methods.\n */\nvar RFMapImpl;\n(function (RFMapImpl) {\n    /**\n     *  (private) .  .\n     */\n    const _isEqual = (keyA, keyB) => {\n        if (keyA === keyB)\n            return true;\n        if (keyA === null || keyA === undefined)\n            return (keyB === null || keyB === undefined);\n        if (keyB === null || keyB === undefined)\n            return false;\n        if (typeof keyA === 'object' && typeof keyA.equals === 'function') {\n            return keyA.equals(keyB);\n        }\n        return false;\n    };\n    /**\n     * Implementation for RFMap.mapValFuture.\n     */\n    function mapValFuture(vToV2, v2ToV) {\n        const newMap = new CustomHashMap();\n        const res = RCol.of(newMap);\n        const mapFuture = (f) => {\n            return f ? f.map(vToV2).toWithFlag() : null;\n        };\n        const mapBackFuture = (f) => {\n            return f ? f.map(v2ToV).toWithFlag() : null;\n        };\n        for (const [k, f] of this.entries()) {\n            newMap.set(k, mapFuture(f));\n        }\n        this.forUpdate().add(u => {\n            res.set(u.key, mapFuture(u.newValue));\n        });\n        this.forRemove().add(e => {\n            res.delete(e.key);\n        });\n        res.forUpdate().add(u => {\n            this.set(u.key, mapBackFuture(u.newValue));\n        });\n        res.forRemove().add(e => {\n            this.delete(e.key);\n        });\n        res.mapValFuture = RFMapImpl.mapValFuture.bind(res);\n        res.mapKeyFuture = RFMapImpl.mapKeyFuture.bind(res);\n        return res;\n    }\n    RFMapImpl.mapValFuture = mapValFuture;\n    /**\n     * Implementation for RFMap.mapKeyFuture .\n     */\n    function mapKeyFuture(vToK2) {\n        const newMap = new CustomHashMap();\n        const res = RCol.of(newMap);\n        const keyMapping = new CustomHashMap();\n        const processEntry = (key, future) => {\n            if (!future)\n                return;\n            const processValue = (v) => {\n                const newKey = vToK2(v);\n                const oldOriginalKey = keyMapping.get(newKey);\n                // *** :   _isEqual ***\n                if (oldOriginalKey && !_isEqual(oldOriginalKey, key)) {\n                    this.delete(oldOriginalKey);\n                }\n                keyMapping.set(newKey, key);\n                res.set(newKey, future);\n            };\n            if (future.isDone()) {\n                const value = future.getNow();\n                if (value !== null) {\n                    processValue(value);\n                }\n            }\n            else {\n                future.to((v) => {\n                    processValue(v);\n                });\n            }\n        };\n        for (const [k, f] of this.entries()) {\n            processEntry(k, f);\n        }\n        this.forUpdate().add(u => {\n            processEntry(u.key, u.newValue);\n        });\n        this.forRemove().add(e => {\n            let keyToRemove = null;\n            for (const [k2, k] of keyMapping.entries()) {\n                // *** :   _isEqual ***\n                if (_isEqual(k, e.key)) {\n                    keyToRemove = k2;\n                    break;\n                }\n            }\n            if (keyToRemove !== null) {\n                keyMapping.delete(keyToRemove);\n                res.delete(keyToRemove);\n            }\n        });\n        res.mapValFuture = RFMapImpl.mapValFuture.bind(res);\n        res.mapKeyFuture = RFMapImpl.mapKeyFuture.bind(res);\n        return res;\n    }\n    RFMapImpl.mapKeyFuture = mapKeyFuture;\n})(RFMapImpl || (RFMapImpl = {}));\n/**\n * Represents a single network sender/flusher.\n * @template K The key type.\n * @internal\n */\nclass BMapSender {\n    /**\n     * **:**  CustomHashMap  HashSet\n     */\n    requests = new CustomHashMap();\n    constructor(allRequests) {\n        allRequests.forEach((_v, k) => this.requests.set(k, true));\n    }\n    extract() {\n        const r = Array.from(this.requests.keys());\n        this.requests.clear();\n        return r;\n    }\n}\n/**\n * Implementation of the BMap interface.\n * @template K The key type.\n * @template V The value type.\n */\nclass BMapImpl extends RMapBySrc {\n    /**\n     * **:**  CustomHashMap  HashSet\n     */\n    allRequests = new CustomHashMap();\n    valueUpdate = new aether_future_1.EventConsumer();\n    /**\n     * **:**   `Map`.\n     *  -   `ConnectionWork` (sender),  \n     *      (===).\n     */\n    senders = new Map();\n    constructor(_initialCapacity, _name, _timeoutMs) {\n        super(new CustomHashMap());\n    }\n    getOrCreateFuture(key) {\n        let future = this.src.get(key); // `get`  CustomHashMap\n        if (!future) {\n            future = new aether_future_2.ARFutureWithFlag();\n            this.src.set(key, future); // `set`  CustomHashMap\n            future.to((v) => {\n                this.removeRequest(key);\n                this.valueUpdate.fire(new RMapUpdate(key, v, null));\n            });\n            future.onError((_err) => {\n                this.removeRequest(key);\n            });\n            future.onCancel(() => {\n                this.removeRequest(key);\n            });\n            this.addRequest(key);\n        }\n        return future;\n    }\n    removeRequest(key) {\n        // `delete`  CustomHashMap\n        const res = this.allRequests.delete(key);\n        for (const s of this.senders.values()) {\n            s.requests.delete(key);\n        }\n        return res;\n    }\n    addRequest(key) {\n        // `set`  CustomHashMap\n        this.allRequests.set(key, true);\n        for (const s of this.senders.values()) {\n            s.requests.set(key, true);\n        }\n    }\n    getSender(k) {\n        // `get`/`set`  `senders`  ===\n        let sender = this.senders.get(k);\n        if (!sender) {\n            sender = new BMapSender(this.allRequests);\n            this.senders.set(k, sender);\n        }\n        return sender;\n    }\n    getFuture(key) {\n        return this.getOrCreateFuture(key);\n    }\n    getPendingRequests() {\n        return new Set(this.allRequests.keys());\n    }\n    putResolved(key, valueOrUpdater, valueIfUpdater) {\n        if (arguments.length === 2) {\n            const value = valueOrUpdater;\n            this.getOrCreateFuture(key).tryDone(value);\n        }\n        else {\n            const updater = valueOrUpdater;\n            const value = valueIfUpdater;\n            const f = this.getOrCreateFuture(key);\n            if (!f.tryDone(value)) {\n                const v = f.getNow();\n                if (v !== null) {\n                    updater(v);\n                }\n            }\n        }\n    }\n    putError(key, error) {\n        const future = this.getOrCreateFuture(key);\n        future.tryError(error);\n    }\n    forValueUpdate() {\n        return this.valueUpdate;\n    }\n    getRequestsFor(sender) {\n        return this.getSender(sender).extract();\n    }\n    isRequests() {\n        return this.allRequests.size > 0;\n    }\n    isRequestsFor(sender) {\n        //      `this.senders.has(sender)`,\n        // .. sender   ,    .\n        // `getSender`  ,   ,     .requests.size\n        return this.getSender(sender).requests.size > 0;\n    }\n    get(key) {\n        return this.getFuture(key);\n    }\n    set(key, value) {\n        throw new Error(\"Cannot .set() a future directly on BMap. Use putResolved() or putError().\");\n    }\n    delete(key) {\n        this.removeRequest(key);\n        const future = this.src.get(key); // `get`  CustomHashMap\n        if (future) {\n            future.cancel();\n        }\n        return super.delete(key); // `delete`  RMapBySrc\n    }\n    // --- ADDED METHODS TO SATISFY RFMap INTERFACE ---\n    mapValFuture(vToV2, v2ToV) {\n        return RFMapImpl.mapValFuture.bind(this)(vToV2, v2ToV);\n    }\n    mapKeyFuture(vToK2) {\n        return RFMapImpl.mapKeyFuture.bind(this)(vToK2);\n    }\n}\nexports.BMapImpl = BMapImpl;\n/**\n * Base implementation for RCollection.\n * @template T The element type.\n * @template S The underlying storage type.\n */\nclass RCollectionBySrc {\n    src;\n    forAddEvent = new aether_future_1.EventConsumer();\n    forRemoveEvent = new aether_future_1.EventConsumer();\n    constructor(src) {\n        this.src = src;\n    }\n    forAdd() { return this.forAddEvent; }\n    forRemove() { return this.forRemoveEvent; }\n    get size() {\n        if (this.src instanceof CustomHashMap) {\n            return this.src.size;\n        }\n        return this.src.size ?? this.src.length;\n    }\n    isEmpty() {\n        return this.size === 0;\n    }\n    add0(val) {\n        this.forAddEvent.fire(val);\n    }\n    remove0(val) {\n        this.forRemoveEvent.fire(val);\n    }\n    addAll(c) {\n        let modified = false;\n        for (const e of c) {\n            if (this.add(e)) {\n                modified = true;\n            }\n        }\n        return modified;\n    }\n    removeAll(c) {\n        let modified = false;\n        for (const e of c) {\n            if (this.remove(e)) {\n                modified = true;\n            }\n        }\n        return modified;\n    }\n    retainAll(c) {\n        //   Set  retainSet, .. JObj  \n        const retainSet = new Set(c);\n        let modified = false;\n        const toRemove = [];\n        for (const e of this) {\n            if (!retainSet.has(e)) {\n                toRemove.push(e);\n            }\n        }\n        for (const e of toRemove) {\n            if (this.remove(e)) {\n                modified = true;\n            }\n        }\n        return modified;\n    }\n    map(f, f2) {\n        //   Set  mappedSet\n        const mappedSet = new Set();\n        for (const e of this) {\n            mappedSet.add(f(e));\n        }\n        // RCol.of(Set)  RSetBySrc<T2, CustomHashMap<T2, true>>\n        //   T2 extends JObj.\n        //   RCol.queue()\n        const res = RCol.queue();\n        mappedSet.forEach(e => res.add(e));\n        this.forAdd().add(v => res.add(f(v)));\n        this.forRemove().add(v => res.remove(f(v)));\n        res.forAdd().add(v => this.add(f2(v)));\n        res.forRemove().add(v => this.remove(f2(v)));\n        return res;\n    }\n}\nexports.RCollectionBySrc = RCollectionBySrc;\n/**\n * Implementation of RSet wrapping a **CustomHashMap**.\n * @template T The element type.\n */\nclass RSetBySrc extends RCollectionBySrc {\n    [Symbol.toStringTag] = \"RSet\";\n    constructor(src) {\n        super(src);\n    }\n    [Symbol.iterator]() {\n        return this.src.keys();\n    }\n    contains(o) {\n        return this.src.has(o);\n    }\n    add(e) {\n        if (this.src.has(e)) {\n            return false;\n        }\n        this.src.set(e, true);\n        this.add0(e);\n        return true;\n    }\n    remove(o) {\n        const result = this.src.delete(o);\n        if (result) {\n            this.remove0(o);\n        }\n        return result;\n    }\n    clear() {\n        for (const e of this.src.keys()) {\n            this.remove0(e);\n        }\n        this.src.clear();\n    }\n    *entries() {\n        for (const k of this.src.keys()) {\n            yield [k, k];\n        }\n    }\n    keys() {\n        return this.src.keys();\n    }\n    values() {\n        return this.src.keys();\n    }\n    forEach(callbackfn, thisArg) {\n        this.src.forEach((_v, k) => {\n            callbackfn.call(thisArg, k, k, this);\n        });\n    }\n    has(value) {\n        return this.src.has(value);\n    }\n    delete(value) {\n        return this.remove(value);\n    }\n    link(other, f, back) {\n        if (f && back) {\n            const otherRSet = other;\n            this.forAdd().add(v => otherRSet.add(f(v)));\n            this.forRemove().add(v => otherRSet.remove(f(v)));\n            otherRSet.forAdd().add(v => this.add(back(v)));\n            otherRSet.forRemove().add(v => this.remove(back(v)));\n            for (const e of otherRSet) {\n                this.add(back(e));\n            }\n            for (const e of this) {\n                otherRSet.add(f(e));\n            }\n        }\n        else {\n            const otherRSet = other;\n            this.forAdd().add(v => otherRSet.add(v));\n            this.forRemove().add(v => otherRSet.remove(v));\n            otherRSet.forAdd().add(v => this.add(v));\n            otherRSet.forRemove().add(v => this.remove(v));\n            otherRSet.addAll(this);\n            this.addAll(otherRSet);\n        }\n    }\n    map(f, f2) {\n        if (f2) {\n            return super.map(f, f2);\n        }\n        else {\n            const res = RCol.set();\n            this.forAdd().add(v => { res.add(f(v)); });\n            this.forRemove().add(v => { res.remove(f(v)); });\n            for (const e of this) {\n                res.add(f(e));\n            }\n            return res;\n        }\n    }\n}\nexports.RSetBySrc = RSetBySrc;\n/**\n * Implementation of RQueue wrapping a standard Array (as a FIFO queue).\n * @template T The element type.\n */\nclass RQueueBySrc extends RCollectionBySrc {\n    [Symbol.toStringTag] = \"RQueue\";\n    constructor(src) {\n        super(src);\n    }\n    [Symbol.iterator]() {\n        return this.src[Symbol.iterator]();\n    }\n    contains(o) {\n        return this.src.includes(o);\n    }\n    add(e) {\n        this.src.push(e);\n        this.add0(e);\n        return true;\n    }\n    remove(o) {\n        const index = this.src.indexOf(o);\n        if (index > -1) {\n            this.src.splice(index, 1);\n            this.remove0(o);\n            return true;\n        }\n        return false;\n    }\n    clear() {\n        for (const e of this.src) {\n            this.remove0(e);\n        }\n        this.src.length = 0;\n    }\n    offer(e) {\n        return this.add(e);\n    }\n    poll() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const v = this.src.shift(); /** Removes from start */\n        if (v !== undefined) {\n            this.remove0(v);\n            return v;\n        }\n        return null;\n    }\n    element() {\n        if (this.isEmpty()) {\n            throw new Error(\"Queue is empty\");\n        }\n        return this.src[0];\n    }\n    peek() {\n        return this.isEmpty() ? null : this.src[0];\n    }\n}\nexports.RQueueBySrc = RQueueBySrc;\n// =============================================================================================\n// SECTION 7: RCol (Static Factory)\n// =============================================================================================\n/**\n * Factory namespace for creating reactive collections.\n */\nvar RCol;\n(function (RCol) {\n    function of(src) {\n        if (src instanceof Array) {\n            return new RQueueBySrc(src);\n        }\n        if (src instanceof CustomHashMap) {\n            return new RMapBySrc(src);\n        }\n        if (src instanceof Map) {\n            return new RMapBySrc(new CustomHashMap(src.entries()));\n        }\n        if (src instanceof Set) {\n            const customMap = new CustomHashMap();\n            src.forEach(e => customMap.set(e, true));\n            return new RSetBySrc(customMap);\n        }\n        if (typeof src[Symbol.iterator] === 'function') {\n            const customMap = new CustomHashMap();\n            for (const e of src) {\n                customMap.set(e, true);\n            }\n            return new RSetBySrc(customMap);\n        }\n        throw new Error(\"Unsupported source type for RCol.of\");\n    }\n    RCol.of = of;\n    /**\n     * Creates a new, empty, reactive RMap (backed by CustomHashMap).\n     */\n    function map() {\n        return new RMapBySrc(new CustomHashMap());\n    }\n    RCol.map = map;\n    /**\n     * Creates a new, empty, reactive RSet (backed by CustomHashMap).\n     */\n    function set() {\n        return new RSetBySrc(new CustomHashMap());\n    }\n    RCol.set = set;\n    /**\n     * Creates a new, empty, reactive RQueue.\n     */\n    function queue() {\n        return new RQueueBySrc(new Array());\n    }\n    RCol.queue = queue;\n    function bMap(timeoutMs, name) {\n        const finalTimeout = timeoutMs ?? 4000;\n        const finalName = name ?? \"GenericBMap\";\n        return new BMapImpl(10, finalName, finalTimeout);\n    }\n    RCol.bMap = bMap;\n})(RCol || (exports.RCol = RCol = {}));\n//# sourceMappingURL=aether_rcollection.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_rcollection.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_types.js":
/*!**********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/**\n * @file aether.types.ts\n * @purpose Contains core, low-level types and functional interface definitions.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientTimeoutException = exports.ClientApiException = exports.ClientStartException = exports.ConcurrentLinkedQueue_C = exports.AtomicLong = exports.AtomicReference = exports.AtomicInteger = exports.WeakConsumer_T = exports.AConsumer_T = exports.UUID = void 0;\nconst aether_astring_1 = __webpack_require__(/*! ./aether_astring */ \"./node_modules/aether-client/build/aether_astring.js\");\n/**\n * A basic UUID implementation.\n */\n// ,   ToString   AString\n// (  )  -   .\n// interface ToString { ... }\n// declare class AString { ... }\nclass UUID {\n    static fromString(uuidString) {\n        const uuidRegex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i;\n        const match = uuidRegex.exec(uuidString);\n        if (!match) {\n            throw new Error(`Invalid UUID string format: ${uuidString}`);\n        }\n        const hex = match.slice(1).join(''); // match[1]...match[5]\n        const data = new Uint8Array(16);\n        for (let i = 0; i < 16; i++) {\n            data[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);\n        }\n        const uuid = new UUID();\n        uuid.data = data;\n        return uuid;\n    }\n    data;\n    toString(s) {\n        if (!s)\n            s = aether_astring_1.AString.of(); // ,  AString.of() \n        if (!this.data || this.data.length !== 16) {\n            throw new Error('UUID data is missing or incorrect size.');\n        }\n        let hexParts = [];\n        for (let i = 0; i < 16; i++) {\n            hexParts.push(this.data[i].toString(16).padStart(2, '0'));\n        }\n        s.add([\n            hexParts.slice(0, 4).join(''),\n            hexParts.slice(4, 6).join(''),\n            hexParts.slice(6, 8).join(''),\n            hexParts.slice(8, 10).join(''),\n            hexParts.slice(10, 16).join(''),\n        ].join('-'));\n        return s;\n    }\n    /**\n     * ,    UUID  .\n     *  UUID ,   16    .\n     * @param other    .\n     * @returns true,   ,  false.\n     */\n    equals(other) {\n        if (this === other) {\n            return true; //    \n        }\n        // ,  other   UUID     \n        if (!(other instanceof UUID) || !other.data) {\n            return false;\n        }\n        //       \n        if (!this.data) {\n            return false;\n        }\n        // UUID     (16 )\n        if (this.data.length !== other.data.length) {\n            return false;\n        }\n        //  \n        for (let i = 0; i < this.data.length; i++) {\n            if (this.data[i] !== other.data[i]) {\n                return false; //  \n            }\n        }\n        return true; //   \n    }\n    /**\n     *  32- -   UUID.\n     * *       128-\n     * : 16     32-\n     * ,     XOR.\n     * * @returns 32-  (-).\n     */\n    hashCode() {\n        if (!this.data || this.data.length !== 16) {\n            return 0; // -     UUID\n        }\n        //  DataView    32- \n        //  16-  Uint8Array\n        const view = new DataView(this.data.buffer, this.data.byteOffset, this.data.byteLength);\n        //  4   32  (4 ).\n        // false  big-endian (  ),\n        //       UUID.\n        const int1 = view.getInt32(0, false);\n        const int2 = view.getInt32(4, false);\n        const int3 = view.getInt32(8, false);\n        const int4 = view.getInt32(12, false);\n        //     XOR,   32- \n        const hash = int1 ^ int2 ^ int3 ^ int4;\n        // | 0 ,    32-\n        //   ,     Java/C#.\n        return hash | 0;\n    }\n}\nexports.UUID = UUID;\n/**\n * A namespace for AConsumer utilities, mirroring Java's AConsumer interface statics.\n */\nvar AConsumer_T;\n(function (AConsumer_T) {\n    /**\n     * A consumer that does nothing.\n     */\n    AConsumer_T.EMPTY = () => { };\n    /**\n     * Returns a typed empty consumer.\n     * @template E The type.\n     * @returns An empty consumer.\n     */\n    function stub() {\n        return AConsumer_T.EMPTY;\n    }\n    AConsumer_T.stub = stub;\n})(AConsumer_T || (exports.AConsumer_T = AConsumer_T = {}));\n/**\n * A type guard and helper namespace for Weak Consumers.\n * This creates a function that acts as an AConsumer but holds a WeakRef\n * to the original task, allowing it to be garbage collected.\n */\nvar WeakConsumer_T;\n(function (WeakConsumer_T) {\n    /**\n     * Type guard to check if a consumer is a weak consumer.\n     * @param c The consumer to check.\n     * @returns True if it is a WeakConsumer.\n     */\n    function isWeakConsumer(c) {\n        return c?._isWeak === true;\n    }\n    /**\n     * Creates a new weak consumer function.\n     * @param task The original AConsumer to wrap.\n     * @returns A new AConsumer function that holds a WeakRef to the task.\n     */\n    function create(task) {\n        const ref = new WeakRef(task);\n        /**\n         * This is the callable function that will be stored in the listener set.\n         */\n        const weakConsumerFunc = (t) => {\n            ref.deref()?.(t);\n        };\n        /**\n         * Tag the function with properties needed by EventConsumer.\n         */\n        weakConsumerFunc._isWeak = true;\n        weakConsumerFunc._weakOriginalTask = task;\n        weakConsumerFunc._weakRef = ref;\n        return weakConsumerFunc;\n    }\n    WeakConsumer_T.create = create;\n    /**\n     * Checks if a consumer is a weak consumer and its reference is dead.\n     * @param c The consumer to check.\n     * @returns True if the consumer is weak and its target has been garbage collected.\n     */\n    function isGarbageCollected(c) {\n        if (isWeakConsumer(c)) {\n            return c._weakRef.deref() === undefined;\n        }\n        return false;\n    }\n    WeakConsumer_T.isGarbageCollected = isGarbageCollected;\n})(WeakConsumer_T || (exports.WeakConsumer_T = WeakConsumer_T = {}));\n/** Atomic Types (Simple JS Implementation) */\nclass AtomicInteger {\n    value;\n    constructor(initial) { this.value = initial; }\n    incrementAndGet() { return ++this.value; }\n    decrementAndGet() { return --this.value; }\n    addAndGet(delta) { this.value += delta; return this.value; }\n    get() { return this.value; }\n    set(v) { this.value = v; }\n    compareAndSet(expect, update) {\n        if (this.value === expect) {\n            this.value = update;\n            return true;\n        }\n        return false;\n    }\n}\nexports.AtomicInteger = AtomicInteger;\nclass AtomicReference {\n    value;\n    constructor(initial) { this.value = initial; }\n    get() { return this.value; }\n    set(v) { this.value = v; }\n    compareAndSet(expect, update) {\n        if (this.value === expect) {\n            this.value = update;\n            return true;\n        }\n        return false;\n    }\n}\nexports.AtomicReference = AtomicReference;\nclass AtomicLong {\n    value;\n    constructor(initial) { this.value = initial; }\n    get() { return this.value; }\n    set(v) { this.value = v; }\n    compareAndSet(expect, update) {\n        if (this.value === expect) {\n            this.value = update;\n            return true;\n        }\n        return false;\n    }\n    addAndGet(delta) {\n        this.value += delta;\n        return this.value;\n    }\n}\nexports.AtomicLong = AtomicLong;\n/** Concurrency Stubs (Simple JS Implementation) */\nclass ConcurrentLinkedQueue_C {\n    items = [];\n    add(item) { this.items.push(item); }\n    poll() { return this.items.shift(); }\n    isEmpty() { return this.items.length === 0; }\n    clear() { this.items = []; }\n    get length() { return this.items.length; }\n}\nexports.ConcurrentLinkedQueue_C = ConcurrentLinkedQueue_C;\n/** Exception related to client startup and connection issues. */\nclass ClientStartException extends Error {\n    constructor(message, cause) {\n        super(message);\n        if (cause)\n            this.cause = cause;\n        this.name = 'ClientStartException';\n    }\n}\nexports.ClientStartException = ClientStartException;\n/** Exception related to errors occurring during API requests. */\nclass ClientApiException extends Error {\n    constructor(message, cause) {\n        super(message);\n        if (cause)\n            this.cause = cause;\n        this.name = 'ClientApiException';\n    }\n}\nexports.ClientApiException = ClientApiException;\n/** Exception related to internal asynchronous operation timeouts. */\nclass ClientTimeoutException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'ClientTimeoutException';\n    }\n}\nexports.ClientTimeoutException = ClientTimeoutException;\n//# sourceMappingURL=aether_types.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_types.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/aether-client/build/aether_utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n// =============================================================================================\n// FILE: aether.utils.ts\n// PURPOSE: Contains low-level utilities, HexUtils, Destroyer, and RU (Runtime Utilities).\n// DEPENDENCIES: aether.types.ts, aether.future.ts, aether.logging.ts\n// =============================================================================================\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Queue = exports.DataUtils = exports.Objects = exports.Arrays = exports.StandardUUIDs = exports.RU = exports.Destroyer = exports.HexUtils = void 0;\nconst aether_types_1 = __webpack_require__(/*! ./aether_types */ \"./node_modules/aether-client/build/aether_types.js\");\nconst aether_logging_1 = __webpack_require__(/*! ./aether_logging */ \"./node_modules/aether-client/build/aether_logging.js\");\nconst aether_future_1 = __webpack_require__(/*! ./aether_future */ \"./node_modules/aether-client/build/aether_future.js\");\n// --- HexUtils ---\nexports.HexUtils = {\n    HEX_ARRAY: \"0123456789ABCDEF\".split(''),\n    HEX_MAP: \"0123456789ABCDEF\".split('').reduce((acc, char, index) => ({ ...acc, [char]: index }), {}),\n    hexToBytes(s) {\n        const charSequence = s;\n        if (!s || s.length % 2 !== 0)\n            throw new Error(`Invalid hex string (null, empty, or odd length): \"${s}\"`);\n        const byteArray = new Uint8Array(charSequence.length / 2);\n        for (let i = 0; i < charSequence.length; i = i + 2) {\n            const c1 = exports.HexUtils.HEX_MAP[charSequence[i].toUpperCase()];\n            const c2 = exports.HexUtils.HEX_MAP[charSequence[i + 1].toUpperCase()];\n            if (c1 === undefined || c2 === undefined)\n                throw new Error(`Invalid hex character: ${charSequence.substring(i, i + 2)}`);\n            byteArray[i / 2] = ((c1 << 4) | c2);\n        }\n        return byteArray;\n    },\n    toHexString(bytes, offset, endIndex, result) {\n        if (!bytes) {\n            if (result) {\n                result.addNull();\n                return;\n            }\n            else {\n                return \"null\";\n            }\n        }\n        const dataBytes = bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes);\n        const start = offset === undefined ? 0 : offset;\n        const end = endIndex === undefined ? dataBytes.length : endIndex;\n        if (result) {\n            for (let i = start; i < end; i++) {\n                const v = dataBytes[i] & 0xFF;\n                result.add(exports.HexUtils.HEX_ARRAY[v >>> 4]);\n                result.add(exports.HexUtils.HEX_ARRAY[v & 0x0F]);\n            }\n            return;\n        }\n        else {\n            let res = [];\n            for (let i = start; i < end; i++) {\n                const v = dataBytes[i] & 0xFF;\n                res.push(exports.HexUtils.HEX_ARRAY[v >>> 4]);\n                res.push(exports.HexUtils.HEX_ARRAY[v & 0x0F]);\n            }\n            return res.join('');\n        }\n    }\n};\n// =============================================================================================\n// DESTROYER\n// =============================================================================================\n// <-- Destroyable  Disposable,  Destroyer  \nclass Destroyer {\n    name;\n    // <--     ,  Disposable  \n    queue = new aether_types_1.ConcurrentLinkedQueue_C();\n    destroyFuture = new aether_types_1.AtomicReference(null);\n    constructor(name) { this.name = name; }\n    isDestroyed() { return this.destroyFuture.get() !== null; }\n    // <--   Disposable    Destroyable\n    add(resource) {\n        // :    Destroyable, ..  T  Disposable\n        if (typeof resource.destroy === 'function') {\n            this.queue.add(resource);\n        }\n        else if (typeof resource[Symbol.dispose] === 'function') {\n            this.queue.add(resource);\n        }\n        else {\n            aether_logging_1.Log.error(\"Attempted to add non-Disposable/Destroyable to Destroyer\", { object: resource });\n        }\n    }\n    destroy(force) {\n        const res = aether_future_1.AFuture.make();\n        if (!this.destroyFuture.compareAndSet(null, res)) {\n            return this.destroyFuture.get();\n        }\n        const destroyTasks = [];\n        let e;\n        while ((e = this.queue.poll()) !== undefined) {\n            try {\n                // :     'destroy'\n                if (typeof e.destroy === 'function') {\n                    destroyTasks.push(e.destroy(force).timeoutError(5, `Timeout destroying unit: ${e.toString()}`));\n                }\n                //    'dispose'\n                else if (typeof e[Symbol.dispose] === 'function') {\n                    e[Symbol.dispose]();\n                }\n                else {\n                    aether_logging_1.Log.warn(\"Object in Destroyer queue has no destroy or dispose method\", { object: e });\n                }\n            }\n            catch (err) {\n                aether_logging_1.Log.error(\"Error during destroy/dispose call\", { error: err, object: e });\n            }\n        }\n        const allDestroy = aether_future_1.AFuture.all(...destroyTasks);\n        allDestroy.to(() => { if (res.tryDone()) { /* done */ } })\n            .onError(e => res.error(e));\n        res.timeoutError(5, `Timeout destroying all units in Destroyer[${this.name}]`);\n        return res;\n    }\n    // <--  [Symbol.dispose]   Destroyer\n    [Symbol.dispose]() {\n        this.destroy(true); // 'true'  force, .. 'using'  \n    }\n}\nexports.Destroyer = Destroyer;\n// =============================================================================================\n// RU - Runtime Utilities\n// =============================================================================================\nexports.RU = {\n    AtomicLong: aether_types_1.AtomicLong,\n    AtomicReference: aether_types_1.AtomicReference,\n    ConcurrentHashMap: Map,\n    ConcurrentLinkedQueue: aether_types_1.ConcurrentLinkedQueue_C,\n    ConcurrentHashSet: Set,\n    time: () => Date.now(),\n    schedule: (ms, task) => {\n        const timer = setTimeout(aether_logging_1.Log.wrap(task), ms);\n        return { [Symbol.dispose]: () => clearTimeout(timer) };\n    },\n    // <--     Destroyable\n    scheduleAtFixedRate: (resTo, period, timeUnit, t) => {\n        const periodMs = period * (timeUnit === \"SECONDS\" ? 1000 : 1);\n        const wrappedTask = aether_logging_1.Log.wrap(t);\n        const timer = setInterval(wrappedTask, periodMs);\n        //     \n        const destroyableTimer = {\n            //  destroy\n            destroy: (_f) => {\n                clearInterval(timer);\n                return aether_future_1.AFuture.of();\n            },\n            //  dispose\n            [Symbol.dispose]: () => {\n                clearInterval(timer);\n            }\n        };\n        if (resTo && typeof resTo.add === 'function') {\n            resTo.add(destroyableTimer);\n        }\n        else {\n            aether_logging_1.Log.warn(\"scheduleAtFixedRate: Provided 'resTo' is not a Destroyer. Timer will not be automatically cleaned up.\");\n        }\n        return destroyableTimer;\n    },\n    cast: (t) => t,\n    error: (e) => { aether_logging_1.Log.error(e); throw e; },\n    readAll: (q, o) => {\n        let element;\n        while ((element = q.poll()) !== undefined) {\n            try {\n                o(element);\n            }\n            catch (err) {\n                aether_logging_1.Log.error(\"Error processing item in readAll\", { error: err, item: element });\n            }\n        }\n    },\n};\n// =============================================================================================\n// Standard UUIDs\n// =============================================================================================\nexports.StandardUUIDs = {\n    ROOT_UID: aether_types_1.UUID.fromString(\"ed307ca7-8369-4342-91ee-60c8fc6f9b6b\"),\n    TEST_UID: aether_types_1.UUID.fromString(\"3ac93165-3d37-4970-87a6-fa4ee27744e4\"),\n    ANONYMOUS_UID: aether_types_1.UUID.fromString(\"237e2dc0-21a4-4e83-8184-c43052f93b79\"),\n};\n// ---     ---\nexports.Arrays = {\n    equals: (a, b) => {\n        if (a === b)\n            return true;\n        if (!a || !b)\n            return false;\n        if (a.length !== b.length)\n            return false;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i])\n                return false;\n        }\n        return true;\n    },\n    hashCode: (a) => {\n        if (!a)\n            return 0;\n        let hash = 1;\n        for (let i = 0; i < a.length; i++) {\n            hash = (31 * hash + a[i]) | 0; // | 0 to force 32-bit int\n        }\n        return hash;\n    }\n};\nexports.Objects = {\n    hash: (...values) => {\n        let result = 1;\n        for (const val of values) {\n            let hash;\n            if (val === null || val === undefined) {\n                hash = 0;\n            }\n            else if (typeof val.hashCode === 'function') {\n                hash = val.hashCode();\n            }\n            else if (val instanceof Uint8Array) {\n                hash = exports.Arrays.hashCode(val);\n            }\n            else if (typeof val === 'string') {\n                //    \n                hash = 0;\n                for (let i = 0; i < val.length; i++) {\n                    hash = (31 * hash + val.charCodeAt(i)) | 0;\n                }\n            }\n            else if (typeof val === 'number') {\n                hash = val | 0;\n            }\n            else if (typeof val === 'boolean') {\n                hash = val ? 1231 : 1237;\n            }\n            else {\n                // Fallback\n                hash = 0;\n                const s = String(val);\n                for (let i = 0; i < s.length; i++) {\n                    hash = (31 * hash + s.charCodeAt(i)) | 0;\n                }\n            }\n            result = (31 * result + (hash | 0)) | 0;\n        }\n        return result;\n    }\n};\nexports.DataUtils = {\n    writeLongLE: (arr, offset, value) => {\n        const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n        let valueAsBigInt;\n        if (typeof value === 'bigint') {\n            valueAsBigInt = value;\n        }\n        else {\n            valueAsBigInt = BigInt(Math.trunc(value));\n        }\n        if (typeof view.setBigUint64 === 'function') {\n            view.setBigUint64(offset, valueAsBigInt, true); // true = Little-Endian\n        }\n        else {\n            const high = Number(BigInt.asUintN(32, valueAsBigInt >> 32n));\n            const low = Number(BigInt.asUintN(32, valueAsBigInt));\n            view.setUint32(offset, low, true);\n            view.setUint32(offset + 4, high, true);\n        }\n    }\n};\n/**\n *   (FIFO)  TypeScript,  API java.util.Queue.\n *     (unbounded).\n */\nclass Queue {\n    //       .\n    //  (enqueue)     (push).\n    //  (dequeue)     (shift).\n    storage = [];\n    /**\n     *   .\n     * @param initialData     .\n     */\n    constructor(initialData = []) {\n        this.storage = [...initialData];\n    }\n    // ---   ---\n    /**\n     *     .\n     *    ,    true.\n     *   Java:  ,    .\n     * @param element   .\n     * @returns true\n     */\n    add(element) {\n        const success = this.offer(element);\n        if (!success) {\n            //      ,    Java\n            throw new Error(\"Queue full\");\n        }\n        return true;\n    }\n    /**\n     *     .\n     *    ,    true.\n     * @param element   .\n     * @returns true\n     */\n    offer(element) {\n        this.storage.push(element);\n        return true;\n    }\n    // ---   ---\n    /**\n     *       .\n     *   \"NoSuchElementException\",   .\n     * @returns    .\n     */\n    remove() {\n        const item = this.storage.shift();\n        if (item === undefined) {\n            throw new Error(\"NoSuchElementException: Queue is empty\");\n        }\n        return item;\n    }\n    /**\n     *       .\n     *  null,   .\n     * @returns      null.\n     */\n    poll() {\n        const item = this.storage.shift();\n        //  '??'   ,  item 'undefined'\n        return item ?? null;\n    }\n    // ---   ---\n    /**\n     * ,   ,    .\n     *   \"NoSuchElementException\",   .\n     * @returns    .\n     */\n    element() {\n        const item = this.storage[0];\n        if (item === undefined) {\n            throw new Error(\"NoSuchElementException: Queue is empty\");\n        }\n        return item;\n    }\n    /**\n     * ,   ,    .\n     *  null,   .\n     * @returns      null.\n     */\n    peek() {\n        const item = this.storage[0];\n        return item ?? null;\n    }\n    // ---   ---\n    /**\n     *    .\n     * @returns number\n     */\n    size() {\n        return this.storage.length;\n    }\n    /**\n     * ,   .\n     * @returns true,   ,  false.\n     */\n    isEmpty() {\n        return this.storage.length === 0;\n    }\n    /**\n     *     .\n     */\n    clear() {\n        this.storage = [];\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=aether_utils.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_utils.js?\n}");

/***/ }),

/***/ "./node_modules/aether-client/build/aether_work_proof.js":
/*!***************************************************************!*\
  !*** ./node_modules/aether-client/build/aether_work_proof.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WorkProofUtil = void 0;\nconst bcrypt = __importStar(__webpack_require__(/*! bcryptjs */ \"./node_modules/bcryptjs/umd/index.js\"));\nconst crc32 = __importStar(__webpack_require__(/*! crc-32 */ \"./node_modules/crc-32/crc32.js\"));\nconst aether_utils_1 = __webpack_require__(/*! ./aether_utils */ \"./node_modules/aether-client/build/aether_utils.js\");\nvar WorkProofUtil;\n(function (WorkProofUtil) {\n    function checkProofOfWorkHash(salt, password, max_hash_val) {\n        const hash = bcrypt.hashSync(password, salt);\n        const hashBytes = new Uint8Array(hash.length);\n        for (let i = 0; i < hash.length; i++) {\n            hashBytes[i] = hash.charCodeAt(i) & 0xFF;\n        }\n        const crc = crc32.buf(hashBytes);\n        return Math.abs(crc) <= max_hash_val;\n    }\n    function generateProofOfWorkPool(salt, suffix, max_hash_val, poolSize, timeout) {\n        const result = new Array(poolSize);\n        const startTime = aether_utils_1.RU.time();\n        let prefix = 0;\n        for (let e = 0; e < poolSize; e++) {\n            while (true) {\n                if (aether_utils_1.RU.time() - startTime > timeout) {\n                    throw new Error(`TimeoutException: PoW calculation exceeded ${timeout}ms`);\n                }\n                const prefixHex = prefix.toString(16).padStart(8, '0');\n                const password = prefixHex + suffix;\n                if (checkProofOfWorkHash(salt, password, max_hash_val)) {\n                    result[e] = prefix++;\n                    break;\n                }\n                prefix++;\n            }\n        }\n        return result;\n    }\n    WorkProofUtil.generateProofOfWorkPool = generateProofOfWorkPool;\n    function checkProofOfWorkHashList(salt, suffix, passwords, max_hash_val) {\n        for (const p of passwords) {\n            const prefixHex = p.toString(16).padStart(8, '0');\n            const password = prefixHex + suffix;\n            if (!checkProofOfWorkHash(salt, password, max_hash_val)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    WorkProofUtil.checkProofOfWorkHashList = checkProofOfWorkHashList;\n})(WorkProofUtil || (exports.WorkProofUtil = WorkProofUtil = {}));\n//# sourceMappingURL=aether_work_proof.js.map\n\n//# sourceURL=webpack://gui/./node_modules/aether-client/build/aether_work_proof.js?\n}");

/***/ }),

/***/ "./node_modules/bcryptjs/umd/index.js":
/*!********************************************!*\
  !*** ./node_modules/bcryptjs/umd/index.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\n(function (global, factory) {\n  function preferDefault(exports) {\n    return exports.default || exports;\n  }\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! crypto */ \"?7243\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (_crypto) {\n      var exports = {};\n      factory(exports, _crypto);\n      return preferDefault(exports);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else // removed by dead control flow\n{}\n})(\n  typeof globalThis !== \"undefined\"\n    ? globalThis\n    : typeof self !== \"undefined\"\n      ? self\n      : this,\n  function (_exports, _crypto) {\n    \"use strict\";\n\n    Object.defineProperty(_exports, \"__esModule\", {\n      value: true,\n    });\n    _exports.compare = compare;\n    _exports.compareSync = compareSync;\n    _exports.decodeBase64 = decodeBase64;\n    _exports.default = void 0;\n    _exports.encodeBase64 = encodeBase64;\n    _exports.genSalt = genSalt;\n    _exports.genSaltSync = genSaltSync;\n    _exports.getRounds = getRounds;\n    _exports.getSalt = getSalt;\n    _exports.hash = hash;\n    _exports.hashSync = hashSync;\n    _exports.setRandomFallback = setRandomFallback;\n    _exports.truncates = truncates;\n    _crypto = _interopRequireDefault(_crypto);\n    function _interopRequireDefault(e) {\n      return e && e.__esModule ? e : { default: e };\n    }\n    /*\n   Copyright (c) 2012 Nevins Bartolomeo <nevins.bartolomeo@gmail.com>\n   Copyright (c) 2012 Shane Girish <shaneGirish@gmail.com>\n   Copyright (c) 2025 Daniel Wirtz <dcode@dcode.io>\n  \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n   1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n   2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n   3. The name of the author may not be used to endorse or promote products\n   derived from this software without specific prior written permission.\n  \n   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   */\n\n    // The Node.js crypto module is used as a fallback for the Web Crypto API. When\n    // building for the browser, inclusion of the crypto module should be disabled,\n    // which the package hints at in its package.json for bundlers that support it.\n\n    /**\n     * The random implementation to use as a fallback.\n     * @type {?function(number):!Array.<number>}\n     * @inner\n     */\n    var randomFallback = null;\n\n    /**\n     * Generates cryptographically secure random bytes.\n     * @function\n     * @param {number} len Bytes length\n     * @returns {!Array.<number>} Random bytes\n     * @throws {Error} If no random implementation is available\n     * @inner\n     */\n    function randomBytes(len) {\n      // Web Crypto API. Globally available in the browser and in Node.js >=23.\n      try {\n        return crypto.getRandomValues(new Uint8Array(len));\n      } catch {}\n      // Node.js crypto module for non-browser environments.\n      try {\n        return _crypto.default.randomBytes(len);\n      } catch {}\n      // Custom fallback specified with `setRandomFallback`.\n      if (!randomFallback) {\n        throw Error(\n          \"Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative\",\n        );\n      }\n      return randomFallback(len);\n    }\n\n    /**\n     * Sets the pseudo random number generator to use as a fallback if neither node's `crypto` module nor the Web Crypto\n     *  API is available. Please note: It is highly important that the PRNG used is cryptographically secure and that it\n     *  is seeded properly!\n     * @param {?function(number):!Array.<number>} random Function taking the number of bytes to generate as its\n     *  sole argument, returning the corresponding array of cryptographically secure random byte values.\n     * @see http://nodejs.org/api/crypto.html\n     * @see http://www.w3.org/TR/WebCryptoAPI/\n     */\n    function setRandomFallback(random) {\n      randomFallback = random;\n    }\n\n    /**\n     * Synchronously generates a salt.\n     * @param {number=} rounds Number of rounds to use, defaults to 10 if omitted\n     * @param {number=} seed_length Not supported.\n     * @returns {string} Resulting salt\n     * @throws {Error} If a random fallback is required but not set\n     */\n    function genSaltSync(rounds, seed_length) {\n      rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;\n      if (typeof rounds !== \"number\")\n        throw Error(\n          \"Illegal arguments: \" + typeof rounds + \", \" + typeof seed_length,\n        );\n      if (rounds < 4) rounds = 4;\n      else if (rounds > 31) rounds = 31;\n      var salt = [];\n      salt.push(\"$2b$\");\n      if (rounds < 10) salt.push(\"0\");\n      salt.push(rounds.toString());\n      salt.push(\"$\");\n      salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN)); // May throw\n      return salt.join(\"\");\n    }\n\n    /**\n     * Asynchronously generates a salt.\n     * @param {(number|function(Error, string=))=} rounds Number of rounds to use, defaults to 10 if omitted\n     * @param {(number|function(Error, string=))=} seed_length Not supported.\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting salt\n     * @returns {!Promise} If `callback` has been omitted\n     * @throws {Error} If `callback` is present but not a function\n     */\n    function genSalt(rounds, seed_length, callback) {\n      if (typeof seed_length === \"function\")\n        (callback = seed_length), (seed_length = undefined); // Not supported.\n      if (typeof rounds === \"function\")\n        (callback = rounds), (rounds = undefined);\n      if (typeof rounds === \"undefined\") rounds = GENSALT_DEFAULT_LOG2_ROUNDS;\n      else if (typeof rounds !== \"number\")\n        throw Error(\"illegal arguments: \" + typeof rounds);\n      function _async(callback) {\n        nextTick(function () {\n          // Pretty thin, but salting is fast enough\n          try {\n            callback(null, genSaltSync(rounds));\n          } catch (err) {\n            callback(err);\n          }\n        });\n      }\n      if (callback) {\n        if (typeof callback !== \"function\")\n          throw Error(\"Illegal callback: \" + typeof callback);\n        _async(callback);\n      } else\n        return new Promise(function (resolve, reject) {\n          _async(function (err, res) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(res);\n          });\n        });\n    }\n\n    /**\n     * Synchronously generates a hash for the given password.\n     * @param {string} password Password to hash\n     * @param {(number|string)=} salt Salt length to generate or salt to use, default to 10\n     * @returns {string} Resulting hash\n     */\n    function hashSync(password, salt) {\n      if (typeof salt === \"undefined\") salt = GENSALT_DEFAULT_LOG2_ROUNDS;\n      if (typeof salt === \"number\") salt = genSaltSync(salt);\n      if (typeof password !== \"string\" || typeof salt !== \"string\")\n        throw Error(\n          \"Illegal arguments: \" + typeof password + \", \" + typeof salt,\n        );\n      return _hash(password, salt);\n    }\n\n    /**\n     * Asynchronously generates a hash for the given password.\n     * @param {string} password Password to hash\n     * @param {number|string} salt Salt length to generate or salt to use\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash\n     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\n     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\n     * @returns {!Promise} If `callback` has been omitted\n     * @throws {Error} If `callback` is present but not a function\n     */\n    function hash(password, salt, callback, progressCallback) {\n      function _async(callback) {\n        if (typeof password === \"string\" && typeof salt === \"number\")\n          genSalt(salt, function (err, salt) {\n            _hash(password, salt, callback, progressCallback);\n          });\n        else if (typeof password === \"string\" && typeof salt === \"string\")\n          _hash(password, salt, callback, progressCallback);\n        else\n          nextTick(\n            callback.bind(\n              this,\n              Error(\n                \"Illegal arguments: \" + typeof password + \", \" + typeof salt,\n              ),\n            ),\n          );\n      }\n      if (callback) {\n        if (typeof callback !== \"function\")\n          throw Error(\"Illegal callback: \" + typeof callback);\n        _async(callback);\n      } else\n        return new Promise(function (resolve, reject) {\n          _async(function (err, res) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(res);\n          });\n        });\n    }\n\n    /**\n     * Compares two strings of the same length in constant time.\n     * @param {string} known Must be of the correct length\n     * @param {string} unknown Must be the same length as `known`\n     * @returns {boolean}\n     * @inner\n     */\n    function safeStringCompare(known, unknown) {\n      var diff = known.length ^ unknown.length;\n      for (var i = 0; i < known.length; ++i) {\n        diff |= known.charCodeAt(i) ^ unknown.charCodeAt(i);\n      }\n      return diff === 0;\n    }\n\n    /**\n     * Synchronously tests a password against a hash.\n     * @param {string} password Password to compare\n     * @param {string} hash Hash to test against\n     * @returns {boolean} true if matching, otherwise false\n     * @throws {Error} If an argument is illegal\n     */\n    function compareSync(password, hash) {\n      if (typeof password !== \"string\" || typeof hash !== \"string\")\n        throw Error(\n          \"Illegal arguments: \" + typeof password + \", \" + typeof hash,\n        );\n      if (hash.length !== 60) return false;\n      return safeStringCompare(\n        hashSync(password, hash.substring(0, hash.length - 31)),\n        hash,\n      );\n    }\n\n    /**\n     * Asynchronously tests a password against a hash.\n     * @param {string} password Password to compare\n     * @param {string} hashValue Hash to test against\n     * @param {function(Error, boolean)=} callback Callback receiving the error, if any, otherwise the result\n     * @param {function(number)=} progressCallback Callback successively called with the percentage of rounds completed\n     *  (0.0 - 1.0), maximally once per `MAX_EXECUTION_TIME = 100` ms.\n     * @returns {!Promise} If `callback` has been omitted\n     * @throws {Error} If `callback` is present but not a function\n     */\n    function compare(password, hashValue, callback, progressCallback) {\n      function _async(callback) {\n        if (typeof password !== \"string\" || typeof hashValue !== \"string\") {\n          nextTick(\n            callback.bind(\n              this,\n              Error(\n                \"Illegal arguments: \" +\n                  typeof password +\n                  \", \" +\n                  typeof hashValue,\n              ),\n            ),\n          );\n          return;\n        }\n        if (hashValue.length !== 60) {\n          nextTick(callback.bind(this, null, false));\n          return;\n        }\n        hash(\n          password,\n          hashValue.substring(0, 29),\n          function (err, comp) {\n            if (err) callback(err);\n            else callback(null, safeStringCompare(comp, hashValue));\n          },\n          progressCallback,\n        );\n      }\n      if (callback) {\n        if (typeof callback !== \"function\")\n          throw Error(\"Illegal callback: \" + typeof callback);\n        _async(callback);\n      } else\n        return new Promise(function (resolve, reject) {\n          _async(function (err, res) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(res);\n          });\n        });\n    }\n\n    /**\n     * Gets the number of rounds used to encrypt the specified hash.\n     * @param {string} hash Hash to extract the used number of rounds from\n     * @returns {number} Number of rounds used\n     * @throws {Error} If `hash` is not a string\n     */\n    function getRounds(hash) {\n      if (typeof hash !== \"string\")\n        throw Error(\"Illegal arguments: \" + typeof hash);\n      return parseInt(hash.split(\"$\")[2], 10);\n    }\n\n    /**\n     * Gets the salt portion from a hash. Does not validate the hash.\n     * @param {string} hash Hash to extract the salt from\n     * @returns {string} Extracted salt part\n     * @throws {Error} If `hash` is not a string or otherwise invalid\n     */\n    function getSalt(hash) {\n      if (typeof hash !== \"string\")\n        throw Error(\"Illegal arguments: \" + typeof hash);\n      if (hash.length !== 60)\n        throw Error(\"Illegal hash length: \" + hash.length + \" != 60\");\n      return hash.substring(0, 29);\n    }\n\n    /**\n     * Tests if a password will be truncated when hashed, that is its length is\n     * greater than 72 bytes when converted to UTF-8.\n     * @param {string} password The password to test\n     * @returns {boolean} `true` if truncated, otherwise `false`\n     */\n    function truncates(password) {\n      if (typeof password !== \"string\")\n        throw Error(\"Illegal arguments: \" + typeof password);\n      return utf8Length(password) > 72;\n    }\n\n    /**\n     * Continues with the callback after yielding to the event loop.\n     * @function\n     * @param {function(...[*])} callback Callback to execute\n     * @inner\n     */\n    var nextTick =\n      typeof setImmediate === \"function\"\n        ? setImmediate\n        : typeof scheduler === \"object\" &&\n            typeof scheduler.postTask === \"function\"\n          ? scheduler.postTask.bind(scheduler)\n          : setTimeout;\n\n    /** Calculates the byte length of a string encoded as UTF8. */\n    function utf8Length(string) {\n      var len = 0,\n        c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128) len += 1;\n        else if (c < 2048) len += 2;\n        else if (\n          (c & 0xfc00) === 0xd800 &&\n          (string.charCodeAt(i + 1) & 0xfc00) === 0xdc00\n        ) {\n          ++i;\n          len += 4;\n        } else len += 3;\n      }\n      return len;\n    }\n\n    /** Converts a string to an array of UTF8 bytes. */\n    function utf8Array(string) {\n      var offset = 0,\n        c1,\n        c2;\n      var buffer = new Array(utf8Length(string));\n      for (var i = 0, k = string.length; i < k; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = (c1 >> 6) | 192;\n          buffer[offset++] = (c1 & 63) | 128;\n        } else if (\n          (c1 & 0xfc00) === 0xd800 &&\n          ((c2 = string.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n        ) {\n          c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n          ++i;\n          buffer[offset++] = (c1 >> 18) | 240;\n          buffer[offset++] = ((c1 >> 12) & 63) | 128;\n          buffer[offset++] = ((c1 >> 6) & 63) | 128;\n          buffer[offset++] = (c1 & 63) | 128;\n        } else {\n          buffer[offset++] = (c1 >> 12) | 224;\n          buffer[offset++] = ((c1 >> 6) & 63) | 128;\n          buffer[offset++] = (c1 & 63) | 128;\n        }\n      }\n      return buffer;\n    }\n\n    // A base64 implementation for the bcrypt algorithm. This is partly non-standard.\n\n    /**\n     * bcrypt's own non-standard base64 dictionary.\n     * @type {!Array.<string>}\n     * @const\n     * @inner\n     **/\n    var BASE64_CODE =\n      \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split(\n        \"\",\n      );\n\n    /**\n     * @type {!Array.<number>}\n     * @const\n     * @inner\n     **/\n    var BASE64_INDEX = [\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 54, 55, 56, 57, 58, 59, 60,\n      61, 62, 63, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n      12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, -1, -1,\n      -1, -1, -1, -1, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\n      42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, -1, -1, -1, -1, -1,\n    ];\n\n    /**\n     * Encodes a byte array to base64 with up to len bytes of input.\n     * @param {!Array.<number>} b Byte array\n     * @param {number} len Maximum input length\n     * @returns {string}\n     * @inner\n     */\n    function base64_encode(b, len) {\n      var off = 0,\n        rs = [],\n        c1,\n        c2;\n      if (len <= 0 || len > b.length) throw Error(\"Illegal len: \" + len);\n      while (off < len) {\n        c1 = b[off++] & 0xff;\n        rs.push(BASE64_CODE[(c1 >> 2) & 0x3f]);\n        c1 = (c1 & 0x03) << 4;\n        if (off >= len) {\n          rs.push(BASE64_CODE[c1 & 0x3f]);\n          break;\n        }\n        c2 = b[off++] & 0xff;\n        c1 |= (c2 >> 4) & 0x0f;\n        rs.push(BASE64_CODE[c1 & 0x3f]);\n        c1 = (c2 & 0x0f) << 2;\n        if (off >= len) {\n          rs.push(BASE64_CODE[c1 & 0x3f]);\n          break;\n        }\n        c2 = b[off++] & 0xff;\n        c1 |= (c2 >> 6) & 0x03;\n        rs.push(BASE64_CODE[c1 & 0x3f]);\n        rs.push(BASE64_CODE[c2 & 0x3f]);\n      }\n      return rs.join(\"\");\n    }\n\n    /**\n     * Decodes a base64 encoded string to up to len bytes of output.\n     * @param {string} s String to decode\n     * @param {number} len Maximum output length\n     * @returns {!Array.<number>}\n     * @inner\n     */\n    function base64_decode(s, len) {\n      var off = 0,\n        slen = s.length,\n        olen = 0,\n        rs = [],\n        c1,\n        c2,\n        c3,\n        c4,\n        o,\n        code;\n      if (len <= 0) throw Error(\"Illegal len: \" + len);\n      while (off < slen - 1 && olen < len) {\n        code = s.charCodeAt(off++);\n        c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n        code = s.charCodeAt(off++);\n        c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n        if (c1 == -1 || c2 == -1) break;\n        o = (c1 << 2) >>> 0;\n        o |= (c2 & 0x30) >> 4;\n        rs.push(String.fromCharCode(o));\n        if (++olen >= len || off >= slen) break;\n        code = s.charCodeAt(off++);\n        c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n        if (c3 == -1) break;\n        o = ((c2 & 0x0f) << 4) >>> 0;\n        o |= (c3 & 0x3c) >> 2;\n        rs.push(String.fromCharCode(o));\n        if (++olen >= len || off >= slen) break;\n        code = s.charCodeAt(off++);\n        c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;\n        o = ((c3 & 0x03) << 6) >>> 0;\n        o |= c4;\n        rs.push(String.fromCharCode(o));\n        ++olen;\n      }\n      var res = [];\n      for (off = 0; off < olen; off++) res.push(rs[off].charCodeAt(0));\n      return res;\n    }\n\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */\n    var BCRYPT_SALT_LEN = 16;\n\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */\n    var GENSALT_DEFAULT_LOG2_ROUNDS = 10;\n\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */\n    var BLOWFISH_NUM_ROUNDS = 16;\n\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */\n    var MAX_EXECUTION_TIME = 100;\n\n    /**\n     * @type {Array.<number>}\n     * @const\n     * @inner\n     */\n    var P_ORIG = [\n      0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0,\n      0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n      0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b,\n    ];\n\n    /**\n     * @type {Array.<number>}\n     * @const\n     * @inner\n     */\n    var S_ORIG = [\n      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,\n      0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,\n      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658,\n      0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,\n      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,\n      0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,\n      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6,\n      0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,\n      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c,\n      0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,\n      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1,\n      0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,\n      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a,\n      0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,\n      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,\n      0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,\n      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706,\n      0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,\n      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b,\n      0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,\n      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c,\n      0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,\n      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a,\n      0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,\n      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,\n      0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,\n      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8,\n      0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,\n      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33,\n      0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,\n      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0,\n      0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,\n      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777,\n      0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,\n      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,\n      0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,\n      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e,\n      0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,\n      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9,\n      0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,\n      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f,\n      0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,\n      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a, 0x4b7a70e9, 0xb5b32944,\n      0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,\n      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29,\n      0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,\n      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1, 0x4cdd2086, 0x8470eb26,\n      0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,\n      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c,\n      0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,\n      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd, 0xd19113f9, 0x7ca92ff6,\n      0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,\n      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f,\n      0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,\n      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 0xde9a771f, 0xd9930810,\n      0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,\n      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa,\n      0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,\n      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd, 0x71dff89e, 0x10314e55,\n      0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,\n      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1,\n      0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,\n      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a, 0xc6150eba, 0x94e2ea78,\n      0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,\n      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883,\n      0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,\n      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 0x1521b628, 0x29076170,\n      0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,\n      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7,\n      0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,\n      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 0x9b540b19, 0x875fa099,\n      0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,\n      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263,\n      0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,\n      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73, 0x5d4a14d9, 0xe864b7e3,\n      0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,\n      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7,\n      0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,\n      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285, 0x095bbf00, 0xad19489d,\n      0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,\n      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460,\n      0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,\n      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc, 0x9e447a2e, 0xc3453484,\n      0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,\n      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a,\n      0xe6e39f2b, 0xdb83adf7, 0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,\n      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a,\n      0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,\n      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785,\n      0x7fac6dd0, 0x31cb8504, 0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,\n      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900,\n      0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,\n      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9,\n      0xee39d7ab, 0x3b124e8b, 0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,\n      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397,\n      0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,\n      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9,\n      0x5ef47e1c, 0x9029317c, 0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,\n      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f,\n      0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,\n      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e,\n      0xaf664fd1, 0xcad18115, 0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,\n      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd,\n      0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,\n      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8,\n      0x991be14c, 0xdb6e6b0d, 0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,\n      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c,\n      0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,\n      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b,\n      0x12754ccc, 0x782ef11c, 0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,\n      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386,\n      0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,\n      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0,\n      0x7745ae04, 0xd736fccc, 0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,\n      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2,\n      0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,\n      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770,\n      0x8cd55591, 0xc902de4c, 0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,\n      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c,\n      0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,\n      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa,\n      0xa002b5c4, 0x0de6d027, 0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,\n      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63,\n      0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,\n      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9,\n      0x1ac15bb4, 0xd39eb8fc, 0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,\n      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4,\n      0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,\n      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742,\n      0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,\n      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79,\n      0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,\n      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a,\n      0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,\n      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,\n      0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,\n      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797,\n      0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,\n      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6,\n      0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,\n      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba,\n      0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,\n      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5,\n      0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,\n      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,\n      0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,\n      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd,\n      0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,\n      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb,\n      0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,\n      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc,\n      0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,\n      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc,\n      0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,\n      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,\n      0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,\n      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a,\n      0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,\n      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b,\n      0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\n      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e,\n      0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,\n      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623,\n      0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,\n      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,\n      0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,\n      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3,\n      0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,\n      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c,\n      0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,\n      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6,\n    ];\n\n    /**\n     * @type {Array.<number>}\n     * @const\n     * @inner\n     */\n    var C_ORIG = [\n      0x4f727068, 0x65616e42, 0x65686f6c, 0x64657253, 0x63727944, 0x6f756274,\n    ];\n\n    /**\n     * @param {Array.<number>} lr\n     * @param {number} off\n     * @param {Array.<number>} P\n     * @param {Array.<number>} S\n     * @returns {Array.<number>}\n     * @inner\n     */\n    function _encipher(lr, off, P, S) {\n      // This is our bottleneck: 1714/1905 ticks / 90% - see profile.txt\n      var n,\n        l = lr[off],\n        r = lr[off + 1];\n      l ^= P[0];\n\n      /*\n      for (var i=0, k=BLOWFISH_NUM_ROUNDS-2; i<=k;)\n          // Feistel substitution on left word\n          n  = S[l >>> 24],\n          n += S[0x100 | ((l >> 16) & 0xff)],\n          n ^= S[0x200 | ((l >> 8) & 0xff)],\n          n += S[0x300 | (l & 0xff)],\n          r ^= n ^ P[++i],\n          // Feistel substitution on right word\n          n  = S[r >>> 24],\n          n += S[0x100 | ((r >> 16) & 0xff)],\n          n ^= S[0x200 | ((r >> 8) & 0xff)],\n          n += S[0x300 | (r & 0xff)],\n          l ^= n ^ P[++i];\n      */\n\n      //The following is an unrolled version of the above loop.\n      //Iteration 0\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[1];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[2];\n      //Iteration 1\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[3];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[4];\n      //Iteration 2\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[5];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[6];\n      //Iteration 3\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[7];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[8];\n      //Iteration 4\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[9];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[10];\n      //Iteration 5\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[11];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[12];\n      //Iteration 6\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[13];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[14];\n      //Iteration 7\n      n = S[l >>> 24];\n      n += S[0x100 | ((l >> 16) & 0xff)];\n      n ^= S[0x200 | ((l >> 8) & 0xff)];\n      n += S[0x300 | (l & 0xff)];\n      r ^= n ^ P[15];\n      n = S[r >>> 24];\n      n += S[0x100 | ((r >> 16) & 0xff)];\n      n ^= S[0x200 | ((r >> 8) & 0xff)];\n      n += S[0x300 | (r & 0xff)];\n      l ^= n ^ P[16];\n      lr[off] = r ^ P[BLOWFISH_NUM_ROUNDS + 1];\n      lr[off + 1] = l;\n      return lr;\n    }\n\n    /**\n     * @param {Array.<number>} data\n     * @param {number} offp\n     * @returns {{key: number, offp: number}}\n     * @inner\n     */\n    function _streamtoword(data, offp) {\n      for (var i = 0, word = 0; i < 4; ++i)\n        (word = (word << 8) | (data[offp] & 0xff)),\n          (offp = (offp + 1) % data.length);\n      return {\n        key: word,\n        offp: offp,\n      };\n    }\n\n    /**\n     * @param {Array.<number>} key\n     * @param {Array.<number>} P\n     * @param {Array.<number>} S\n     * @inner\n     */\n    function _key(key, P, S) {\n      var offset = 0,\n        lr = [0, 0],\n        plen = P.length,\n        slen = S.length,\n        sw;\n      for (var i = 0; i < plen; i++)\n        (sw = _streamtoword(key, offset)),\n          (offset = sw.offp),\n          (P[i] = P[i] ^ sw.key);\n      for (i = 0; i < plen; i += 2)\n        (lr = _encipher(lr, 0, P, S)), (P[i] = lr[0]), (P[i + 1] = lr[1]);\n      for (i = 0; i < slen; i += 2)\n        (lr = _encipher(lr, 0, P, S)), (S[i] = lr[0]), (S[i + 1] = lr[1]);\n    }\n\n    /**\n     * Expensive key schedule Blowfish.\n     * @param {Array.<number>} data\n     * @param {Array.<number>} key\n     * @param {Array.<number>} P\n     * @param {Array.<number>} S\n     * @inner\n     */\n    function _ekskey(data, key, P, S) {\n      var offp = 0,\n        lr = [0, 0],\n        plen = P.length,\n        slen = S.length,\n        sw;\n      for (var i = 0; i < plen; i++)\n        (sw = _streamtoword(key, offp)),\n          (offp = sw.offp),\n          (P[i] = P[i] ^ sw.key);\n      offp = 0;\n      for (i = 0; i < plen; i += 2)\n        (sw = _streamtoword(data, offp)),\n          (offp = sw.offp),\n          (lr[0] ^= sw.key),\n          (sw = _streamtoword(data, offp)),\n          (offp = sw.offp),\n          (lr[1] ^= sw.key),\n          (lr = _encipher(lr, 0, P, S)),\n          (P[i] = lr[0]),\n          (P[i + 1] = lr[1]);\n      for (i = 0; i < slen; i += 2)\n        (sw = _streamtoword(data, offp)),\n          (offp = sw.offp),\n          (lr[0] ^= sw.key),\n          (sw = _streamtoword(data, offp)),\n          (offp = sw.offp),\n          (lr[1] ^= sw.key),\n          (lr = _encipher(lr, 0, P, S)),\n          (S[i] = lr[0]),\n          (S[i + 1] = lr[1]);\n    }\n\n    /**\n     * Internaly crypts a string.\n     * @param {Array.<number>} b Bytes to crypt\n     * @param {Array.<number>} salt Salt bytes to use\n     * @param {number} rounds Number of rounds\n     * @param {function(Error, Array.<number>=)=} callback Callback receiving the error, if any, and the resulting bytes. If\n     *  omitted, the operation will be performed synchronously.\n     *  @param {function(number)=} progressCallback Callback called with the current progress\n     * @returns {!Array.<number>|undefined} Resulting bytes if callback has been omitted, otherwise `undefined`\n     * @inner\n     */\n    function _crypt(b, salt, rounds, callback, progressCallback) {\n      var cdata = C_ORIG.slice(),\n        clen = cdata.length,\n        err;\n\n      // Validate\n      if (rounds < 4 || rounds > 31) {\n        err = Error(\"Illegal number of rounds (4-31): \" + rounds);\n        if (callback) {\n          nextTick(callback.bind(this, err));\n          return;\n        } else throw err;\n      }\n      if (salt.length !== BCRYPT_SALT_LEN) {\n        err = Error(\n          \"Illegal salt length: \" + salt.length + \" != \" + BCRYPT_SALT_LEN,\n        );\n        if (callback) {\n          nextTick(callback.bind(this, err));\n          return;\n        } else throw err;\n      }\n      rounds = (1 << rounds) >>> 0;\n      var P,\n        S,\n        i = 0,\n        j;\n\n      //Use typed arrays when available - huge speedup!\n      if (typeof Int32Array === \"function\") {\n        P = new Int32Array(P_ORIG);\n        S = new Int32Array(S_ORIG);\n      } else {\n        P = P_ORIG.slice();\n        S = S_ORIG.slice();\n      }\n      _ekskey(salt, b, P, S);\n\n      /**\n       * Calcualtes the next round.\n       * @returns {Array.<number>|undefined} Resulting array if callback has been omitted, otherwise `undefined`\n       * @inner\n       */\n      function next() {\n        if (progressCallback) progressCallback(i / rounds);\n        if (i < rounds) {\n          var start = Date.now();\n          for (; i < rounds; ) {\n            i = i + 1;\n            _key(b, P, S);\n            _key(salt, P, S);\n            if (Date.now() - start > MAX_EXECUTION_TIME) break;\n          }\n        } else {\n          for (i = 0; i < 64; i++)\n            for (j = 0; j < clen >> 1; j++) _encipher(cdata, j << 1, P, S);\n          var ret = [];\n          for (i = 0; i < clen; i++)\n            ret.push(((cdata[i] >> 24) & 0xff) >>> 0),\n              ret.push(((cdata[i] >> 16) & 0xff) >>> 0),\n              ret.push(((cdata[i] >> 8) & 0xff) >>> 0),\n              ret.push((cdata[i] & 0xff) >>> 0);\n          if (callback) {\n            callback(null, ret);\n            return;\n          } else return ret;\n        }\n        if (callback) nextTick(next);\n      }\n\n      // Async\n      if (typeof callback !== \"undefined\") {\n        next();\n\n        // Sync\n      } else {\n        var res;\n        while (true)\n          if (typeof (res = next()) !== \"undefined\") return res || [];\n      }\n    }\n\n    /**\n     * Internally hashes a password.\n     * @param {string} password Password to hash\n     * @param {?string} salt Salt to use, actually never null\n     * @param {function(Error, string=)=} callback Callback receiving the error, if any, and the resulting hash. If omitted,\n     *  hashing is performed synchronously.\n     *  @param {function(number)=} progressCallback Callback called with the current progress\n     * @returns {string|undefined} Resulting hash if callback has been omitted, otherwise `undefined`\n     * @inner\n     */\n    function _hash(password, salt, callback, progressCallback) {\n      var err;\n      if (typeof password !== \"string\" || typeof salt !== \"string\") {\n        err = Error(\"Invalid string / salt: Not a string\");\n        if (callback) {\n          nextTick(callback.bind(this, err));\n          return;\n        } else throw err;\n      }\n\n      // Validate the salt\n      var minor, offset;\n      if (salt.charAt(0) !== \"$\" || salt.charAt(1) !== \"2\") {\n        err = Error(\"Invalid salt version: \" + salt.substring(0, 2));\n        if (callback) {\n          nextTick(callback.bind(this, err));\n          return;\n        } else throw err;\n      }\n      if (salt.charAt(2) === \"$\")\n        (minor = String.fromCharCode(0)), (offset = 3);\n      else {\n        minor = salt.charAt(2);\n        if (\n          (minor !== \"a\" && minor !== \"b\" && minor !== \"y\") ||\n          salt.charAt(3) !== \"$\"\n        ) {\n          err = Error(\"Invalid salt revision: \" + salt.substring(2, 4));\n          if (callback) {\n            nextTick(callback.bind(this, err));\n            return;\n          } else throw err;\n        }\n        offset = 4;\n      }\n\n      // Extract number of rounds\n      if (salt.charAt(offset + 2) > \"$\") {\n        err = Error(\"Missing salt rounds\");\n        if (callback) {\n          nextTick(callback.bind(this, err));\n          return;\n        } else throw err;\n      }\n      var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10,\n        r2 = parseInt(salt.substring(offset + 1, offset + 2), 10),\n        rounds = r1 + r2,\n        real_salt = salt.substring(offset + 3, offset + 25);\n      password += minor >= \"a\" ? \"\\x00\" : \"\";\n      var passwordb = utf8Array(password),\n        saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);\n\n      /**\n       * Finishes hashing.\n       * @param {Array.<number>} bytes Byte array\n       * @returns {string}\n       * @inner\n       */\n      function finish(bytes) {\n        var res = [];\n        res.push(\"$2\");\n        if (minor >= \"a\") res.push(minor);\n        res.push(\"$\");\n        if (rounds < 10) res.push(\"0\");\n        res.push(rounds.toString());\n        res.push(\"$\");\n        res.push(base64_encode(saltb, saltb.length));\n        res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));\n        return res.join(\"\");\n      }\n\n      // Sync\n      if (typeof callback == \"undefined\")\n        return finish(_crypt(passwordb, saltb, rounds));\n      // Async\n      else {\n        _crypt(\n          passwordb,\n          saltb,\n          rounds,\n          function (err, bytes) {\n            if (err) callback(err, null);\n            else callback(null, finish(bytes));\n          },\n          progressCallback,\n        );\n      }\n    }\n\n    /**\n     * Encodes a byte array to base64 with up to len bytes of input, using the custom bcrypt alphabet.\n     * @function\n     * @param {!Array.<number>} bytes Byte array\n     * @param {number} length Maximum input length\n     * @returns {string}\n     */\n    function encodeBase64(bytes, length) {\n      return base64_encode(bytes, length);\n    }\n\n    /**\n     * Decodes a base64 encoded string to up to len bytes of output, using the custom bcrypt alphabet.\n     * @function\n     * @param {string} string String to decode\n     * @param {number} length Maximum output length\n     * @returns {!Array.<number>}\n     */\n    function decodeBase64(string, length) {\n      return base64_decode(string, length);\n    }\n    var _default = (_exports.default = {\n      setRandomFallback,\n      genSaltSync,\n      genSalt,\n      hashSync,\n      hash,\n      compareSync,\n      compare,\n      getRounds,\n      getSalt,\n      truncates,\n      encodeBase64,\n      decodeBase64,\n    });\n  },\n);\n\n\n//# sourceURL=webpack://gui/./node_modules/bcryptjs/umd/index.js?\n}");

/***/ }),

/***/ "./node_modules/crc-32/crc32.js":
/*!**************************************!*\
  !*** ./node_modules/crc-32/crc32.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\n/*exported CRC32 */\nvar CRC32;\n(function (factory) {\n\t/*jshint ignore:start */\n\t/*eslint-disable */\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif(true) {\n\t\t\tfactory(exports);\n\t\t} else // removed by dead control flow\n{}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n\t/*eslint-enable */\n\t/*jshint ignore:end */\n}(function(CRC32) {\nCRC32.version = '1.2.2';\n/*global Int32Array */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar T0 = signed_crc_table();\nfunction slice_by_16_tables(T) {\n\tvar c = 0, v = 0, n = 0, table = typeof Int32Array !== 'undefined' ? new Int32Array(4096) : new Array(4096) ;\n\n\tfor(n = 0; n != 256; ++n) table[n] = T[n];\n\tfor(n = 0; n != 256; ++n) {\n\t\tv = T[n];\n\t\tfor(c = 256 + n; c < 4096; c += 256) v = table[c] = (v >>> 8) ^ T[v & 0xFF];\n\t}\n\tvar out = [];\n\tfor(n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== 'undefined' ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);\n\treturn out;\n}\nvar TT = slice_by_16_tables(T0);\nvar T1 = TT[0],  T2 = TT[1],  T3 = TT[2],  T4 = TT[3],  T5 = TT[4];\nvar T6 = TT[5],  T7 = TT[6],  T8 = TT[7],  T9 = TT[8],  Ta = TT[9];\nvar Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];\nfunction crc32_bstr(bstr, seed) {\n\tvar C = seed ^ -1;\n\tfor(var i = 0, L = bstr.length; i < L;) C = (C>>>8) ^ T0[(C^bstr.charCodeAt(i++))&0xFF];\n\treturn ~C;\n}\n\nfunction crc32_buf(B, seed) {\n\tvar C = seed ^ -1, L = B.length - 15, i = 0;\n\tfor(; i < L;) C =\n\t\tTf[B[i++] ^ (C & 255)] ^\n\t\tTe[B[i++] ^ ((C >> 8) & 255)] ^\n\t\tTd[B[i++] ^ ((C >> 16) & 255)] ^\n\t\tTc[B[i++] ^ (C >>> 24)] ^\n\t\tTb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^\n\t\tT7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^\n\t\tT3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];\n\tL += 15;\n\twhile(i < L) C = (C>>>8) ^ T0[(C^B[i++])&0xFF];\n\treturn ~C;\n}\n\nfunction crc32_str(str, seed) {\n\tvar C = seed ^ -1;\n\tfor(var i = 0, L = str.length, c = 0, d = 0; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tC = (C>>>8) ^ T0[(C^c)&0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tC = (C>>>8) ^ T0[(C ^ (192|((c>>6)&31)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++)&1023;\n\t\t\tC = (C>>>8) ^ T0[(C ^ (240|((c>>8)&7)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((c>>2)&63)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(d&63)))&0xFF];\n\t\t} else {\n\t\t\tC = (C>>>8) ^ T0[(C ^ (224|((c>>12)&15)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|((c>>6)&63)))&0xFF];\n\t\t\tC = (C>>>8) ^ T0[(C ^ (128|(c&63)))&0xFF];\n\t\t}\n\t}\n\treturn ~C;\n}\nCRC32.table = T0;\n// $FlowIgnore\nCRC32.bstr = crc32_bstr;\n// $FlowIgnore\nCRC32.buf = crc32_buf;\n// $FlowIgnore\nCRC32.str = crc32_str;\n}));\n\n\n//# sourceURL=webpack://gui/./node_modules/crc-32/crc32.js?\n}");

/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof __webpack_require__.g !== 'undefined') {\n  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ws);\n\n\n//# sourceURL=webpack://gui/./node_modules/isomorphic-ws/browser.js?\n}");

/***/ }),

/***/ "./src/SmartHomeController.ts":
/*!************************************!*\
  !*** ./src/SmartHomeController.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartHomeController = void 0;\n// --- 1.    aether-client ---\nconst aether_client_1 = __webpack_require__(/*! aether-client/build/aether_client */ \"./node_modules/aether-client/build/aether_client.js\"); //    \n// --- 2.   API  DTOs ---\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./src/aether_api.ts\"); //\nclass EventEmitter {\n    constructor() {\n        this.listeners = [];\n    }\n    add(listener) { this.listeners.push(listener); }\n    fire(data) { this.listeners.forEach(l => l(data)); }\n}\n/**\n * -----------------------------------------------------------------\n *    GUI (V4 -  toApi)\n * -----------------------------------------------------------------\n */\nclass SmartHomeController {\n    constructor() {\n        // ---   ---\n        // ( )\n        this.onConnectionStateChange = new EventEmitter();\n        this.onDeviceListUpdate = new EventEmitter();\n        this.onDeviceStateChanged = new EventEmitter();\n        this.onPairingListUpdate = new EventEmitter();\n        this.onPairingRequested = new EventEmitter();\n        this.localApi = this.createLocalApi();\n    }\n    /**\n     * 1.   Aether    \" \"\n     */\n    connect(serviceUuidStr, registrationUriStr) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"Connecting to Aether network...\");\n            this.onConnectionStateChange.fire('connecting');\n            try {\n                this.serviceUuid = aether_client_1.UUID.fromString(serviceUuidStr);\n                const registrationUri = [registrationUriStr];\n                const clientConfig = new aether_client_1.ClientStateInMemory(this.serviceUuid, registrationUri, undefined, aether_client_1.aetherApi.CryptoLib.SODIUM);\n                this.client = new aether_client_1.AetherCloudClient(clientConfig, \"SmartHomeGUI\");\n                yield this.client.connect().toPromise(30000);\n                // 3.  \"\" (MessageNode)    ()\n                this.serviceNode = this.client.getMessageNode(this.serviceUuid, aether_client_1.MessageEventListenerDefault);\n                // 4.    :  toApi\n                //\n                //     :\n                // 1.  FastApiContext (this.apiContext),  , \n                //     (flush)     serviceNode.\n                // 2. \"\"  PUSH- (bufferIn)  \n                //      (this.localApi).\n                //\n                this.apiContext = this.serviceNode.toApi(aether_api_1.SmartHomeClientApi.META, this.localApi);\n                // 5.  C \"\" (stub)   API \n                //      apiContext,      4.\n                this.serviceApi = aether_api_1.SmartHomeServiceApi.META.makeRemote(this.apiContext);\n                // 6.   \n                this.serviceApi.register(aether_api_1.ClientType.GUI_CLIENT, [], []);\n                this.apiContext.flush(aether_client_1.AFuture.make()); //   (register)\n                console.log(\"Successfully connected and registered with SmartHomeService!\");\n                this.onConnectionStateChange.fire('connected');\n            }\n            catch (e) {\n                console.error(\"Failed to connect\", e);\n                this.onConnectionStateChange.fire('error');\n            }\n        });\n    }\n    // --- 2. ,    UI ---\n    // ( ,   flush)\n    fetchAllDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.serviceApi)\n                return;\n            try {\n                console.log(\"Fetching all devices...\");\n                const devices = yield this.serviceApi.getAllDevices().toPromise(10000);\n                console.log(\"Got devices:\", devices);\n                this.onDeviceListUpdate.fire(devices);\n                // .flush()  , .. .toPromise()   \n            }\n            catch (e) {\n                console.error(\"Failed to fetch devices\", e);\n            }\n        });\n    }\n    executeCommand(commutatorId, localActorId, commandPkg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.serviceApi)\n                return;\n            try {\n                this.serviceApi.executeActorCommand(commutatorId, localActorId, commandPkg);\n                this.apiContext.flush(aether_client_1.AFuture.make()); //  fire-and-forget\n            }\n            catch (e) {\n                console.error(\"Failed to execute command\", e);\n            }\n        });\n    }\n    fetchPendingPairings() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.serviceApi)\n                return;\n            try {\n                const pairings = yield this.serviceApi.getPendingPairings().toPromise(10000);\n                this.onPairingListUpdate.fire(pairings);\n            }\n            catch (e) {\n                console.error(\"Failed to fetch pending pairings\", e);\n            }\n        });\n    }\n    approvePairing(commutatorUuid) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.serviceApi)\n                return;\n            try {\n                this.serviceApi.approvePairing(commutatorUuid);\n                this.apiContext.flush(aether_client_1.AFuture.make()); //  fire-and-forget\n                // (  UI  )\n                this.fetchPendingPairings();\n                this.fetchAllDevices();\n            }\n            catch (e) {\n                console.error(\"Failed to approve pairing\", e);\n            }\n        });\n    }\n    refreshAllSensors() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.serviceApi)\n                return;\n            try {\n                console.log(\"Requesting sensor refresh...\");\n                this.serviceApi.refreshAllSensorStates();\n                this.apiContext.flush(aether_client_1.AFuture.make()); //  fire-and-forget\n            }\n            catch (e) {\n                console.error(\"Failed to request refresh\", e);\n            }\n        });\n    }\n    /**\n     * 3.  PUSH API (SmartHomeClientApi)\n     * ( )\n     */\n    createLocalApi() {\n        const self = this;\n        return new (class {\n            getRemoteApi() {\n                throw new Error('Method not implemented.');\n            }\n            deviceStateUpdated(device) {\n                console.log(\"PUSH received: deviceStateUpdated\", device.name);\n                self.onDeviceStateChanged.fire(device);\n            }\n            pairingRequested(pairingInfo) {\n                console.log(\"PUSH received: pairingRequested\", pairingInfo.commutatorId.toString());\n                self.onPairingRequested.fire(pairingInfo);\n            }\n        })();\n    }\n}\nexports.SmartHomeController = SmartHomeController;\n\n\n//# sourceURL=webpack://gui/./src/SmartHomeController.ts?\n}");

/***/ }),

/***/ "./src/aether_api.ts":
/*!***************************!*\
  !*** ./src/aether_api.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartHomeClientApiLocal = exports.SmartHomeClientApi = exports.SmartHomeCommutatorApiLocal = exports.SmartHomeCommutatorApi = exports.SmartHomeServiceApiLocal = exports.SmartHomeServiceApi = exports.SmartHomeServiceStream = exports.SmartHomeCommutatorStream = exports.SmartHomeClientStream = exports.Sensor = exports.PendingPairing = exports.HardwareSensor = exports.HardwareActor = exports.DeviceStateData = exports.Actor = exports.HardwareDevice = exports.Device = exports.ClientType = void 0;\nconst aether_client_1 = __webpack_require__(/*! aether-client */ \"./node_modules/aether-client/build/aether_client.js\");\nconst Impl = __importStar(__webpack_require__(/*! ./aether_api_impl */ \"./src/aether_api_impl.ts\"));\n// This is always relative\n/**\n * The type of client connecting to the service.\n */\nvar ClientType;\n(function (ClientType) {\n    ClientType[\"GUI_CLIENT\"] = \"GUI_CLIENT\";\n    ClientType[\"COMMUTATOR\"] = \"COMMUTATOR\";\n})(ClientType || (exports.ClientType = ClientType = {}));\n(function (ClientType) {\n    ClientType.META = new Impl.ClientTypeMetaImpl();\n})(ClientType || (exports.ClientType = ClientType = {}));\n/**\n * Base type for a \"Logical\" device known to the Service. This is the main DTO for the GUI.\n */\nclass Device {\n    /**\n     * Creates an instance of Device.\n     * @param id - number\n     * @param name - string\n     * @param commutatorId - UUID\n     * @param localDeviceId - number\n     * @param lastState - string\n     * @param lastUpdated - Date\n     */\n    constructor(id, name, commutatorId, localDeviceId, lastState, lastUpdated) {\n        this.id = id;\n        this.name = name;\n        this.commutatorId = commutatorId;\n        this.localDeviceId = localDeviceId;\n        this.lastState = lastState;\n        this.lastUpdated = lastUpdated;\n    }\n    getId() {\n        return this.id;\n    }\n    getName() {\n        return this.name;\n    }\n    getCommutatorId() {\n        return this.commutatorId;\n    }\n    getLocalDeviceId() {\n        return this.localDeviceId;\n    }\n    getLastState() {\n        return this.lastState;\n    }\n    getLastUpdated() {\n        return this.lastUpdated;\n    }\n    /**\n     * Calculates a hash code for a static instance of Device.\n     * @param {Device | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Device with another object.\n     * @param {Device | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.Device = Device;\nDevice.META = new Impl.DeviceMetaImpl();\n/**\n * Base type for a physical device attached to a Commutator.\n */\nclass HardwareDevice {\n    /**\n     * Creates an instance of HardwareDevice.\n     * @param localId - number\n     * @param descriptor - string\n     */\n    constructor(localId, descriptor) {\n        this.localId = localId;\n        this.descriptor = descriptor;\n    }\n    getLocalId() {\n        return this.localId;\n    }\n    getDescriptor() {\n        return this.descriptor;\n    }\n    /**\n     * Calculates a hash code for a static instance of HardwareDevice.\n     * @param {HardwareDevice | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        return obj.constructor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HardwareDevice with another object.\n     * @param {HardwareDevice | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        return v1.constructor.META.metaEquals(v1, v2);\n    }\n}\nexports.HardwareDevice = HardwareDevice;\nHardwareDevice.META = new Impl.HardwareDeviceMetaImpl();\n/**\n * A Logical Device that represents an Actor.\n *\n * @aetherTypeId 2\n */\nclass Actor extends Device {\n    getDeviceType() {\n        return \"ACTOR\";\n    }\n    getAetherTypeId() {\n        return 2;\n    }\n    /**\n     * Creates an instance of Actor.\n     * @param id - number\n     * @param name - string\n     * @param commutatorId - UUID\n     * @param localDeviceId - number\n     * @param lastState - string\n     * @param lastUpdated - Date\n     */\n    constructor(id, name, commutatorId, localDeviceId, lastState, lastUpdated) {\n        super(id, name, commutatorId, localDeviceId, lastState, lastUpdated);\n    }\n    /**\n     * Calculates a hash code for a static instance of Actor.\n     * @param {Actor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return Actor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Actor with another object.\n     * @param {Actor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return Actor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return Actor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return Actor.staticEquals(this, other);\n    }\n    toString(result) {\n        Actor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.Actor = Actor;\nActor.META_BODY = new Impl.ActorMetaBodyImpl();\nActor.META = new Impl.ActorMetaImpl();\n/**\n * A generic structure for reporting a device's state at a specific time.\n */\nclass DeviceStateData {\n    /**\n     * Creates an instance of DeviceStateData.\n     * @param value - string\n     * @param timestamp - Date\n     */\n    constructor(value, timestamp) {\n        this.value = value;\n        this.timestamp = timestamp;\n    }\n    getValue() {\n        return this.value;\n    }\n    getTimestamp() {\n        return this.timestamp;\n    }\n    /**\n     * Calculates a hash code for a static instance of DeviceStateData.\n     * @param {DeviceStateData | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return DeviceStateData.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of DeviceStateData with another object.\n     * @param {DeviceStateData | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return DeviceStateData.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return DeviceStateData.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return DeviceStateData.staticEquals(this, other);\n    }\n    toString(result) {\n        DeviceStateData.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.DeviceStateData = DeviceStateData;\nDeviceStateData.META_BODY = new Impl.DeviceStateDataMetaBodyImpl();\nDeviceStateData.META = DeviceStateData.META_BODY;\n/**\n * A physical device that performs actions.\n *\n * @aetherTypeId 2\n */\nclass HardwareActor extends HardwareDevice {\n    getHardwareType() {\n        return \"ACTOR\";\n    }\n    getAetherTypeId() {\n        return 2;\n    }\n    /**\n     * Creates an instance of HardwareActor.\n     * @param localId - number\n     * @param descriptor - string\n     */\n    constructor(localId, descriptor) {\n        super(localId, descriptor);\n    }\n    /**\n     * Calculates a hash code for a static instance of HardwareActor.\n     * @param {HardwareActor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HardwareActor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HardwareActor with another object.\n     * @param {HardwareActor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HardwareActor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HardwareActor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HardwareActor.staticEquals(this, other);\n    }\n    toString(result) {\n        HardwareActor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HardwareActor = HardwareActor;\nHardwareActor.META_BODY = new Impl.HardwareActorMetaBodyImpl();\nHardwareActor.META = new Impl.HardwareActorMetaImpl();\n/**\n * A physical device that reports data.\n *\n * @aetherTypeId 1\n */\nclass HardwareSensor extends HardwareDevice {\n    getHardwareType() {\n        return \"SENSOR\";\n    }\n    getAetherTypeId() {\n        return 1;\n    }\n    /**\n     * Creates an instance of HardwareSensor.\n     * @param localId - number\n     * @param descriptor - string\n     * @param unit - string\n     */\n    constructor(localId, descriptor, unit) {\n        super(localId, descriptor);\n        this.unit = unit;\n    }\n    getUnit() {\n        return this.unit;\n    }\n    /**\n     * Calculates a hash code for a static instance of HardwareSensor.\n     * @param {HardwareSensor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return HardwareSensor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of HardwareSensor with another object.\n     * @param {HardwareSensor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return HardwareSensor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return HardwareSensor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return HardwareSensor.staticEquals(this, other);\n    }\n    toString(result) {\n        HardwareSensor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.HardwareSensor = HardwareSensor;\nHardwareSensor.META_BODY = new Impl.HardwareSensorMetaBodyImpl();\nHardwareSensor.META = new Impl.HardwareSensorMetaImpl();\n/**\n * A DTO for summarizing a Commutator that is awaiting pairing approval.\n */\nclass PendingPairing {\n    /**\n     * Creates an instance of PendingPairing.\n     * @param commutatorId - UUID\n     * @param devices - HardwareDevice[]\n     */\n    constructor(commutatorId, devices) {\n        this.commutatorId = commutatorId;\n        this.devices = devices;\n        if (devices === null || devices === undefined)\n            throw new Error(`Field 'devices' cannot be null for type PendingPairing.`);\n    }\n    getCommutatorId() {\n        return this.commutatorId;\n    }\n    getDevices() {\n        return this.devices;\n    }\n    devicesContains(el) {\n        return this.devices.includes(el);\n    }\n    /**\n     * Calculates a hash code for a static instance of PendingPairing.\n     * @param {PendingPairing | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return PendingPairing.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of PendingPairing with another object.\n     * @param {PendingPairing | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return PendingPairing.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return PendingPairing.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return PendingPairing.staticEquals(this, other);\n    }\n    toString(result) {\n        PendingPairing.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.PendingPairing = PendingPairing;\nPendingPairing.META_BODY = new Impl.PendingPairingMetaBodyImpl();\nPendingPairing.META = PendingPairing.META_BODY;\n/**\n * A Logical Device that represents a Sensor.\n *\n * @aetherTypeId 1\n */\nclass Sensor extends Device {\n    getDeviceType() {\n        return \"SENSOR\";\n    }\n    getAetherTypeId() {\n        return 1;\n    }\n    /**\n     * Creates an instance of Sensor.\n     * @param id - number\n     * @param name - string\n     * @param commutatorId - UUID\n     * @param localDeviceId - number\n     * @param lastState - string\n     * @param lastUpdated - Date\n     * @param unit - string\n     */\n    constructor(id, name, commutatorId, localDeviceId, lastState, lastUpdated, unit) {\n        super(id, name, commutatorId, localDeviceId, lastState, lastUpdated);\n        this.unit = unit;\n    }\n    getUnit() {\n        return this.unit;\n    }\n    /**\n     * Calculates a hash code for a static instance of Sensor.\n     * @param {Sensor | null | undefined} obj - The object to hash.\n     * @returns {number} The hash code.\n     */\n    static staticHashCode(obj) {\n        return Sensor.META.metaHashCode(obj);\n    }\n    /**\n     * Compares a static instance of Sensor with another object.\n     * @param {Sensor | null | undefined} v1 - The first object.\n     * @param {any | null | undefined} v2 - The second object.\n     * @returns {boolean} True if the objects are equal.\n     */\n    static staticEquals(v1, v2) {\n        return Sensor.META.metaEquals(v1, v2);\n    }\n    /**\n     * Calculates a hash code for this object.\n     * @returns {number} The hash code.\n     */\n    hashCode() {\n        return Sensor.staticHashCode(this);\n    }\n    /**\n     * Checks if this object is equal to another.\n     * @param {any} other - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    equals(other) {\n        return Sensor.staticEquals(this, other);\n    }\n    toString(result) {\n        Sensor.META.metaToString(this, result);\n        return result;\n    }\n}\nexports.Sensor = Sensor;\nSensor.META_BODY = new Impl.SensorMetaBodyImpl();\nSensor.META = new Impl.SensorMetaImpl();\n/**\n * A stream of commands destined FOR the Client (GUI).\n */\nclass SmartHomeClientStream {\n    /**\n     * Creates an instance of SmartHomeClientStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    toString(result) {\n        SmartHomeClientStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!SmartHomeClientApi.META)\n            throw new Error(`META not found for API type SmartHomeClientApi`);\n        SmartHomeClientApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeClientStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = SmartHomeClientApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeClientStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new SmartHomeClientStream(encryptedData);\n    }\n}\nexports.SmartHomeClientStream = SmartHomeClientStream;\nSmartHomeClientStream.META = new Impl.SmartHomeClientStreamMetaImpl();\n/**\n * A stream of commands destined FOR the Commutator.\n */\nclass SmartHomeCommutatorStream {\n    /**\n     * Creates an instance of SmartHomeCommutatorStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    toString(result) {\n        SmartHomeCommutatorStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!SmartHomeCommutatorApi.META)\n            throw new Error(`META not found for API type SmartHomeCommutatorApi`);\n        SmartHomeCommutatorApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeCommutatorStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = SmartHomeCommutatorApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeCommutatorStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new SmartHomeCommutatorStream(encryptedData);\n    }\n}\nexports.SmartHomeCommutatorStream = SmartHomeCommutatorStream;\nSmartHomeCommutatorStream.META = new Impl.SmartHomeCommutatorStreamMetaImpl();\n/**\n * A stream of commands destined FOR the Service.\n */\nclass SmartHomeServiceStream {\n    /**\n     * Creates an instance of SmartHomeServiceStream.\n     * @param data - The raw byte data for this stream.\n     */\n    constructor(data) {\n        this.data = data;\n    }\n    toString(result) {\n        SmartHomeServiceStream.META.metaToString(this, result);\n        return result;\n    }\n    accept(context, provider, localApi) {\n        const decryptedData = provider(this.data);\n        const dataInStatic = new aether_client_1.DataInOutStatic(decryptedData);\n        if (!SmartHomeServiceApi.META)\n            throw new Error(`META not found for API type SmartHomeServiceApi`);\n        SmartHomeServiceApi.META.makeLocal_fromDataIn(context, dataInStatic, localApi);\n    }\n    static fromRemote(context, provider, remote, sendFuture) {\n        remote.executeAll(context, sendFuture);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeServiceStream(encryptedData);\n    }\n    static fromRemoteConsumer(context, provider, remoteConsumer) {\n        const api = SmartHomeServiceApi.META.makeRemote(context);\n        remoteConsumer(api);\n        const encryptedData = provider(context.remoteDataToArrayAsArray());\n        return new SmartHomeServiceStream(encryptedData);\n    }\n    static fromRemoteBytes(provider, remoteData) {\n        const encryptedData = provider(remoteData);\n        return new SmartHomeServiceStream(encryptedData);\n    }\n}\nexports.SmartHomeServiceStream = SmartHomeServiceStream;\nSmartHomeServiceStream.META = new Impl.SmartHomeServiceStreamMetaImpl();\nvar SmartHomeServiceApi;\n(function (SmartHomeServiceApi) {\n    SmartHomeServiceApi.META = new Impl.SmartHomeServiceApiMetaImpl();\n})(SmartHomeServiceApi || (exports.SmartHomeServiceApi = SmartHomeServiceApi = {}));\nclass SmartHomeServiceApiLocal {\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.SmartHomeServiceApiLocal = SmartHomeServiceApiLocal;\nvar SmartHomeCommutatorApi;\n(function (SmartHomeCommutatorApi) {\n    SmartHomeCommutatorApi.META = new Impl.SmartHomeCommutatorApiMetaImpl();\n})(SmartHomeCommutatorApi || (exports.SmartHomeCommutatorApi = SmartHomeCommutatorApi = {}));\nclass SmartHomeCommutatorApiLocal {\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.SmartHomeCommutatorApiLocal = SmartHomeCommutatorApiLocal;\nvar SmartHomeClientApi;\n(function (SmartHomeClientApi) {\n    SmartHomeClientApi.META = new Impl.SmartHomeClientApiMetaImpl();\n})(SmartHomeClientApi || (exports.SmartHomeClientApi = SmartHomeClientApi = {}));\nclass SmartHomeClientApiLocal {\n    getRemoteApi() {\n        return this.remoteApi;\n    }\n    constructor(remoteApi) {\n        this.remoteApi = remoteApi;\n    }\n}\nexports.SmartHomeClientApiLocal = SmartHomeClientApiLocal;\n\n\n//# sourceURL=webpack://gui/./src/aether_api.ts?\n}");

/***/ }),

/***/ "./src/aether_api_impl.ts":
/*!********************************!*\
  !*** ./src/aether_api_impl.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartHomeClientApiMetaImpl = exports.SmartHomeCommutatorApiMetaImpl = exports.SmartHomeServiceApiMetaImpl = exports.SmartHomeServiceStreamMetaImpl = exports.SmartHomeCommutatorStreamMetaImpl = exports.SmartHomeClientStreamMetaImpl = exports.SensorMetaImpl = exports.SensorMetaBodyImpl = exports.PendingPairingMetaBodyImpl = exports.HardwareSensorMetaImpl = exports.HardwareSensorMetaBodyImpl = exports.HardwareActorMetaImpl = exports.HardwareActorMetaBodyImpl = exports.DeviceStateDataMetaBodyImpl = exports.ActorMetaImpl = exports.ActorMetaBodyImpl = exports.HardwareDeviceMetaImpl = exports.DeviceMetaImpl = exports.ClientTypeMetaImpl = void 0;\nconst aether_client_1 = __webpack_require__(/*! aether-client */ \"./node_modules/aether-client/build/aether_client.js\");\nconst aether_api_1 = __webpack_require__(/*! ./aether_api */ \"./src/aether_api.ts\");\n// This is always relative\nclass ClientTypeMetaImpl {\n    serialize(_sCtx, obj, out) {\n        const values = Object.keys(aether_api_1.ClientType).filter(k => isNaN(parseInt(k)));\n        out.writeByte(values.indexOf(obj));\n    }\n    deserialize(_sCtx, in_) {\n        const ordinal = in_.readUByte();\n        const keys = Object.keys(aether_api_1.ClientType).filter(k => isNaN(parseInt(k)));\n        if (ordinal < 0 || ordinal >= keys.length)\n            throw new Error(`Invalid ordinal $ {\n            ordinal\n        }\n        for enum ClientType`);\n        return aether_api_1.ClientType[keys[ordinal]];\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_STRING.metaHashCode(obj);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_STRING.metaEquals(v1, v2);\n    }\n    metaToString(obj, res) {\n        res.add(obj);\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ClientTypeMetaImpl = ClientTypeMetaImpl;\nclass DeviceMetaImpl {\n    serialize(sCtx_0, obj_1, _out_2) {\n        const typeId = typeof obj_1.getAetherTypeId === 'function' ? obj_1.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Device' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_2.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.Sensor.META_BODY.serialize(sCtx_0, obj_1, _out_2);\n                break;\n            case 2:\n                aether_api_1.Actor.META_BODY.serialize(sCtx_0, obj_1, _out_2);\n                break;\n            default: throw new Error(`Cannot serialize 'Device' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_0, in__3) {\n        const typeId = in__3.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.Sensor.META_BODY.deserialize(sCtx_0, in__3);\n            case 2: return aether_api_1.Actor.META_BODY.deserialize(sCtx_0, in__3);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Device'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.Sensor.META.metaHashCode(obj);\n            case 2: return aether_api_1.Actor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Device' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.Sensor.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.Actor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Device' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.Sensor.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.Actor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Device' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.DeviceMetaImpl = DeviceMetaImpl;\nclass HardwareDeviceMetaImpl {\n    serialize(sCtx_4, obj_5, _out_6) {\n        const typeId = typeof obj_5.getAetherTypeId === 'function' ? obj_5.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HardwareDevice' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_6.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.HardwareSensor.META_BODY.serialize(sCtx_4, obj_5, _out_6);\n                break;\n            case 2:\n                aether_api_1.HardwareActor.META_BODY.serialize(sCtx_4, obj_5, _out_6);\n                break;\n            default: throw new Error(`Cannot serialize 'HardwareDevice' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_4, in__7) {\n        const typeId = in__7.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.HardwareSensor.META_BODY.deserialize(sCtx_4, in__7);\n            case 2: return aether_api_1.HardwareActor.META_BODY.deserialize(sCtx_4, in__7);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HardwareDevice'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.HardwareSensor.META.metaHashCode(obj);\n            case 2: return aether_api_1.HardwareActor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HardwareDevice' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.HardwareSensor.META.metaEquals(v1, v2);\n            case 2: return aether_api_1.HardwareActor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HardwareDevice' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.HardwareSensor.META.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HardwareActor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HardwareDevice' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HardwareDeviceMetaImpl = HardwareDeviceMetaImpl;\nclass ActorMetaBodyImpl {\n    serialize(sCtx_8, obj_9, _out_10) {\n        let _mask = 0;\n        if (obj_9.lastState === null)\n            _mask |= 1;\n        if (obj_9.lastUpdated === null)\n            _mask |= (1 << 1);\n        _out_10.writeByte(_mask);\n        _out_10.writeInt(obj_9.id);\n        const stringBytes_12 = new TextEncoder().encode(obj_9.name);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_10, stringBytes_12.length);\n        _out_10.write(stringBytes_12);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_8, obj_9.commutatorId, _out_10);\n        _out_10.writeInt(obj_9.localDeviceId);\n        if (obj_9.lastState !== null) {\n            const stringBytes_14 = new TextEncoder().encode(obj_9.lastState);\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_10, stringBytes_14.length);\n            _out_10.write(stringBytes_14);\n        }\n        if (obj_9.lastUpdated !== null) {\n            _out_10.writeLong(obj_9.lastUpdated.getTime());\n        }\n    }\n    deserialize(sCtx_8, in__11) {\n        let id_16;\n        let name_17;\n        let commutatorId_18;\n        let localDeviceId_19;\n        let lastState_20;\n        let lastUpdated_21;\n        const _mask = in__11.readByte();\n        id_16 = in__11.readInt();\n        let stringBytes_22;\n        const len_24 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__11).valueOf());\n        const bytes_25 = in__11.readBytes(len_24);\n        stringBytes_22 = bytes_25;\n        name_17 = new TextDecoder('utf-8').decode(stringBytes_22);\n        commutatorId_18 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_8, in__11);\n        localDeviceId_19 = in__11.readInt();\n        if (((_mask & 1) === 0)) {\n            let stringBytes_26;\n            const len_28 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__11).valueOf());\n            const bytes_29 = in__11.readBytes(len_28);\n            stringBytes_26 = bytes_29;\n            lastState_20 = new TextDecoder('utf-8').decode(stringBytes_26);\n        }\n        else {\n            lastState_20 = null;\n        }\n        if (((_mask & (1 << 1)) === 0)) {\n            lastUpdated_21 = new Date(Number(in__11.readLong()));\n        }\n        else {\n            lastUpdated_21 = null;\n        }\n        return new aether_api_1.Actor(id_16, name_17, commutatorId_18, localDeviceId_19, lastState_20, lastUpdated_21);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.name);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.commutatorId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.localDeviceId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.lastState);\n        hash = 37 * hash + aether_client_1.FastMeta.META_DATE.metaHashCode(obj.lastUpdated);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.Actor))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.name, v2.name))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.commutatorId, v2.commutatorId))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.localDeviceId, v2.localDeviceId))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.lastState, v2.lastState))\n            return false;\n        if (!aether_client_1.FastMeta.META_DATE.metaEquals(v1.lastUpdated, v2.lastUpdated))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('Actor(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('name:').add(obj.name);\n        res.add(', ');\n        res.add('commutatorId:').add(obj.commutatorId);\n        res.add(', ');\n        res.add('localDeviceId:').add(obj.localDeviceId);\n        res.add(', ');\n        res.add('lastState:').add(obj.lastState);\n        res.add(', ');\n        res.add('lastUpdated:').add(obj.lastUpdated);\n        res.add(', ');\n        res.add('deviceType:').add(obj.getDeviceType());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ActorMetaBodyImpl = ActorMetaBodyImpl;\nclass ActorMetaImpl {\n    serialize(sCtx_30, obj_31, _out_32) {\n        const typeId = typeof obj_31.getAetherTypeId === 'function' ? obj_31.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Actor' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_32.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.Actor.META_BODY.serialize(sCtx_30, obj_31, _out_32);\n                break;\n            case 1:\n                aether_api_1.Sensor.META_BODY.serialize(sCtx_30, obj_31, _out_32);\n                break;\n            default: throw new Error(`Cannot serialize 'Actor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_30, in__33) {\n        const typeId = in__33.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.Actor.META_BODY.deserialize(sCtx_30, in__33);\n            case 1: return aether_api_1.Sensor.META_BODY.deserialize(sCtx_30, in__33);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Actor'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.Actor.META_BODY.metaHashCode(obj);\n            case 1: return aether_api_1.Sensor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Actor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.Actor.META_BODY.metaEquals(v1, v2);\n            case 1: return aether_api_1.Sensor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Actor' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.Actor.META_BODY.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.Sensor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Actor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.ActorMetaImpl = ActorMetaImpl;\nclass DeviceStateDataMetaBodyImpl {\n    serialize(sCtx_34, obj_35, _out_36) {\n        const stringBytes_38 = new TextEncoder().encode(obj_35.value);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_36, stringBytes_38.length);\n        _out_36.write(stringBytes_38);\n        _out_36.writeLong(obj_35.timestamp.getTime());\n    }\n    deserialize(sCtx_34, in__37) {\n        let value_40;\n        let timestamp_41;\n        let stringBytes_42;\n        const len_44 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__37).valueOf());\n        const bytes_45 = in__37.readBytes(len_44);\n        stringBytes_42 = bytes_45;\n        value_40 = new TextDecoder('utf-8').decode(stringBytes_42);\n        timestamp_41 = new Date(Number(in__37.readLong()));\n        return new aether_api_1.DeviceStateData(value_40, timestamp_41);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.value);\n        hash = 37 * hash + aether_client_1.FastMeta.META_DATE.metaHashCode(obj.timestamp);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.DeviceStateData))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.value, v2.value))\n            return false;\n        if (!aether_client_1.FastMeta.META_DATE.metaEquals(v1.timestamp, v2.timestamp))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('DeviceStateData(');\n        res.add('value:').add(obj.value);\n        res.add(', ');\n        res.add('timestamp:').add(obj.timestamp);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.DeviceStateDataMetaBodyImpl = DeviceStateDataMetaBodyImpl;\nclass HardwareActorMetaBodyImpl {\n    serialize(sCtx_46, obj_47, _out_48) {\n        _out_48.writeInt(obj_47.localId);\n        const stringBytes_50 = new TextEncoder().encode(obj_47.descriptor);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_48, stringBytes_50.length);\n        _out_48.write(stringBytes_50);\n    }\n    deserialize(sCtx_46, in__49) {\n        let localId_52;\n        let descriptor_53;\n        localId_52 = in__49.readInt();\n        let stringBytes_54;\n        const len_56 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__49).valueOf());\n        const bytes_57 = in__49.readBytes(len_56);\n        stringBytes_54 = bytes_57;\n        descriptor_53 = new TextDecoder('utf-8').decode(stringBytes_54);\n        return new aether_api_1.HardwareActor(localId_52, descriptor_53);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.localId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.descriptor);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HardwareActor))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.localId, v2.localId))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.descriptor, v2.descriptor))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HardwareActor(');\n        res.add('localId:').add(obj.localId);\n        res.add(', ');\n        res.add('descriptor:').add(obj.descriptor);\n        res.add(', ');\n        res.add('hardwareType:').add(obj.getHardwareType());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HardwareActorMetaBodyImpl = HardwareActorMetaBodyImpl;\nclass HardwareActorMetaImpl {\n    serialize(sCtx_58, obj_59, _out_60) {\n        const typeId = typeof obj_59.getAetherTypeId === 'function' ? obj_59.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HardwareActor' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_60.writeByte(typeId);\n        switch (typeId) {\n            case 2:\n                aether_api_1.HardwareActor.META_BODY.serialize(sCtx_58, obj_59, _out_60);\n                break;\n            case 1:\n                aether_api_1.HardwareSensor.META_BODY.serialize(sCtx_58, obj_59, _out_60);\n                break;\n            default: throw new Error(`Cannot serialize 'HardwareActor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_58, in__61) {\n        const typeId = in__61.readUByte();\n        switch (typeId) {\n            case 2: return aether_api_1.HardwareActor.META_BODY.deserialize(sCtx_58, in__61);\n            case 1: return aether_api_1.HardwareSensor.META_BODY.deserialize(sCtx_58, in__61);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HardwareActor'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2: return aether_api_1.HardwareActor.META_BODY.metaHashCode(obj);\n            case 1: return aether_api_1.HardwareSensor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HardwareActor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 2: return aether_api_1.HardwareActor.META_BODY.metaEquals(v1, v2);\n            case 1: return aether_api_1.HardwareSensor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HardwareActor' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 2:\n                aether_api_1.HardwareActor.META_BODY.metaToString(obj, res);\n                break;\n            case 1:\n                aether_api_1.HardwareSensor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HardwareActor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HardwareActorMetaImpl = HardwareActorMetaImpl;\nclass HardwareSensorMetaBodyImpl {\n    serialize(sCtx_62, obj_63, _out_64) {\n        let _mask = 0;\n        if (obj_63.unit === null)\n            _mask |= 1;\n        _out_64.writeByte(_mask);\n        _out_64.writeInt(obj_63.localId);\n        const stringBytes_66 = new TextEncoder().encode(obj_63.descriptor);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_64, stringBytes_66.length);\n        _out_64.write(stringBytes_66);\n        if (obj_63.unit !== null) {\n            const stringBytes_68 = new TextEncoder().encode(obj_63.unit);\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_64, stringBytes_68.length);\n            _out_64.write(stringBytes_68);\n        }\n    }\n    deserialize(sCtx_62, in__65) {\n        let localId_70;\n        let descriptor_71;\n        let unit_72;\n        const _mask = in__65.readByte();\n        localId_70 = in__65.readInt();\n        let stringBytes_73;\n        const len_75 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__65).valueOf());\n        const bytes_76 = in__65.readBytes(len_75);\n        stringBytes_73 = bytes_76;\n        descriptor_71 = new TextDecoder('utf-8').decode(stringBytes_73);\n        if (((_mask & 1) === 0)) {\n            let stringBytes_77;\n            const len_79 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__65).valueOf());\n            const bytes_80 = in__65.readBytes(len_79);\n            stringBytes_77 = bytes_80;\n            unit_72 = new TextDecoder('utf-8').decode(stringBytes_77);\n        }\n        else {\n            unit_72 = null;\n        }\n        return new aether_api_1.HardwareSensor(localId_70, descriptor_71, unit_72);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.localId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.descriptor);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.unit);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.HardwareSensor))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.localId, v2.localId))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.descriptor, v2.descriptor))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.unit, v2.unit))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('HardwareSensor(');\n        res.add('localId:').add(obj.localId);\n        res.add(', ');\n        res.add('descriptor:').add(obj.descriptor);\n        res.add(', ');\n        res.add('unit:').add(obj.unit);\n        res.add(', ');\n        res.add('hardwareType:').add(obj.getHardwareType());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HardwareSensorMetaBodyImpl = HardwareSensorMetaBodyImpl;\nclass HardwareSensorMetaImpl {\n    serialize(sCtx_81, obj_82, _out_83) {\n        const typeId = typeof obj_82.getAetherTypeId === 'function' ? obj_82.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'HardwareSensor' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_83.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.HardwareSensor.META_BODY.serialize(sCtx_81, obj_82, _out_83);\n                break;\n            case 2:\n                aether_api_1.HardwareActor.META_BODY.serialize(sCtx_81, obj_82, _out_83);\n                break;\n            default: throw new Error(`Cannot serialize 'HardwareSensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_81, in__84) {\n        const typeId = in__84.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.HardwareSensor.META_BODY.deserialize(sCtx_81, in__84);\n            case 2: return aether_api_1.HardwareActor.META_BODY.deserialize(sCtx_81, in__84);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'HardwareSensor'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.HardwareSensor.META_BODY.metaHashCode(obj);\n            case 2: return aether_api_1.HardwareActor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'HardwareSensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.HardwareSensor.META_BODY.metaEquals(v1, v2);\n            case 2: return aether_api_1.HardwareActor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'HardwareSensor' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.HardwareSensor.META_BODY.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.HardwareActor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'HardwareSensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.HardwareSensorMetaImpl = HardwareSensorMetaImpl;\nclass PendingPairingMetaBodyImpl {\n    serialize(sCtx_85, obj_86, _out_87) {\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_85, obj_86.commutatorId, _out_87);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_87, obj_86.devices.length);\n        for (const el_89 of obj_86.devices) {\n            aether_api_1.HardwareDevice.META.serialize(sCtx_85, el_89, _out_87);\n        }\n    }\n    deserialize(sCtx_85, in__88) {\n        let commutatorId_90;\n        let devices_91;\n        commutatorId_90 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_85, in__88);\n        const len_93 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__88).valueOf());\n        devices_91 = new Array(len_93);\n        for (let idx_92 = 0; idx_92 < len_93; idx_92++) {\n            devices_91[idx_92] = aether_api_1.HardwareDevice.META.deserialize(sCtx_85, in__88);\n        }\n        return new aether_api_1.PendingPairing(commutatorId_90, devices_91);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.commutatorId);\n        hash = 37 * hash + aether_client_1.FastMeta.getMetaArray(aether_api_1.HardwareDevice.META).metaHashCode(obj.devices);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.PendingPairing))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.commutatorId, v2.commutatorId))\n            return false;\n        if (!aether_client_1.FastMeta.getMetaArray(aether_api_1.HardwareDevice.META).metaEquals(v1.devices, v2.devices))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('PendingPairing(');\n        res.add('commutatorId:').add(obj.commutatorId);\n        res.add(', ');\n        res.add('devices:').add(obj.devices);\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.PendingPairingMetaBodyImpl = PendingPairingMetaBodyImpl;\nclass SensorMetaBodyImpl {\n    serialize(sCtx_94, obj_95, _out_96) {\n        let _mask = 0;\n        if (obj_95.lastState === null)\n            _mask |= 1;\n        if (obj_95.lastUpdated === null)\n            _mask |= (1 << 1);\n        if (obj_95.unit === null)\n            _mask |= (1 << 2);\n        _out_96.writeByte(_mask);\n        _out_96.writeInt(obj_95.id);\n        const stringBytes_98 = new TextEncoder().encode(obj_95.name);\n        aether_client_1.SerializerPackNumber.INSTANCE.put(_out_96, stringBytes_98.length);\n        _out_96.write(stringBytes_98);\n        aether_client_1.FastMeta.META_UUID.serialize(sCtx_94, obj_95.commutatorId, _out_96);\n        _out_96.writeInt(obj_95.localDeviceId);\n        if (obj_95.lastState !== null) {\n            const stringBytes_100 = new TextEncoder().encode(obj_95.lastState);\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_96, stringBytes_100.length);\n            _out_96.write(stringBytes_100);\n        }\n        if (obj_95.lastUpdated !== null) {\n            _out_96.writeLong(obj_95.lastUpdated.getTime());\n        }\n        if (obj_95.unit !== null) {\n            const stringBytes_102 = new TextEncoder().encode(obj_95.unit);\n            aether_client_1.SerializerPackNumber.INSTANCE.put(_out_96, stringBytes_102.length);\n            _out_96.write(stringBytes_102);\n        }\n    }\n    deserialize(sCtx_94, in__97) {\n        let id_104;\n        let name_105;\n        let commutatorId_106;\n        let localDeviceId_107;\n        let lastState_108;\n        let lastUpdated_109;\n        let unit_110;\n        const _mask = in__97.readByte();\n        id_104 = in__97.readInt();\n        let stringBytes_111;\n        const len_113 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__97).valueOf());\n        const bytes_114 = in__97.readBytes(len_113);\n        stringBytes_111 = bytes_114;\n        name_105 = new TextDecoder('utf-8').decode(stringBytes_111);\n        commutatorId_106 = aether_client_1.FastMeta.META_UUID.deserialize(sCtx_94, in__97);\n        localDeviceId_107 = in__97.readInt();\n        if (((_mask & 1) === 0)) {\n            let stringBytes_115;\n            const len_117 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__97).valueOf());\n            const bytes_118 = in__97.readBytes(len_117);\n            stringBytes_115 = bytes_118;\n            lastState_108 = new TextDecoder('utf-8').decode(stringBytes_115);\n        }\n        else {\n            lastState_108 = null;\n        }\n        if (((_mask & (1 << 1)) === 0)) {\n            lastUpdated_109 = new Date(Number(in__97.readLong()));\n        }\n        else {\n            lastUpdated_109 = null;\n        }\n        if (((_mask & (1 << 2)) === 0)) {\n            let stringBytes_119;\n            const len_121 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(in__97).valueOf());\n            const bytes_122 = in__97.readBytes(len_121);\n            stringBytes_119 = bytes_122;\n            unit_110 = new TextDecoder('utf-8').decode(stringBytes_119);\n        }\n        else {\n            unit_110 = null;\n        }\n        return new aether_api_1.Sensor(id_104, name_105, commutatorId_106, localDeviceId_107, lastState_108, lastUpdated_109, unit_110);\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        let hash = 17;\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.id);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.name);\n        hash = 37 * hash + aether_client_1.FastMeta.META_UUID.metaHashCode(obj.commutatorId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_INT.metaHashCode(obj.localDeviceId);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.lastState);\n        hash = 37 * hash + aether_client_1.FastMeta.META_DATE.metaHashCode(obj.lastUpdated);\n        hash = 37 * hash + aether_client_1.FastMeta.META_STRING.metaHashCode(obj.unit);\n        return hash | 0;\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined || !(v2 instanceof aether_api_1.Sensor))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.id, v2.id))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.name, v2.name))\n            return false;\n        if (!aether_client_1.FastMeta.META_UUID.metaEquals(v1.commutatorId, v2.commutatorId))\n            return false;\n        if (!aether_client_1.FastMeta.META_INT.metaEquals(v1.localDeviceId, v2.localDeviceId))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.lastState, v2.lastState))\n            return false;\n        if (!aether_client_1.FastMeta.META_DATE.metaEquals(v1.lastUpdated, v2.lastUpdated))\n            return false;\n        if (!aether_client_1.FastMeta.META_STRING.metaEquals(v1.unit, v2.unit))\n            return false;\n        return true;\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('Sensor(');\n        res.add('id:').add(obj.id);\n        res.add(', ');\n        res.add('name:').add(obj.name);\n        res.add(', ');\n        res.add('commutatorId:').add(obj.commutatorId);\n        res.add(', ');\n        res.add('localDeviceId:').add(obj.localDeviceId);\n        res.add(', ');\n        res.add('lastState:').add(obj.lastState);\n        res.add(', ');\n        res.add('lastUpdated:').add(obj.lastUpdated);\n        res.add(', ');\n        res.add('unit:').add(obj.unit);\n        res.add(', ');\n        res.add('deviceType:').add(obj.getDeviceType());\n        res.add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SensorMetaBodyImpl = SensorMetaBodyImpl;\nclass SensorMetaImpl {\n    serialize(sCtx_123, obj_124, _out_125) {\n        const typeId = typeof obj_124.getAetherTypeId === 'function' ? obj_124.getAetherTypeId() : -1;\n        if (typeId === undefined || typeId < 0)\n            throw new Error(`Cannot serialize 'Sensor' with invalid type id $ {\n            typeId\n        }\n        `);\n        _out_125.writeByte(typeId);\n        switch (typeId) {\n            case 1:\n                aether_api_1.Sensor.META_BODY.serialize(sCtx_123, obj_124, _out_125);\n                break;\n            case 2:\n                aether_api_1.Actor.META_BODY.serialize(sCtx_123, obj_124, _out_125);\n                break;\n            default: throw new Error(`Cannot serialize 'Sensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    deserialize(sCtx_123, in__126) {\n        const typeId = in__126.readUByte();\n        switch (typeId) {\n            case 1: return aether_api_1.Sensor.META_BODY.deserialize(sCtx_123, in__126);\n            case 2: return aether_api_1.Actor.META_BODY.deserialize(sCtx_123, in__126);\n            default: throw new Error(`Bad type id $ {\n                typeId\n            }\n            for type 'Sensor'`);\n        }\n    }\n    metaHashCode(obj) {\n        if (obj === null || obj === undefined)\n            return 0;\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1: return aether_api_1.Sensor.META_BODY.metaHashCode(obj);\n            case 2: return aether_api_1.Actor.META.metaHashCode(obj);\n            default: throw new Error(`Cannot hashCode 'Sensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    metaEquals(v1, v2) {\n        if (v1 === v2)\n            return true;\n        if (v1 === null || v1 === undefined)\n            return (v2 === null || v2 === undefined);\n        if (v2 === null || v2 === undefined)\n            return false;\n        const typeId1 = v1.getAetherTypeId ? v1.getAetherTypeId() : -1;\n        const typeId2 = v2.getAetherTypeId ? v2.getAetherTypeId() : -1;\n        if (typeId1 === -1 || typeId1 !== typeId2)\n            return false;\n        switch (typeId1) {\n            case 1: return aether_api_1.Sensor.META_BODY.metaEquals(v1, v2);\n            case 2: return aether_api_1.Actor.META.metaEquals(v1, v2);\n            default: throw new Error(`Cannot equals 'Sensor' with unknown type id $ {\n                typeId1\n            }\n            `);\n        }\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        const typeId = typeof obj.getAetherTypeId === 'function' ? obj.getAetherTypeId() : -1;\n        switch (typeId) {\n            case 1:\n                aether_api_1.Sensor.META_BODY.metaToString(obj, res);\n                break;\n            case 2:\n                aether_api_1.Actor.META.metaToString(obj, res);\n                break;\n            default: throw new Error(`Cannot toString 'Sensor' with unknown type id $ {\n                typeId\n            }\n            `);\n        }\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SensorMetaImpl = SensorMetaImpl;\nclass SmartHomeClientStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.SmartHomeClientStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj === null || obj === void 0 ? void 0 : obj.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1 === null || v1 === void 0 ? void 0 : v1.data, (v2 instanceof aether_api_1.SmartHomeClientStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SmartHomeClientStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SmartHomeClientStreamMetaImpl = SmartHomeClientStreamMetaImpl;\nclass SmartHomeCommutatorStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.SmartHomeCommutatorStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj === null || obj === void 0 ? void 0 : obj.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1 === null || v1 === void 0 ? void 0 : v1.data, (v2 instanceof aether_api_1.SmartHomeCommutatorStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SmartHomeCommutatorStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SmartHomeCommutatorStreamMetaImpl = SmartHomeCommutatorStreamMetaImpl;\nclass SmartHomeServiceStreamMetaImpl {\n    serialize(ctx, obj, out) {\n        aether_client_1.FastMeta.META_ARRAY_BYTE.serialize(ctx, obj.data, out);\n    }\n    deserialize(ctx, in_) {\n        return new aether_api_1.SmartHomeServiceStream(aether_client_1.FastMeta.META_ARRAY_BYTE.deserialize(ctx, in_));\n    }\n    metaHashCode(obj) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaHashCode(obj === null || obj === void 0 ? void 0 : obj.data);\n    }\n    metaEquals(v1, v2) {\n        return aether_client_1.FastMeta.META_ARRAY_BYTE.metaEquals(v1 === null || v1 === void 0 ? void 0 : v1.data, (v2 instanceof aether_api_1.SmartHomeServiceStream) ? v2.data : v2);\n    }\n    metaToString(obj, res) {\n        if (obj === null || obj === undefined) {\n            res.add('null');\n            return;\n        }\n        res.add('SmartHomeServiceStream(').add('data:').add(obj.data).add(')');\n    }\n    serializeToBytes(obj) {\n        const d = new aether_client_1.DataInOut();\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        this.serialize(aether_client_1.FastFutureContextStub, obj, d);\n        return d.toArray();\n    }\n    deserializeFromBytes(data) {\n        const d = new aether_client_1.DataInOutStatic(data);\n        // FastFutureContextStub is imported in aether_api_impl.ts\n        return this.deserialize(aether_client_1.FastFutureContextStub, d);\n    }\n    loadFromFile(file) {\n        throw new Error(\"UnsupportedOperationException: loadFromFile requires Node.js/Filesystem access.\");\n    }\n}\nexports.SmartHomeServiceStreamMetaImpl = SmartHomeServiceStreamMetaImpl;\nclass SmartHomeServiceApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let type_128;\n                    let sensors_129;\n                    let actors_130;\n                    type_128 = aether_api_1.ClientType.META.deserialize(ctx, dataIn);\n                    const len_132 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn).valueOf());\n                    sensors_129 = new Array(len_132);\n                    for (let idx_131 = 0; idx_131 < len_132; idx_131++) {\n                        sensors_129[idx_131] = aether_api_1.HardwareSensor.META.deserialize(ctx, dataIn);\n                    }\n                    const len_134 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn).valueOf());\n                    actors_130 = new Array(len_134);\n                    for (let idx_133 = 0; idx_133 < len_134; idx_133++) {\n                        actors_130[idx_133] = aether_api_1.HardwareActor.META.deserialize(ctx, dataIn);\n                    }\n                    const argsNames_135 = [\"type\", \"sensors\", \"actors\"];\n                    const argsValues_136 = [type_128, sensors_129, actors_130];\n                    ctx.invokeLocalMethodBefore(\"register\", argsNames_135, argsValues_136);\n                    localApi.register(type_128, sensors_129, actors_130);\n                    ctx.invokeLocalMethodAfter(\"register\", null, argsNames_135, argsValues_136);\n                    break;\n                }\n                case 4: {\n                    const reqId_137 = dataIn.readInt();\n                    const argsNames_138 = [];\n                    const argsValues_139 = [];\n                    ctx.invokeLocalMethodBefore(\"getAllDevices\", argsNames_138, argsValues_139);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getAllDevices();\n                    ctx.invokeLocalMethodAfter(\"getAllDevices\", resultFuture, argsNames_138, argsValues_139);\n                    resultFuture.to((v_141) => {\n                        const data_140 = new aether_client_1.DataInOut();\n                        aether_client_1.SerializerPackNumber.INSTANCE.put(data_140, v_141.length);\n                        for (const el_142 of v_141) {\n                            aether_api_1.Device.META.serialize(ctx, el_142, data_140);\n                        }\n                        ctx.sendResultToRemote(reqId_137, data_140.toArray());\n                    });\n                    break;\n                }\n                case 5: {\n                    const reqId_143 = dataIn.readInt();\n                    let commutatorId_144;\n                    let localActorId_145;\n                    let pkg_146;\n                    commutatorId_144 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    localActorId_145 = dataIn.readInt();\n                    const len_148 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn).valueOf());\n                    const bytes_149 = dataIn.readBytes(len_148);\n                    pkg_146 = bytes_149;\n                    const argsNames_150 = [\"commutatorId\", \"localActorId\", \"pkg\"];\n                    const argsValues_151 = [commutatorId_144, localActorId_145, pkg_146];\n                    ctx.invokeLocalMethodBefore(\"executeActorCommand\", argsNames_150, argsValues_151);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.executeActorCommand(commutatorId_144, localActorId_145, pkg_146);\n                    ctx.invokeLocalMethodAfter(\"executeActorCommand\", resultFuture, argsNames_150, argsValues_151);\n                    resultFuture.to((v_153) => {\n                        const data_152 = new aether_client_1.DataInOut();\n                        aether_api_1.Actor.META.serialize(ctx, v_153, data_152);\n                        ctx.sendResultToRemote(reqId_143, data_152.toArray());\n                    });\n                    break;\n                }\n                case 6: {\n                    const reqId_154 = dataIn.readInt();\n                    const argsNames_155 = [];\n                    const argsValues_156 = [];\n                    ctx.invokeLocalMethodBefore(\"getPendingPairings\", argsNames_155, argsValues_156);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.getPendingPairings();\n                    ctx.invokeLocalMethodAfter(\"getPendingPairings\", resultFuture, argsNames_155, argsValues_156);\n                    resultFuture.to((v_158) => {\n                        const data_157 = new aether_client_1.DataInOut();\n                        aether_client_1.SerializerPackNumber.INSTANCE.put(data_157, v_158.length);\n                        for (const el_159 of v_158) {\n                            aether_api_1.PendingPairing.META.serialize(ctx, el_159, data_157);\n                        }\n                        ctx.sendResultToRemote(reqId_154, data_157.toArray());\n                    });\n                    break;\n                }\n                case 7: {\n                    let commutatorUuid_161;\n                    commutatorUuid_161 = aether_client_1.FastMeta.META_UUID.deserialize(ctx, dataIn);\n                    const argsNames_162 = [\"commutatorUuid\"];\n                    const argsValues_163 = [commutatorUuid_161];\n                    ctx.invokeLocalMethodBefore(\"approvePairing\", argsNames_162, argsValues_163);\n                    localApi.approvePairing(commutatorUuid_161);\n                    ctx.invokeLocalMethodAfter(\"approvePairing\", null, argsNames_162, argsValues_163);\n                    break;\n                }\n                case 8: {\n                    let localSensorId_165;\n                    let data_166;\n                    localSensorId_165 = dataIn.readInt();\n                    data_166 = aether_api_1.DeviceStateData.META.deserialize(ctx, dataIn);\n                    const argsNames_167 = [\"localSensorId\", \"data\"];\n                    const argsValues_168 = [localSensorId_165, data_166];\n                    ctx.invokeLocalMethodBefore(\"pushSensorData\", argsNames_167, argsValues_168);\n                    localApi.pushSensorData(localSensorId_165, data_166);\n                    ctx.invokeLocalMethodAfter(\"pushSensorData\", null, argsNames_167, argsValues_168);\n                    break;\n                }\n                case 9: {\n                    const argsNames_170 = [];\n                    const argsValues_171 = [];\n                    ctx.invokeLocalMethodBefore(\"refreshAllSensorStates\", argsNames_170, argsValues_171);\n                    localApi.refreshAllSensorStates();\n                    ctx.invokeLocalMethodAfter(\"refreshAllSensorStates\", null, argsNames_170, argsValues_171);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_172) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_172.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_172, register: (type, sensors, actors) => {\n                const dataOut_174 = new aether_client_1.DataInOut();\n                dataOut_174.writeByte(3);\n                const argsNames_176 = [\"type\", \"sensors\", \"actors\"];\n                const argsValues_177 = [type, sensors, actors];\n                sCtx_172.invokeRemoteMethodAfter(\"register\", null, argsNames_176, argsValues_177);\n                aether_api_1.ClientType.META.serialize(sCtx_172, type, dataOut_174);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_174, sensors.length);\n                for (const el_178 of sensors) {\n                    aether_api_1.HardwareSensor.META.serialize(sCtx_172, el_178, dataOut_174);\n                }\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_174, actors.length);\n                for (const el_179 of actors) {\n                    aether_api_1.HardwareActor.META.serialize(sCtx_172, el_179, dataOut_174);\n                }\n                sCtx_172.sendToRemote(dataOut_174.toArray());\n            },\n            getAllDevices: () => {\n                const dataOut_181 = new aether_client_1.DataInOut();\n                dataOut_181.writeByte(4);\n                const argsNames_183 = [];\n                const argsValues_184 = [];\n                const result_182 = aether_client_1.ARFuture.of();\n                sCtx_172.invokeRemoteMethodAfter(\"getAllDevices\", result_182, argsNames_183, argsValues_184);\n                const reqId_180 = sCtx_172.regFuture({\n                    onDone: (in_) => {\n                        result_182.tryDone(aether_client_1.FastMeta.getMetaArray(aether_api_1.Device.META).deserialize(sCtx_172, in_));\n                    },\n                    onError: (_in_) => {\n                        result_182.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_181.writeInt(reqId_180);\n                sCtx_172.sendToRemote(dataOut_181.toArray());\n                return result_182;\n            },\n            executeActorCommand: (commutatorId, localActorId, pkg) => {\n                const dataOut_186 = new aether_client_1.DataInOut();\n                dataOut_186.writeByte(5);\n                const argsNames_188 = [\"commutatorId\", \"localActorId\", \"pkg\"];\n                const argsValues_189 = [commutatorId, localActorId, pkg];\n                const result_187 = aether_client_1.ARFuture.of();\n                sCtx_172.invokeRemoteMethodAfter(\"executeActorCommand\", result_187, argsNames_188, argsValues_189);\n                const reqId_185 = sCtx_172.regFuture({\n                    onDone: (in_) => {\n                        result_187.tryDone(aether_api_1.Actor.META.deserialize(sCtx_172, in_));\n                    },\n                    onError: (_in_) => {\n                        result_187.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_186.writeInt(reqId_185);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_172, commutatorId, dataOut_186);\n                dataOut_186.writeInt(localActorId);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_186, pkg.length);\n                dataOut_186.write(pkg);\n                sCtx_172.sendToRemote(dataOut_186.toArray());\n                return result_187;\n            },\n            getPendingPairings: () => {\n                const dataOut_192 = new aether_client_1.DataInOut();\n                dataOut_192.writeByte(6);\n                const argsNames_194 = [];\n                const argsValues_195 = [];\n                const result_193 = aether_client_1.ARFuture.of();\n                sCtx_172.invokeRemoteMethodAfter(\"getPendingPairings\", result_193, argsNames_194, argsValues_195);\n                const reqId_191 = sCtx_172.regFuture({\n                    onDone: (in_) => {\n                        result_193.tryDone(aether_client_1.FastMeta.getMetaArray(aether_api_1.PendingPairing.META).deserialize(sCtx_172, in_));\n                    },\n                    onError: (_in_) => {\n                        result_193.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_192.writeInt(reqId_191);\n                sCtx_172.sendToRemote(dataOut_192.toArray());\n                return result_193;\n            },\n            approvePairing: (commutatorUuid) => {\n                const dataOut_197 = new aether_client_1.DataInOut();\n                dataOut_197.writeByte(7);\n                const argsNames_199 = [\"commutatorUuid\"];\n                const argsValues_200 = [commutatorUuid];\n                sCtx_172.invokeRemoteMethodAfter(\"approvePairing\", null, argsNames_199, argsValues_200);\n                aether_client_1.FastMeta.META_UUID.serialize(sCtx_172, commutatorUuid, dataOut_197);\n                sCtx_172.sendToRemote(dataOut_197.toArray());\n            },\n            pushSensorData: (localSensorId, data) => {\n                const dataOut_202 = new aether_client_1.DataInOut();\n                dataOut_202.writeByte(8);\n                const argsNames_204 = [\"localSensorId\", \"data\"];\n                const argsValues_205 = [localSensorId, data];\n                sCtx_172.invokeRemoteMethodAfter(\"pushSensorData\", null, argsNames_204, argsValues_205);\n                dataOut_202.writeInt(localSensorId);\n                aether_api_1.DeviceStateData.META.serialize(sCtx_172, data, dataOut_202);\n                sCtx_172.sendToRemote(dataOut_202.toArray());\n            },\n            refreshAllSensorStates: () => {\n                const dataOut_207 = new aether_client_1.DataInOut();\n                dataOut_207.writeByte(9);\n                const argsNames_209 = [];\n                const argsValues_210 = [];\n                sCtx_172.invokeRemoteMethodAfter(\"refreshAllSensorStates\", null, argsNames_209, argsValues_210);\n                sCtx_172.sendToRemote(dataOut_207.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.SmartHomeServiceApiMetaImpl = SmartHomeServiceApiMetaImpl;\nclass SmartHomeCommutatorApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    const argsNames_212 = [];\n                    const argsValues_213 = [];\n                    ctx.invokeLocalMethodBefore(\"confirmPairing\", argsNames_212, argsValues_213);\n                    localApi.confirmPairing();\n                    ctx.invokeLocalMethodAfter(\"confirmPairing\", null, argsNames_212, argsValues_213);\n                    break;\n                }\n                case 4: {\n                    const reqId_214 = dataIn.readInt();\n                    let localActorId_215;\n                    let pkg_216;\n                    localActorId_215 = dataIn.readInt();\n                    const len_218 = Number(aether_client_1.DeserializerPackNumber.INSTANCE.put(dataIn).valueOf());\n                    const bytes_219 = dataIn.readBytes(len_218);\n                    pkg_216 = bytes_219;\n                    const argsNames_220 = [\"localActorId\", \"pkg\"];\n                    const argsValues_221 = [localActorId_215, pkg_216];\n                    ctx.invokeLocalMethodBefore(\"executeActorCommand\", argsNames_220, argsValues_221);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.executeActorCommand(localActorId_215, pkg_216);\n                    ctx.invokeLocalMethodAfter(\"executeActorCommand\", resultFuture, argsNames_220, argsValues_221);\n                    resultFuture.to((v_223) => {\n                        const data_222 = new aether_client_1.DataInOut();\n                        aether_api_1.DeviceStateData.META.serialize(ctx, v_223, data_222);\n                        ctx.sendResultToRemote(reqId_214, data_222.toArray());\n                    });\n                    break;\n                }\n                case 5: {\n                    const reqId_224 = dataIn.readInt();\n                    let localDeviceId_225;\n                    localDeviceId_225 = dataIn.readInt();\n                    const argsNames_226 = [\"localDeviceId\"];\n                    const argsValues_227 = [localDeviceId_225];\n                    ctx.invokeLocalMethodBefore(\"queryState\", argsNames_226, argsValues_227);\n                    ctx.regLocalFuture();\n                    const resultFuture = localApi.queryState(localDeviceId_225);\n                    ctx.invokeLocalMethodAfter(\"queryState\", resultFuture, argsNames_226, argsValues_227);\n                    resultFuture.to((v_229) => {\n                        const data_228 = new aether_client_1.DataInOut();\n                        aether_api_1.DeviceStateData.META.serialize(ctx, v_229, data_228);\n                        ctx.sendResultToRemote(reqId_224, data_228.toArray());\n                    });\n                    break;\n                }\n                case 6: {\n                    const argsNames_231 = [];\n                    const argsValues_232 = [];\n                    ctx.invokeLocalMethodBefore(\"queryAllSensorStates\", argsNames_231, argsValues_232);\n                    localApi.queryAllSensorStates();\n                    ctx.invokeLocalMethodAfter(\"queryAllSensorStates\", null, argsNames_231, argsValues_232);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_233) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_233.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_233, confirmPairing: () => {\n                const dataOut_235 = new aether_client_1.DataInOut();\n                dataOut_235.writeByte(3);\n                const argsNames_237 = [];\n                const argsValues_238 = [];\n                sCtx_233.invokeRemoteMethodAfter(\"confirmPairing\", null, argsNames_237, argsValues_238);\n                sCtx_233.sendToRemote(dataOut_235.toArray());\n            },\n            executeActorCommand: (localActorId, pkg) => {\n                const dataOut_240 = new aether_client_1.DataInOut();\n                dataOut_240.writeByte(4);\n                const argsNames_242 = [\"localActorId\", \"pkg\"];\n                const argsValues_243 = [localActorId, pkg];\n                const result_241 = aether_client_1.ARFuture.of();\n                sCtx_233.invokeRemoteMethodAfter(\"executeActorCommand\", result_241, argsNames_242, argsValues_243);\n                const reqId_239 = sCtx_233.regFuture({\n                    onDone: (in_) => {\n                        result_241.tryDone(aether_api_1.DeviceStateData.META.deserialize(sCtx_233, in_));\n                    },\n                    onError: (_in_) => {\n                        result_241.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_240.writeInt(reqId_239);\n                dataOut_240.writeInt(localActorId);\n                aether_client_1.SerializerPackNumber.INSTANCE.put(dataOut_240, pkg.length);\n                dataOut_240.write(pkg);\n                sCtx_233.sendToRemote(dataOut_240.toArray());\n                return result_241;\n            },\n            queryState: (localDeviceId) => {\n                const dataOut_246 = new aether_client_1.DataInOut();\n                dataOut_246.writeByte(5);\n                const argsNames_248 = [\"localDeviceId\"];\n                const argsValues_249 = [localDeviceId];\n                const result_247 = aether_client_1.ARFuture.of();\n                sCtx_233.invokeRemoteMethodAfter(\"queryState\", result_247, argsNames_248, argsValues_249);\n                const reqId_245 = sCtx_233.regFuture({\n                    onDone: (in_) => {\n                        result_247.tryDone(aether_api_1.DeviceStateData.META.deserialize(sCtx_233, in_));\n                    },\n                    onError: (_in_) => {\n                        result_247.error(new Error(\"Remote call failed without a typed exception\"));\n                    }\n                });\n                dataOut_246.writeInt(reqId_245);\n                dataOut_246.writeInt(localDeviceId);\n                sCtx_233.sendToRemote(dataOut_246.toArray());\n                return result_247;\n            },\n            queryAllSensorStates: () => {\n                const dataOut_251 = new aether_client_1.DataInOut();\n                dataOut_251.writeByte(6);\n                const argsNames_253 = [];\n                const argsValues_254 = [];\n                sCtx_233.invokeRemoteMethodAfter(\"queryAllSensorStates\", null, argsNames_253, argsValues_254);\n                sCtx_233.sendToRemote(dataOut_251.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.SmartHomeCommutatorApiMetaImpl = SmartHomeCommutatorApiMetaImpl;\nclass SmartHomeClientApiMetaImpl {\n    makeLocal_fromDataIn(ctx, dataIn, localApi) {\n        while (dataIn.isReadable()) {\n            const commandId = dataIn.readUByte();\n            switch (commandId) {\n                case 0: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onDone(dataIn);\n                    break;\n                }\n                case 1: {\n                    const reqId = aether_client_1.FastMeta.META_REQUEST_ID.deserialize(ctx, dataIn);\n                    const futureRec = ctx.getFuture(reqId);\n                    if (futureRec)\n                        futureRec.onError(dataIn);\n                    break;\n                }\n                case 3: {\n                    let device_256;\n                    device_256 = aether_api_1.Device.META.deserialize(ctx, dataIn);\n                    const argsNames_257 = [\"device\"];\n                    const argsValues_258 = [device_256];\n                    ctx.invokeLocalMethodBefore(\"deviceStateUpdated\", argsNames_257, argsValues_258);\n                    localApi.deviceStateUpdated(device_256);\n                    ctx.invokeLocalMethodAfter(\"deviceStateUpdated\", null, argsNames_257, argsValues_258);\n                    break;\n                }\n                case 4: {\n                    let pairingInfo_260;\n                    pairingInfo_260 = aether_api_1.PendingPairing.META.deserialize(ctx, dataIn);\n                    const argsNames_261 = [\"pairingInfo\"];\n                    const argsValues_262 = [pairingInfo_260];\n                    ctx.invokeLocalMethodBefore(\"pairingRequested\", argsNames_261, argsValues_262);\n                    localApi.pairingRequested(pairingInfo_260);\n                    ctx.invokeLocalMethodAfter(\"pairingRequested\", null, argsNames_261, argsValues_262);\n                    break;\n                }\n                default: throw new Error(`Unknown command ID: $ {\n                    commandId\n                }\n                `);\n            }\n        }\n    }\n    makeLocal_fromBytes_ctxLocal(ctx, data) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), ctx.localApi);\n    }\n    makeLocal_fromBytes_ctx(ctx, data, localApi) {\n        this.makeLocal_fromDataIn(ctx, new aether_client_1.DataInOutStatic(data), localApi);\n    }\n    makeRemote(sCtx_263) {\n        const remoteApiImpl = {\n            flush: (sendFuture) => {\n                sCtx_263.flush(sendFuture || aether_client_1.AFuture.make());\n            },\n            getFastMetaContext: () => sCtx_263, deviceStateUpdated: (device) => {\n                const dataOut_265 = new aether_client_1.DataInOut();\n                dataOut_265.writeByte(3);\n                const argsNames_267 = [\"device\"];\n                const argsValues_268 = [device];\n                sCtx_263.invokeRemoteMethodAfter(\"deviceStateUpdated\", null, argsNames_267, argsValues_268);\n                aether_api_1.Device.META.serialize(sCtx_263, device, dataOut_265);\n                sCtx_263.sendToRemote(dataOut_265.toArray());\n            },\n            pairingRequested: (pairingInfo) => {\n                const dataOut_270 = new aether_client_1.DataInOut();\n                dataOut_270.writeByte(4);\n                const argsNames_272 = [\"pairingInfo\"];\n                const argsValues_273 = [pairingInfo];\n                sCtx_263.invokeRemoteMethodAfter(\"pairingRequested\", null, argsNames_272, argsValues_273);\n                aether_api_1.PendingPairing.META.serialize(sCtx_263, pairingInfo, dataOut_270);\n                sCtx_263.sendToRemote(dataOut_270.toArray());\n            },\n        };\n        return remoteApiImpl;\n    }\n}\nexports.SmartHomeClientApiMetaImpl = SmartHomeClientApiMetaImpl;\n\n\n//# sourceURL=webpack://gui/./src/aether_api_impl.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst SmartHomeController_1 = __webpack_require__(/*! ./SmartHomeController */ \"./src/SmartHomeController.ts\");\n// ---  (  ) ---\nconst SERVICE_UUID_STRING = \"A8348A48-64CC-A8EF-6902-090F446247C8\"; // UUID  Java- ()\nconst REGISTRATION_URI = \"ws://localhost:9011\"; // URI  mock-\n// ---   ---\nconst controller = new SmartHomeController_1.SmartHomeController();\n// ---   UI ---\ndocument.addEventListener('DOMContentLoaded', () => {\n    //     HTML-\n    const statusEl = document.getElementById('status-text');\n    const refreshButton = document.getElementById('refresh-button');\n    const commutatorsContainer = document.getElementById('commutators-container');\n    const pairingsContainer = document.getElementById('pairings-container');\n    const pairingsTitle = document.getElementById('pairings-title');\n    // 1.   :   \n    controller.onConnectionStateChange.add(state => {\n        statusEl.textContent = `: ${state}`;\n        if (state === 'connected') {\n            statusEl.style.color = 'green';\n            controller.fetchAllDevices();\n            controller.fetchPendingPairings();\n        }\n        else if (state === 'error') {\n            statusEl.style.color = 'red';\n        }\n    });\n    // 2.   :   \n    controller.onDeviceListUpdate.add(devices => {\n        console.log(\"Updating device list\", devices);\n        renderDeviceTree(devices);\n    });\n    // 3.   :    (PUSH)\n    controller.onDeviceStateChanged.add(device => {\n        console.log(\"Updating single device (PUSH)\", device);\n        const existingCard = document.getElementById(`device-${device.id}`);\n        if (existingCard) {\n            existingCard.replaceWith(createDeviceCard(device));\n        }\n        else {\n            //  ,   \n            controller.fetchAllDevices();\n        }\n    });\n    // 4.   :   \n    controller.onPairingListUpdate.add(pairings => {\n        console.log(\"Updating pairing list\", pairings);\n        renderPairingList(pairings);\n    });\n    // 5.   :     (PUSH)\n    controller.onPairingRequested.add(pairing => {\n        console.log(\"New pairing request (PUSH)\", pairing);\n        pairingsTitle.style.color = 'red'; //  \n        //    ,   \n        controller.fetchPendingPairings();\n    });\n    // 6.  \"\"\n    refreshButton.onclick = () => {\n        controller.refreshAllSensors();\n    };\n    // ---   HTML- ---\n    /**\n     * \"\"    -> \n     */\n    function renderDeviceTree(devices) {\n        commutatorsContainer.innerHTML = ''; // \n        if (devices.length === 0) {\n            commutatorsContainer.innerHTML = '<p>  .</p>';\n            return;\n        }\n        //  1:    commutatorId\n        const devicesByCommutator = new Map();\n        for (const device of devices) {\n            const commId = device.commutatorId.toString().toString();\n            if (!devicesByCommutator.has(commId)) {\n                devicesByCommutator.set(commId, []);\n            }\n            devicesByCommutator.get(commId).push(device);\n        }\n        //  2: \"\"    \n        for (const [commId, deviceList] of devicesByCommutator.entries()) {\n            const block = document.createElement('div');\n            block.className = 'commutator-block';\n            const title = document.createElement('h3');\n            title.className = 'commutator-title';\n            title.textContent = `: ${commId}`;\n            const grid = document.createElement('div');\n            grid.className = 'devices-grid';\n            deviceList.forEach(device => grid.appendChild(createDeviceCard(device)));\n            block.appendChild(title);\n            block.appendChild(grid);\n            commutatorsContainer.appendChild(block);\n        }\n    }\n    /**\n     * \"\"   \n     */\n    function renderPairingList(pairings) {\n        pairingsContainer.innerHTML = ''; // \n        if (pairings.length === 0) {\n            pairingsTitle.style.color = 'black';\n            pairingsContainer.innerHTML = '<p>  .</p>';\n            return;\n        }\n        pairingsTitle.style.color = 'red';\n        pairings.forEach(pairing => {\n            const div = document.createElement('div');\n            div.className = 'card pairing-card';\n            const devicesStr = pairing.devices.map(d => `<li>${d.descriptor} (${d.getHardwareType()})</li>`).join('');\n            div.innerHTML = `\n                <h4> </h4>\n                <small>${pairing.commutatorId.toString()}</small>\n                <p> :</p>\n                <ul>${devicesStr}</ul>\n            `;\n            const btnApprove = document.createElement('button');\n            btnApprove.textContent = \"\";\n            btnApprove.onclick = () => {\n                controller.approvePairing(pairing.commutatorId);\n            };\n            div.appendChild(btnApprove);\n            pairingsContainer.appendChild(div);\n        });\n    }\n    /**\n     *  HTML-    (Actor  Sensor)\n     */\n    function createDeviceCard(device) {\n        const div = document.createElement('div');\n        div.className = 'card';\n        div.id = `device-${device.id}`; //   ID\n        const isActor = device.getDeviceType() === 'ACTOR';\n        const unit = device.unit || ''; //  \n        div.innerHTML = `\n            <h4>${device.name}</h4>\n            <small>Comm-UUID: ${device.commutatorId.toString()}</small><br>\n            <small>Local-ID: ${device.localDeviceId} | Global-ID: ${device.id}</small>\n            <p>: <b>${device.getDeviceType()}</b></p>\n            <p>: <b>${device.lastState || 'N/A'}</b> ${unit}</p>\n            <p>: ${device.lastUpdated ? new Date(device.lastUpdated).toLocaleString() : 'N/A'}</p>\n        `;\n        if (isActor) {\n            const controls = document.createElement('div');\n            controls.style.marginTop = '10px';\n            const btnOn = document.createElement('button');\n            btnOn.textContent = \" (ON)\";\n            btnOn.onclick = () => {\n                const pkgOn = new Uint8Array([1]);\n                controller.executeCommand(device.commutatorId, device.localDeviceId, pkgOn);\n            };\n            const btnOff = document.createElement('button');\n            btnOff.textContent = \" (OFF)\";\n            btnOff.onclick = () => {\n                const pkgOff = new Uint8Array([0]);\n                controller.executeCommand(device.commutatorId, device.localDeviceId, pkgOff);\n            };\n            controls.appendChild(btnOn);\n            controls.appendChild(btnOff);\n            div.appendChild(controls);\n        }\n        return div;\n    }\n    // --- 7. ! ---\n    controller.connect(SERVICE_UUID_STRING, REGISTRATION_URI);\n}); //  DOMContentLoaded\n\n\n//# sourceURL=webpack://gui/./src/index.ts?\n}");

/***/ }),

/***/ "?7243":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://gui/crypto_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;